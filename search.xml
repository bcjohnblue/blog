<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>debounce 中的 this 指向</title>
    <url>/blog/2023/12/06/debounce-%E4%B8%AD%E7%9A%84-this-%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="什麼是-debounce"><a href="#什麼是-debounce" class="headerlink" title="什麼是 debounce ?"></a>什麼是 debounce ?</h2><p><code>debounce</code> 是一種用於防止事件處理過於頻繁發生的技術，常用於處理使用者輸入，例如按鍵事件或搜尋框的輸入事件。</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>以文字搜尋功能為例，使用者每次搜尋打的文字都會呼叫後端的 api 拿回資料，但通常使用者想搜尋的是最後打字的結果，而此時就適合使用 <code>debounce</code> 在一定時間過後才去真正的呼叫後端 api</p>
<p>以下面為例，搜尋框改變時，不會馬上觸發 <code>onInput</code> 方法，而是會等 500ms 後，如果搜尋框的文字沒有任何改變，才呼叫 <code>onInput</code> 方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onInput</span>=<span class="string">&quot;debounceInput&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onInput</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// call api...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="title function_">debounce</span>(onInput, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基礎版-debounce"><a href="#基礎版-debounce" class="headerlink" title="基礎版 - debounce"></a>基礎版 - debounce</h2><p>基礎的 <code>debounce</code> 是利用 <code>setTimeout</code> 延後 <code>fn</code> 函式的執行時間，等到 <code>delay</code> 時間過後才會實際呼叫 <code>fn</code> 函式執行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加-this-版-debounce"><a href="#添加-this-版-debounce" class="headerlink" title="添加 this 版 - debounce"></a>添加 this 版 - debounce</h2><p>以上的部分是 <code>debounce</code> 主要的功用，拿來避免事件頻繁的觸發，但這篇文章想講的是在 <code>debounce</code> 中的 <code>this</code> 指向</p>
<p>如果查看 <code>debounce</code> 相關的教學文章，會發現有些文章的 <code>debounce</code> 是這樣寫的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(self, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當使用 <code>debounce</code> 時如果沒有牽涉到 <code>this</code> 的指向，不論是 <strong>第一種基礎版</strong> 或是 <strong>第二種添加 this 版</strong> 的寫法都是一樣的，但如果牽扯到 <code>this</code> 的使用時就會有所差別</p>
<p>以下我們拿 vue2 的 option api 當作範例，來看看實際使用 <code>debounce</code> 時可能會遇到的 <code>this</code> 指向問題：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;debounceInput&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 寫法 1.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">onInput</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寫法 2.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寫法 3.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onInput</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newValue = event.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>直接先講結論，<strong>寫法 1.</strong> 及 <strong>寫法 2.</strong> 不論是使用 <strong>基礎版</strong> 或是 <strong>添加 this 版</strong> 的 <code>debounce</code>，都是可以正常運作的</p>
<p>但 <strong>寫法 3.</strong> 如果搭配上 <strong>基礎版 - debounce</strong> 時，在 <code>debounce</code> 函式中沒有處理 <code>this</code> 的指向，<code>this.onInput</code> 中的 <code>this</code> 等於 <code>undefined</code>，因此也就沒有 <code>onInput</code> 方法可以呼叫，會直接報錯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寫法 3.</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 這裡的 this 會等於 undefined，導致直接報錯</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br />

<p>以下我們來看看這三種寫法，<code>this</code> 的指向有什麼樣的差別：</p>
<h5 id="寫法-1"><a href="#寫法-1" class="headerlink" title="寫法 1."></a>寫法 1.</h5><p>第一種寫法 <code>this.onInput</code> 的 <code>this</code> 作用域是在 <code>mounted</code> 底下，所以 <code>this</code> 指向的是 <code>vue instance</code>，完全沒有問題</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">onInput</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<br />

<h5 id="寫法-2"><a href="#寫法-2" class="headerlink" title="寫法 2."></a>寫法 2.</h5><p>第二種寫法，在 <code>debounce</code> 裡使用了箭頭函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/#%E4%B8%8D%E5%90%88%E7%BE%A4%E7%9A%84%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F">箭頭函式在宣告它的地方的 this 是什麼，它的 this 就是什麼</a></p>
</blockquote>
<p>箭頭函式沒有自己的 <code>this</code>，在箭頭函式中的 <code>this</code> 指向就是在宣告它時的 <code>this</code>，也就是 <code>mounted</code> 中的 <code>this</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mounted: this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">arrowFn</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 這裡的 this 等同於第二行中 mounted 裡的 this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>所以第 5 行的 <code>this</code> 一樣會指向 <code>vue instance</code> 沒有問題</p>
<br />

<h5 id="寫法-3"><a href="#寫法-3" class="headerlink" title="寫法 3."></a>寫法 3.</h5><p>第三種寫法在 <code>debounce</code> 中使用了傳統的 <code>function</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://something-about-js-book.onejar99.com/day15#han-shu-zhi-hang-huan-jing-xia-function-context">在傳統的 function 執行環境下，this 的指向取決於函數怎麼被呼叫</a></p>
</blockquote>
<p>所以接下來我們需要先釐清 <code>debounce</code> 中的 <code>fn</code> 函式如何被呼叫，才能夠知道 <code>this.onInput</code> 的 <code>this</code> 是指向誰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>這裡我們回頭來看一開始寫的 <strong>基礎版 - debounce</strong>，可以看到 <code>fn</code> 在第 8 行被呼叫，而這裡呼叫 <code>fn</code> 的時候並沒有傳遞 <code>this</code> 的指向，因此在嚴格模式下 <code>fn</code> 函式中的 <code>this</code> 會是 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 這裡的 this 等於 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(fn);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>Refs.<br><a href="https://something-about-js-book.onejar99.com/day18#7.2.-jian-chan-hu-jiao-callback-function-yan-jin-mo-shi">簡單呼叫 Callback Function (嚴謹模式)</a></p>
<br />

<p>那麼 <strong>添加 this 版 - debounce</strong> 中的 <code>this</code> 指向又是怎麼運作的呢？</p>
<p>在 <code>debounce</code> 函式中的第 5 行將 <code>this</code> 暫存到 <code>self</code> 變數裡，接著又在第 ９ 行利用 <code>apply</code> 將 <code>fn</code> 函式中的 <code>this</code> 指向 <code>self</code>，因此最後 <code>fn</code> 中 <code>this</code> 的指向將等同於第 5 行的 <code>this</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(self, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>debounce</code> 中第 5 行的 <code>this</code> 又是從哪裡來的呢？</p>
<p>這裡我們可以看到呼叫 <code>debounce</code> 時指向的 <code>this</code> 是由 <code>this.debounceInput</code> 中的 <code>this</code> 來的，也就是 <code>vue instance</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">debounceInput</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">onInput</span>(event);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h5 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h5><p><code>this.debounceInput</code> 中的 <code>this</code> 會傳遞到 <code>debounce</code> 函式第 5 行中的 <code>this</code>，<code>this</code> 賦值給 <code>self</code> 後又會經由第 9 行的 <code>fn.apply</code> 將 <code>this</code> 指向傳遞到 <code>fn</code> 中，因此最後 <code>fn</code> 中的 <code>this.onInput</code> 中的 <code>this</code> 也就等同於 <code>this.debounceInput</code> 中的 <code>this</code></p>
<p>因此如果丟入 <code>debounce</code> 中的 <code>fn</code> 函式是採用傳統 <code>function</code> 的第三種寫法，這時 <code>debounce</code> 函式就必須正確的傳遞 <code>this</code> 指向 (<strong>添加 this 版 - debounce</strong>)，才能夠使得 <code>fn</code> 函式中的 <code>this</code> 正常運作</p>
<h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://codesandbox.io/p/devbox/debounce-9q6tlx?file=/src/App.vue:28,11">Demo</a></h5><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><code>debounce</code> 的教學文章有很多，但一直以來都不太懂為什麼有些文章使用 <code>fn.apply</code> 將 <code>this</code> 的指向傳入 <code>fn</code> 函式裡，而有些沒有。今天藉由 vue2 使用 <code>debounce</code> 的寫法，才瞭解傳遞 <code>this</code> 的指向是必要的</p>
<p>但現在的 vue3 或是 react16 後流行的 hooks 寫法，都幾乎不太會用到 <code>this</code>，因此可以放心不會遇到 <strong>寫法 3.</strong> 的這種 bug 了</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://something-about-js-book.onejar99.com/day21">Day 21：箭頭函數 (Arrow Functions) 的 this 和你想的不一樣 (1)</a><br><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a><br><a href="https://kuro.tw/posts/2017/10/12/What-is-THIS-in-JavaScript-%E4%B8%8A/">What’s THIS in JavaScript ? [上]</a></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>面試題</tag>
      </tags>
  </entry>
  <entry>
    <title>餘弦定理</title>
    <url>/blog/2023/12/10/%E9%A4%98%E5%BC%A6%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>餘弦定理是三角形中三邊長度與一個角的 <strong>餘弦值(cos)</strong> 的數學式，公式定義如下：</p>
<span id="more"></span>

<img src="三角形.png" width="50%" height="50%">
<br />
<img src="定義.png">

<h2 id="證明"><a href="#證明" class="headerlink" title="證明"></a><a href="https://www.mathcha.io/editor/6l5ZmHXkClosYltp1OknvCMqg4glSdpYg9NCzEOexK">證明</a></h2><img src="證明.png">

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://zh.wikipedia.org/zh-tw/%E9%A4%98%E5%BC%A6%E5%AE%9A%E7%90%86">wiki - 餘弦定理</a></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>理解 THREE.Plane 的平面方程式</title>
    <url>/blog/2023/12/19/%E7%90%86%E8%A7%A3-three-plane-%E7%9A%84%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://threejs.org/docs/index.html?q=Plane#api/en/math/Plane">THREE.Plane</a> 在 <code>threejs</code> 中用來表示數學上的平面</p>
<h2 id="數學中的平面方程式"><a href="#數學中的平面方程式" class="headerlink" title="數學中的平面方程式"></a>數學中的平面方程式</h2><p><code>a, b, c</code> 代表平面的<strong>法向量</strong>，<code>d</code> 是一個<strong>常數值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ax + by + cz + d = 0;</span><br></pre></td></tr></table></figure>

<h2 id="創建平面"><a href="#創建平面" class="headerlink" title="創建平面"></a>創建平面</h2><p>以下程式碼創建了一個 <code>y - 1 = 0</code> 的平面，法向量為 <code>[0, 1, 0]</code>，常數值為 <code>-1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">normalize</span>(), -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;normal&quot;</span>, plane.<span class="property">normal</span>); <span class="comment">// &#123;x: 0, y: 1, z: 0&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;constant&quot;</span>, plane.<span class="property">constant</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>這裡需要特別注意的是傳入<strong>法向量</strong>時需要將其轉換為<strong>單位向量</strong>，<code>[0, 10, 0]</code> 跟 <code>[0, 1, 0]</code> 在向量的定義上是一樣的，都是指向正 x 軸方向，但 <code>threejs</code> 要求在牽涉到<strong>法向量</strong>時都必須是<strong>單位向量</strong>，否則在某些運算上會錯誤，所以以上程式碼才刻意加了 <a href="https://threejs.org/docs/index.html?q=vector#api/en/math/Vector3.normalize">.normalize()</a></p>
<h2 id="Plane-的方法"><a href="#Plane-的方法" class="headerlink" title="Plane 的方法"></a>Plane 的方法</h2><h5 id="distanceToPoint-point-Vector3-Float"><a href="#distanceToPoint-point-Vector3-Float" class="headerlink" title="- distanceToPoint(point: Vector3): Float"></a><strong>- distanceToPoint(point: Vector3): Float</strong></h5><p>計算傳入的 <code>point</code> 與平面的距離</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> distanceToPoint = plane.<span class="title function_">distanceToPoint</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;distanceToPoint&quot;</span>, distanceToPoint); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>這裡就可以看出為什麼一開始傳入<strong>法向量</strong>要是單位向量，以下面的例子來看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> distanceToPoint = plane.<span class="title function_">distanceToPoint</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;distanceToPoint&quot;</span>, distanceToPoint); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<p><code>[0, 1, 0]</code> 與 <code>[0, 10, 0]</code> 在<strong>法向量</strong>的定義上是一樣的，所以計算出來的點與平面的距離應該要一樣，但這兩個寫法的結果卻完全不一樣，原因可以從 <code>threejs</code> 的 <a href="https://github.com/mrdoob/three.js/blob/e5c2a56d035df52b3b4d6f4a066e65bc1941f634/src/math/Plane.js#L90">distanceToPoint</a> 來查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">distanceToPoint</span>(<span class="params">point</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">normal</span>.<span class="title function_">dot</span>(point) + <span class="variable language_">this</span>.<span class="property">constant</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從 <code>threejs</code> 原始碼來看，假設 <code>point</code> 座標為 <code>(x0, y0, z0)</code>，計算 <code>distanceToPoint</code> 的數學式為：</p>
<p>$$ ax_0 + by_0 + cz_0 + d $$</p>
<p>但實際用數學計算某個點與平面的距離公式是：</p>
<p>$$ \frac{\lvert ax_0 + by_0 + cz_0 + d \rvert}{\sqrt{a^2+b^2+c^2}} $$</p>
<p>可以看出來差異就在分母的 $ \sqrt{a^2+b^2+c^2} $，而這個東西就是<strong>法向量</strong>的長度，當<strong>法向量</strong>為<strong>單位向量</strong>時分母會等於 <code>1</code>，如此一來使用 <code>threejs</code> 的 <code>distanceToPoint</code> 才會與數學計算的結果一致，這也就是為什麼 <code>threejs</code> 中的<strong>法向量</strong>都需要先自行轉換為<strong>單位向量</strong></p>
<h6 id="Refs"><a href="#Refs" class="headerlink" title="Refs."></a>Refs.</h6><p><a href="https://www.youtube.com/watch?v=CtDk_cg6u4A&t=208s">點到平面的距離公式推導</a><br><a href="https://github.com/mrdoob/three.js/pull/11821">Use unit norm when finding plane distanceToPoint</a></p>
<h5 id="projectPoint-point-Vector3-target-Vector3-Vector3"><a href="#projectPoint-point-Vector3-target-Vector3-Vector3" class="headerlink" title="- projectPoint(point:Vector3, target:Vector3): Vector3"></a><strong>- projectPoint(point:Vector3, target:Vector3): Vector3</strong></h5><p>計算空間中的某個點 <code>point</code> 投影到平面上的座標</p>
<ul>
<li><code>point</code> - 空間中的某個點 $(x_0, y_0, z_0)$</li>
<li><code>target</code> - 投影到平面的座標</li>
<li><code>回傳值</code> - 投影到平面的座標</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> projectPointTarget = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line"><span class="keyword">const</span> projectPoint = plane.<span class="title function_">projectPoint</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">  projectPointTarget,</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;projectPointTarget&quot;</span>, projectPointTarget); <span class="comment">// &#123;x: 1, y: 1, z: 0&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;projectPoint&quot;</span>, projectPoint); <span class="comment">// &#123;x: 1, y: 1, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="原始碼"><a href="#原始碼" class="headerlink" title="原始碼"></a><a href="https://github.com/mrdoob/three.js/blob/e5c2a56d035df52b3b4d6f4a066e65bc1941f634/src/math/Plane.js#L102">原始碼</a></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">projectPoint</span>(<span class="params"> point, target </span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> target.<span class="title function_">copy</span>( point ).<span class="title function_">addScaledVector</span>( <span class="variable language_">this</span>.<span class="property">normal</span>, - <span class="variable language_">this</span>.<span class="title function_">distanceToPoint</span>( point ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="數學推導"><a href="#數學推導" class="headerlink" title="數學推導"></a>數學推導</h6><!-- $$ x = x_0 - at $$ -->
<p>$ (x, y, z) &#x3D; (x_0 - at, y_0 - bt, z_0 - ct) $</p>
<p>$ ax + by + cz + d &#x3D; 0 $<br>$ a(x_0 - at) + b(y_0 - bt) + c(z_0 - ct) + d &#x3D; 0 $<br>$ ax_0 + by_0 + cz_0 - a^2t - b^2t - z^2t + d &#x3D; 0 $</p>
<p>&#x3D;&gt;<br>$$ t &#x3D; \frac{ax_0 + by_0 + cz_0 + d}{a^2+b^2+c^2} &#x3D; ax_0 + by_0 + cz_0 + d &#x3D; distanceToPoint(point) $$<br>$$ (x, y, z) &#x3D; (x_0 - at, y_0 - bt, z_0 - ct) &#x3D; (x_0, y_0, z_0) + (a, b, c) \cdot -distanceToPoint(point) $$</p>
<h6 id="Refs-1"><a href="#Refs-1" class="headerlink" title="Refs."></a>Refs.</h6><p><a href="https://www.youtube.com/watch?v=CtDk_cg6u4A&t=101s">點到平面的距離公式</a></p>
<h5 id="coplanarPoint-target-Vector3-Vector3"><a href="#coplanarPoint-target-Vector3-Vector3" class="headerlink" title="- coplanarPoint(target: Vector3): Vector3"></a><strong>- coplanarPoint(target: Vector3): Vector3</strong></h5><p>計算沿著原點方向投影到平面的共面點</p>
<ul>
<li><code>target</code> - 沿著原點方向投影到平面的共面點 $(x, y, z)$</li>
</ul>
<p><code>coplanarPoint</code> 的意思是共面點，代表這個點位於平面上，<code>coplanarPoint</code> 的概念跟 <code>projectPoint</code> 很像，差別在 <code>coplanarPoint</code> 投影到平面上的點是沿著原點的方向，而 <code>projectPoint</code> 是沿著平面<strong>法向量</strong>的方向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">normalize</span>(), -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line"><span class="keyword">const</span> coplanarPoint = plane.<span class="title function_">coplanarPoint</span>(target);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;target&quot;</span>, target); <span class="comment">// &#123;x: 0, y: 1, z: 0&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;coplanarPoint&quot;</span>, coplanarPoint); <span class="comment">// &#123;x: 0, y: 1, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="原始碼-1"><a href="#原始碼-1" class="headerlink" title="原始碼"></a><a href="https://github.com/mrdoob/three.js/blob/e5c2a56d035df52b3b4d6f4a066e65bc1941f634/src/math/Plane.js#L163">原始碼</a></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">coplanarPoint</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> target.<span class="title function_">copy</span>(<span class="variable language_">this</span>.<span class="property">normal</span>).<span class="title function_">multiplyScalar</span>(-<span class="variable language_">this</span>.<span class="property">constant</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="數學推導-1"><a href="#數學推導-1" class="headerlink" title="數學推導"></a>數學推導</h6><p>$ (x, y, z) &#x3D; (at, bt, ct) $</p>
<p>$ ax + by + cz + d &#x3D; 0 $<br>$ t \times (a^2+b^2+c^2) + d &#x3D; 0 $<br>$ t &#x3D; -d $</p>
<p>$ (x, y, z) &#x3D; (a, b, c) \times -d  $</p>
<h5 id="setFromNormalAndCoplanarPoint-normal-Vector3-point-Vector3"><a href="#setFromNormalAndCoplanarPoint-normal-Vector3-point-Vector3" class="headerlink" title="- setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3 )"></a><strong>- setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3 )</strong></h5><p>這個方法藉由提供平面的<strong>法向量</strong>及平面上某點的座標創建出平面</p>
<ul>
<li><code>normal</code> - 平面的<strong>法向量</strong> $(a, b, c)$</li>
<li><code>point</code> - 平面上某個點的座標 $(x, y, z)$</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Plane</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">normalize</span>(), -<span class="number">1</span>);</span><br><span class="line">plane.<span class="title function_">setFromNormalAndCoplanarPoint</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">normalize</span>(),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;plane.normal&quot;</span>, plane.<span class="property">normal</span>); <span class="comment">// &#123;x: 0, y: 1, z: 0&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;plane.constant&quot;</span>, plane.<span class="property">constant</span>); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<h6 id="原始碼-2"><a href="#原始碼-2" class="headerlink" title="原始碼"></a><a href="https://github.com/mrdoob/three.js/blob/e5c2a56d035df52b3b4d6f4a066e65bc1941f634/src/math/Plane.js#L39">原始碼</a></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setFromNormalAndCoplanarPoint</span>(<span class="params">normal, point</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">normal</span>.<span class="title function_">copy</span>( normal );</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">constant</span> = - point.<span class="title function_">dot</span>( <span class="variable language_">this</span>.<span class="property">normal</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="數學推導-2"><a href="#數學推導-2" class="headerlink" title="數學推導"></a>數學推導</h6><p>$ (a, b, c) \cdot (x, y, z) + d &#x3D; 0 $<br>$ d &#x3D; - (x, y, z) \cdot (a, b, c) $</p>
<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><ul>
<li><a href="https://codesandbox.io/p/devbox/threejs-plane-normal-r9qghf">Plane 視覺化呈現</a></li>
</ul>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>threejs r159</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.cnblogs.com/vadim-web/p/13353086.html">three.js 数学方法之Plane</a></li>
</ul>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>向量內積</title>
    <url>/blog/2023/12/11/%E5%90%91%E9%87%8F%E5%85%A7%E7%A9%8D/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>向量內積代表從其中一個向量投影到另一個向量</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/7/72/Scalarproduct.gif?20050309032222" width="250px" />

<span id="more"></span>

<br />
<img src="內積定義.png" width="250px" />

<h2 id="證明"><a href="#證明" class="headerlink" title="證明"></a><a href="https://www.mathcha.io/editor/m9wOQfkVSxps3Wcz3DN76c9x5ll2tkNZw7vH2OB0rg">證明</a></h2><p>利用 <a href="/blog/2023/12/10/餘弦定理/" target="_blank" rel="noreferrer noopenner">餘弦定理</a> 對內積進行證明</p>
<img src="三角形.png" width="80%" />
<br />
<img src="證明.png" width="60%" />

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a href="https://zh.wikipedia.org/zh-tw/%E7%82%B9%E7%A7%AF">維基百科-內積</a></li>
<li><a href="https://mcheng007.pixnet.net/blog/post/24934928">證明內積公式</a></li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>從程式碼角度來看 event loop</title>
    <url>/blog/2024/01/27/%E5%BE%9E%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A7%92%E5%BA%A6%E4%BE%86%E7%9C%8B-event-loop/</url>
    <content><![CDATA[<p>此為 <strong>event loop</strong> 系列文章 - 第 2 篇：</p>
<ol>
<li><a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制" target="_blank" rel="noreferrer noopenner">Javascript 中的 event loop 及瀏覽器渲染機制</a> </li>
<li><a href="/blog/2024/01/27/從程式碼角度來看-event-loop" target="_blank" rel="noreferrer noopenner">從程式碼角度來看 event loop</a> </li>
<li><a href="/blog/2024/02/04/使用原生的-queuemicrotask-處理微任務/" target="_blank" rel="noreferrer noopenner">使用原生的 queueMicrotask 處理微任務</a></li>
<li><a href="/blog/2024/02/05/vue-nexttick-中的-event-loop/" target="_blank" rel="noreferrer noopenner">Vue.nextTick() 中的 event loop</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介紹了 <strong>event loop</strong> 的運行原理，這篇文章希望藉由各種範例進一步體會 <strong>event loop</strong> 的執行順序</p>
<h2 id="各種不同的-event-loop-範例"><a href="#各種不同的-event-loop-範例" class="headerlink" title="各種不同的 event loop 範例"></a>各種不同的 event loop 範例</h2><h4 id="1-基本的-event-loop-執行順序"><a href="#1-基本的-event-loop-執行順序" class="headerlink" title="1. 基本的 event loop 執行順序"></a>1. 基本的 event loop 執行順序</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main script&#x27;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>步驟：</strong></p>
<ol>
<li>第 1 行的 <code>setTimeout</code> <code>callback</code> 會放入 <strong>宏任務佇列 (macrotask queue)</strong> 裡，等待之後執行</li>
<li>第 5 行的 <code>promise</code> <code>callback</code> 會放入 <strong>微任務佇列 (microtask queue)</strong> 裡，等待之後執行</li>
<li>第 9 行的 <code>main script</code> 同步執行，印出 <span class="log">main script</span></li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> ，執行步驟 2. 的 <code>callback</code>，印出 <span class="log">promise</span></li>
<li><strong>微任務佇列 (microtask queue)</strong> 為空，進入下一輪的 <strong>event loop</strong> 循環</li>
<li>此輪從 <strong>宏任務佇列 (macrotask queue)</strong> 挑出步驟 2. 的 <strong>宏任務 (macrotask)</strong> 執行，印出 <span class="log">timeout</span></li>
</ol>
<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;main script&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise&#x27;</span></span><br><span class="line"><span class="string">&#x27;timeout&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-基本的-promise-執行順序"><a href="#2-基本的-promise-執行順序" class="headerlink" title="2. 基本的 promise 執行順序"></a>2. 基本的 promise 執行順序</h4><p><a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/JavaScript/%E5%BC%82%E6%AD%A5/%E8%A6%81%E5%B0%B1%E6%9D%A545%E9%81%93Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E6%AC%A1%E7%88%BD%E5%88%B0%E5%BA%95.md#12-%E9%A2%98%E7%9B%AE%E4%BA%8C">來源</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p><strong>步驟：</strong></p>
<ol>
<li>首先執行第 1 行的 <code>new Promise</code> </li>
<li>第 2 行印出 <span class="log">1</span></li>
<li>第 3 行將 <code>promise</code> 的狀態設為 <code>resolved</code>，值為 <code>success</code></li>
<li>繼續往下執行 <code>promise</code> 裡的程式，遇到第 4 行印出 <span class="log">2</span></li>
<li>第 6 行 <code>promise</code> 的狀態已經為 <code>resolved</code>，將 <code>then</code> 後面的 <code>callback</code> 放入 <strong>微任務佇列 (microtask queue)</strong> 中</li>
<li>執行第 9 行，印出 <span class="log">4</span></li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> &#x3D;&gt; 執行步驟 5. 的 <code>callback</code></li>
<li>執行第 7 行，印出 <span class="log">3</span></li>
</ol>
<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="3-async-await-寫法的-promise"><a href="#3-async-await-寫法的-promise" class="headerlink" title="3. async await 寫法的 promise"></a>3. async await 寫法的 promise</h4><p><a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/JavaScript/%E5%BC%82%E6%AD%A5/%E8%A6%81%E5%B0%B1%E6%9D%A545%E9%81%93Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E6%AC%A1%E7%88%BD%E5%88%B0%E5%BA%95.md#51-%E9%A2%98%E7%9B%AE%E4%B8%80">來源</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>由於 <code>async await</code> 是 <code>promise</code> 的語法糖，所以以下兩種寫法是等價的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>步驟：</strong></p>
<ol>
<li>執行第 9 行 <code>async1</code> 函式</li>
<li>進入 <code>async1</code> 函式，執行第 2 行，印出 <span class="log">async1 start</span></li>
<li>執行第 3 行 <code>async2</code> 函式</li>
<li>進入 <code>async2</code> 函式，執行第 7 行，印出 <span class="log">async2</span></li>
<li><code>async2</code> 函式結束回傳 <code>Promise &#123;&lt;fulfilled&gt;: undefined&#125;</code></li>
<li>回到第 3 行 <code>async2</code> 函式，將第 3 行後的程式放入 <strong>微任務佇列 (microtask queue)</strong> 中</li>
<li><code>async1</code> 函式結束，回到第 9 行</li>
<li>執行第 10 行，印出 <span class="log">start</span></li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> &#x3D;&gt; 執行步驟 6. 的程式</li>
<li>執行第 4 行，印出 <span class="log">async1 end</span></li>
</ol>
<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;async1 start&#x27;</span></span><br><span class="line"><span class="string">&#x27;async2&#x27;</span></span><br><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;async1 end&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-在-promise-中添加長時間的任務執行"><a href="#4-在-promise-中添加長時間的任務執行" class="headerlink" title="4. 在 promise 中添加長時間的任務執行"></a>4. 在 promise 中添加長時間的任務執行</h4><p><a href="https://www.zhihu.com/question/36972010">來源</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>步驟：</strong></p>
<ol>
<li>執行第 1 行將 <code>setTimeout</code> 的 <code>callback</code> 放入 <strong>宏任務佇列 (macrotask queue)</strong> 中</li>
<li>執行第 5 行的 <code>promise</code></li>
<li>執行第 6 行，印出 <span class="log">1</span></li>
<li>第 7-9 行，執行一段長時間的程式後第 8 行將 <code>promise</code> <code>resolve</code></li>
<li>執行第 10 行，印出 <span class="log">2</span></li>
<li>將第 11 行 <code>then</code> 後的 <code>callback</code> 放入 <strong>微任務佇列 (microtask queue)</strong> 中</li>
<li>執行第 15 行，印出 <span class="log">3</span></li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> &#x3D;&gt; 執行步驟 6. 的 <code>callback</code></li>
<li>執行第 12 行，印出 <span class="log">5</span></li>
<li>當輪 <strong>event loop</strong> 結束<br>&nbsp;</li>
<li><strong>event loop</strong> 挑出下一輪 <strong>宏任務佇列 (macrotask queue)</strong> 中的第一個 <strong>宏任務 (macrotask)</strong> &#x3D;&gt; 執行步驟 1. 的 <code>callback</code></li>
<li>執行第 2 行，印出 <span class="log">4</span></li>
</ol>
<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="5-promise-與-setTimeout-的互相執行"><a href="#5-promise-與-setTimeout-的互相執行" class="headerlink" title="5. promise 與 setTimeout 的互相執行"></a>5. promise 與 setTimeout 的互相執行</h4><p><a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/JavaScript/%E5%BC%82%E6%AD%A5/%E8%A6%81%E5%B0%B1%E6%9D%A545%E9%81%93Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E6%AC%A1%E7%88%BD%E5%88%B0%E5%BA%95.md#23-%E9%A2%98%E7%9B%AE%E4%B8%89-1">來源</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>步驟：</strong></p>
<ol>
<li>首先第 1 行將 <code>promise.resolve</code> 後的 <code>callback</code> 放入 <strong>微任務佇列 (microtask queue)</strong> 中</li>
<li>執行第 7 行將 <code>timer1</code> 的 <code>callback</code> 放入 <strong>宏任務佇列 (macrotask queue)</strong> 中</li>
<li>執行第 13 行，印出 <span class="log">start</span></li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> &#x3D;&gt; 執行步驟 1. 的 <code>callback</code></li>
<li>執行第 2 行，印出 <span class="log">promise1</span></li>
<li>執行第 3 行將 <code>timer2</code> 的 <code>callback</code> 放入 <strong>宏任務佇列 (macrotask queue)</strong> 中</li>
<li>當輪 <strong>event loop</strong> 結束<br>&nbsp;</li>
<li><strong>event loop</strong> 挑出下一輪 <strong>宏任務佇列 (macrotask queue)</strong> 中的第一個 <strong>宏任務 (macrotask)</strong> &#x3D;&gt; 執行步驟 2. 的 <code>callback</code></li>
<li>執行第 8 行，印出 <span class="log">timer1</span></li>
<li>執行第 9 行將 <code>promise.resolve</code> 後的 <code>callback</code> 放入 <strong>微任務佇列 (microtask queue)</strong> 中</li>
<li><strong>event loop</strong> 挑出當輪 <strong>微任務佇列 (microtask queue)</strong> 的所有 <strong>微任務 (microtask)</strong> &#x3D;&gt; 執行步驟 10. 的 <code>callback</code></li>
<li>執行第 10 行，印出 <span class="log">promise2</span></li>
<li>當輪 <strong>event loop</strong> 結束<br>&nbsp;</li>
<li><strong>event loop</strong> 挑出下一輪 <strong>宏任務佇列 (macrotask queue)</strong> 的所有 <strong>宏任務 (macrotask)</strong> &#x3D;&gt; 執行步驟 6. 的 <code>callback</code></li>
<li>執行第 4 行，印出 <span class="log">timer2</span></li>
</ol>
<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise1&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer1&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise2&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer2&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="不同狀況下的-event-loop-範例"><a href="#不同狀況下的-event-loop-範例" class="headerlink" title="不同狀況下的 event loop 範例"></a>不同狀況下的 event loop 範例</h2><p>以上範例單純只牽涉到 <strong>宏任務 (macrotask)</strong> 與 <strong>微任務 (microtask)</strong> 時，根據 <strong>event loop</strong> 的規則，執行的順序會是固定的，但如果牽涉到頁面的渲染，使用到 <code>requestAnimationFrame</code> 時，執行的順序就不是那麼絕對的了，以下我們來看看這些狀況：</p>
<h4 id="1-setTimeout-與-requestAnimationFrame"><a href="#1-setTimeout-與-requestAnimationFrame" class="headerlink" title="1. setTimeout 與 requestAnimationFrame"></a>1. setTimeout 與 requestAnimationFrame</h4><p><a href="https://intspirit.medium.com/understanding-the-browsers-event-loop-for-building-high-performance-web-applications-part-1-fe4b573a1520#:~:text=the%20rendering%20step.-,Quiz%201.,-Try%20to%20guess">來源</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout 1&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;requestAnimationFrame&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout 2&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;D&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>首先這一段程式執行後，畫面最後印出來的會是 A, B, C 或是 D 呢？</p>
<img src="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制/event-loop-60fps.png" width="50%">

<p>先貼一張 <a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制#event-loop-的全貌" target="_blank" rel="noreferrer noopenner">Javascript 中的 event loop 及瀏覽器渲染機制</a> 來複習 <strong>event loop</strong> 循環的全貌，以上程式使用到的 <code>requestAnimationFrame</code> 會在每一幀渲染畫面 <strong>之前</strong> 執行，所以我們會認為它執行的順序是：</p>
<p><strong>步驟：</strong></p>
<ol>
<li>第 1 行的 <code>setTimeout</code> <code>callback</code> 會放入 <strong>宏任務佇列 (macrotask queue)</strong> 裡，等待之後執行</li>
<li>第 6 行的 <code>requestAnimationFrame</code> <code>callback</code> 會等待下一次畫面渲染前執行</li>
<li>第 11 行的 <code>setTimeout</code> <code>callback</code> 會放入 <strong>宏任務佇列 (macrotask queue)</strong> 裡，等待之後執行</li>
<li>執行第 16, 17 行</li>
<li>接著當輪的 <strong>宏任務佇列 (macrotask queue)</strong> 都執行完了，所以會看 <strong>微任務佇列 (microtask queue)</strong> 中有沒有 <strong>微任務 (microtask)</strong> 要執行</li>
<li>因爲程式碼中沒有 <strong>微任務 (microtask)</strong> &#x3D;&gt; <strong>微任務佇列 (microtask queue)</strong> 為空 &#x3D;&gt; 沒有 <strong>微任務 (microtask)</strong> 需要處理</li>
<li>預備進行畫面渲染，執行第 6 行的 <code>requestAnimationFrame</code></li>
<li>進入 <strong>Style</strong> &#x3D;&gt; <strong>Layout</strong> &#x3D;&gt; <strong>Paint</strong> &#x3D;&gt; <strong>Composite</strong> 這些階段的頁面渲染</li>
<li>當輪 <strong>event loop</strong> 結束<br>&nbsp;</li>
<li>下一輪的 <strong>event loop</strong> 從 <strong>宏任務佇列 (macrotask queue)</strong> 挑出 <strong>宏任務 (macrotask)</strong> 執行 &#x3D;&gt; 執行步驟 1. 的 <code>setTimeout</code> <code>callback</code></li>
<li>此輪的 <strong>event loop</strong> 已經沒有後續任務了，當輪 <strong>event loop</strong> 結束<br>&nbsp;</li>
<li>再下一輪的 <strong>event loop</strong> 從 <strong>宏任務佇列 (macrotask queue)</strong> 挑出 <strong>宏任務 (macrotask)</strong> 執行 &#x3D;&gt; 執行步驟 3. 的 <code>setTimeout</code> <code>callback</code></li>
</ol>
<p><strong>結果：</strong><br>由以上步驟來看最後執行的應該是第 13 行，所以最後畫面會顯示的是 C，但當你把這段程式碼多次執行時，會發現最後顯示的不一定是 C，有時候畫面上顯示的會是 B，這是為什麼呢？</p>
<p>關鍵就在於瀏覽器什麼時候渲染畫面，上一篇文章 <a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制/#event-loop-如何安排任務的執行順序" target="_blank" rel="noreferrer noopenner">event loop 如何安排任務的執行順序</a> 中提到在 <strong>微任務 (microtask)</strong> 都執行完後，下一步會判斷<strong>是否需要渲染 UI 畫面</strong>，而這就是所謂的關鍵點了</p>
<blockquote>
<p><a href="https://hentaicracker.github.io/2020/rAF.html#_3-5-%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93">瀏覽器可能出於各種原因，盡量高效的渲染畫面，只在必要的時候才進行渲染</a></p>
</blockquote>
<p>因此當瀏覽器判斷第一輪執行 <strong>event loop</strong> 後，如果還不需要渲染畫面，那麼也就不會執行步驟 2. <code>requestAnimationFrame</code> 裡的 <code>callback</code>，這種狀況下，步驟 9. 及步驟 11. 就會先被執行，最後瀏覽器判斷需要渲染畫面時才會執行步驟 2.，因此就會看到畫面上最後顯示的是 B</p>
<h4 id="2-被延遲執行的-requestAnimationFrame"><a href="#2-被延遲執行的-requestAnimationFrame" class="headerlink" title="2. 被延遲執行的 requestAnimationFrame"></a>2. 被延遲執行的 requestAnimationFrame</h4><p>上一個範例我們看到瀏覽器可能會自行判斷在當下的 <strong>event loop</strong> 結束後，是否需要進行渲染畫面，因此也導致 <code>requestAnimationFrame</code> 的執行時機不確定，第 2 個範例我們來看看如果在 <code>requestAnimationFrame</code> 執行之前有耗時較長的任務需要處理，會有什麼樣的結果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">longTask</span> = (<span class="params">ms = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = performance.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (performance.<span class="title function_">now</span>() - start &gt; ms) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = performance.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout 1&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="title function_">longTask</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;requestAnimationFrame&#x27;</span>, performance.<span class="title function_">now</span>() - start);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout 2&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  <span class="title function_">longTask</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="title function_">longTask</span>();</span><br></pre></td></tr></table></figure>

<p>首先這裡我們寫了一個 <code>longTask</code> 的函式，模擬長時間的運算(500ms)，這裡我們打算在每個 <strong>宏任務 (macrotask)</strong> 執行後，再執行一次 <code>longTask</code>，這樣會導致每輪的 <strong>event loop</strong> 結束後都經過了 500ms，而這時間遠遠超過一幀 (17ms) 瀏覽器判斷應該進行畫面渲染的時機，所以每輪 <strong>宏任務 (macrotask)</strong> 執行後瀏覽器都會渲染畫面</p>
<p><strong>順序：</strong></p>
<ol>
<li>首先執行第 29-31 行，因為 31 行添加了一個長時間的任務，可以保證瀏覽器在執行 31 行後會重新渲染畫面</li>
<li>在渲染畫面前會執行第 18-21 行的 <code>requestAnimationFrame</code> <code>callback</code>，第 20 行會將接下來的畫面印出 B</li>
<li>執行第 12-16 行，因為 15 行添加了一個長時間的任務，所以瀏覽器會執行渲染，這一輪的畫面將會印出 A</li>
<li>執行第 23-27 行，因為 26 行添加了一個長時間的任務，所以瀏覽器會執行渲染，這一輪的畫面將會印出 C</li>
</ol>
<p><strong>結果：</strong></p>
<ol>
<li>因為每輪 <strong>event loop</strong> 都添加了 500ms 的長時間任務，所以每輪 <strong>event loop</strong> 執行後瀏覽器會判斷需要渲染畫面，可以明顯地看到 B &#x3D;&gt; A &#x3D;&gt; C 依序印出</li>
<li>第 30 行其實沒有任何作用，因為在頁面渲染前會執行到第 20 行，將原本第 30 行覆蓋過去</li>
<li>第 19 行可以看到 <code>requestAnimationFrame</code> 的執行時機在長時間任務執行下，有可能會被延遲到 500ms 後，不會再是每 17ms 都執行一次</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p><a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/JavaScript/%E5%BC%82%E6%AD%A5/%E8%A6%81%E5%B0%B1%E6%9D%A545%E9%81%93Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E6%AC%A1%E7%88%BD%E5%88%B0%E5%BA%95.md#51-%E9%A2%98%E7%9B%AE%E4%B8%80">要就来45道Promise面试题一次爽到底</a><br>這篇文章的大部分範例都引用這裡，看完這裡面的 45 道題後，一定對於整個 event loop 的執行順序更為熟悉</p>
</li>
<li><p><a href="https://hentaicracker.github.io/2020/rAF.html#_2-requestanimationframe-%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%B0%E6%83%91">requestAnimationFrame 执行的困惑</a></p>
</li>
<li><p><a href="https://intspirit.medium.com/understanding-the-browsers-event-loop-for-building-high-performance-web-applications-part-1-fe4b573a1520">Understanding the browser’s Event Loop for building high-performance web applications. Part 1.</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/77008112/which-queue-is-associated-with-requestanimationframe">Which queue is associated with requestAnimationFrame?</a><br>宏任務(microtask) 有 macrotask queue，微任務(microtask) 有 macrotask queue，但 requestAnimationFrame 的 callback 會被放在哪裡等待後續執行呢？</p>
</li>
</ul>

<style>
.log {
	color: #9c9;
  font-weight: bold;
}
</style>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>面試題</tag>
      </tags>
  </entry>
  <entry>
    <title>使用原生的 queueMicrotask 處理微任務</title>
    <url>/blog/2024/02/04/%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84-queuemicrotask-%E8%99%95%E7%90%86%E5%BE%AE%E4%BB%BB%E5%8B%99/</url>
    <content><![CDATA[<p>此為 <strong>event loop</strong> 系列文章 - 第 3 篇：</p>
<ol>
<li><a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制" target="_blank" rel="noreferrer noopenner">Javascript 中的 event loop 及瀏覽器渲染機制</a> </li>
<li><a href="/blog/2024/01/27/從程式碼角度來看-event-loop" target="_blank" rel="noreferrer noopenner">從程式碼角度來看 event loop</a> </li>
<li><a href="/blog/2024/02/04/使用原生的-queuemicrotask-處理微任務/" target="_blank" rel="noreferrer noopenner">使用原生的 queueMicrotask 處理微任務</a></li>
<li><a href="/blog/2024/02/05/vue-nexttick-中的-event-loop/" target="_blank" rel="noreferrer noopenner">Vue.nextTick() 中的 event loop</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在研究 <strong>event loop</strong> 的過程中，赫然發現原來瀏覽器已經有了原生的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask">queueMicrotask</a> 讓開發者可以自行管理微任務的執行，下面我們來看看什麼情況下會需要用到這個功能吧</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>基本上 <code>queueMicrotask</code> 就如同使用 <code>new Promise()</code> 一樣，會將 callback 加入到 <strong>微任務佇列 (microtask queue)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Regular timeout callback has run&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">urgentCallback</span> = (<span class="params"></span>) =&gt;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*** Oh noes! An urgent callback has run!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Main program started&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(callback, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>(urgentCallback);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Main program exiting&quot;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>結果：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Main program started&#x27;</span></span><br><span class="line"><span class="string">&#x27;Main program exiting&#x27;</span></span><br><span class="line"><span class="string">&#x27;*** Oh noes! An urgent callback has run!&#x27;</span></span><br><span class="line"><span class="string">&#x27;Regular timeout callback has run&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="何時會使用到-queueMicrotask"><a href="#何時會使用到-queueMicrotask" class="headerlink" title="何時會使用到 queueMicrotask"></a>何時會使用到 queueMicrotask</h2><p>基本上大部分的狀況下，開發者們都不太需要使用到 <code>queueMicrotask</code>，但 MDN 上提到一個有趣的範例，為了保證程式的執行順序，在某些狀況下適合使用到 <code>queueMicrotask</code> 將某些任務的優先程度提高，提前執行</p>
<p>假設有一個 DOM 元素添加了自定義的 <code>load</code> 事件，當執行這個元素的 <code>getData()</code> 方法後會利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent">dispatchEvent</a> 送出一個事件，通知資料已經載完了(第 1 行)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Loaded data&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fetching data…&quot;</span>);</span><br><span class="line">element.<span class="title function_">getData</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Data fetched&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElement.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getData</span> = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[url]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">cache</span>[url];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(url)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result.<span class="title function_">arrayBuffer</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>[url] = data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由於 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent#:~:text=Unlike%20%22native%22%20events%2C%20which%20are%20fired%20by%20the%20browser%20and%20invoke%20event%20handlers%20asynchronously%20via%20the%20event%20loop%2C%20dispatchEvent()%20invokes%20event%20handlers%20synchronously.%20All%20applicable%20event%20handlers%20are%20called%20and%20return%20before%20dispatchEvent()%20returns.">dispatchEvent 發出的事件是同步執行的</a>，並不像一般 WebAPI 原生事件(click, mouseenter 等) 是異步執行的 <strong>宏任務 (macrotask)</strong> ，所以以上程式碼的執行順序如下：</p>
<ol>
<li>首先執行第 2 行，印出 <span class="log">Fetching data…</span></li>
<li>執行第 3 行的 <code>getData()</code> 函式，第一次執行 <code>getData()</code> 時由於沒有 cache 所以會執行第 6 行的 <code>fetch</code> 等待資料下載完成</li>
<li>等待 <code>fetch</code> 異步執行獲取資料的過程中，第 4 行會先執行印出 <span class="log">Data fetched</span></li>
<li>最後資料載入完成後執行 <code>this.dispatchEvent(new Event(&quot;load&quot;));</code>，回到第 1 行的 callback 印出 <span class="log">Loaded data</span></li>
</ol>
<!-- 函式裡最終會執行 `this.dispatchEvent(new Event("load"));`，告知其他訂閱對象資料已經下載完成了 -->
<!-- 3. 由於 `dispatchEvent` 是同步執行的，第 1 行中的 callback 會立即執行印出 <span class="log">Loaded data</span> -->

<p><strong>結果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Fetching data…&#x27;</span></span><br><span class="line"><span class="string">&#x27;Data fetched&#x27;</span></span><br><span class="line"><span class="string">&#x27;Loaded data&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但如果之後執行 <code>getData()</code> 資料已經有 cache 的狀況下，執行過程如下：</p>
<ol>
<li>首先執行第 2 行，印出 <span class="log">Fetching data…</span></li>
<li>執行第 3 行的 <code>getData()</code> 函式，此時執行 <code>getData()</code> 時由於已經有 cache 所以會直接執行到第 4 行的 <code>this.dispatchEvent(new Event(&quot;load&quot;));</code> 發出 load event</li>
<li>由於 <code>dispatchEvent</code> 是同步執行的，第 1 行中的 callback 會立即執行印出 <span class="log">Loaded data</span></li>
<li><code>getData()</code> 函式結束，接著執行第 4 行印出 <span class="log">Data fetched</span></li>
</ol>
<p><strong>結果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Fetching data…&#x27;</span></span><br><span class="line"><span class="string">&#x27;Loaded data&#x27;</span></span><br><span class="line"><span class="string">&#x27;Data fetched&#x27;</span></span><br></pre></td></tr></table></figure>

<p>哇！我們可以看到有無 cache 時，會導致程式碼的執行順序不一，這一定不是我們期望看到的，此時就可以考慮使用 <code>queueMicrotask</code>(第 3 行)，使原本的同步事件改為異步事件執行，這樣不論有無 cache 的狀況下都可以保證一樣的執行順序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElement.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getData</span> = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[url]) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">cache</span>[url];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(url)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result.<span class="title function_">arrayBuffer</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>[url] = data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>結果</strong><br>這樣不論有無 cache 都會是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Fetching data…&#x27;</span></span><br><span class="line"><span class="string">&#x27;Data fetched&#x27;</span></span><br><span class="line"><span class="string">&#x27;Loaded data&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>一開始覺得 MDN 提出的這個範例蠻有趣的，在這種場合下用 <code>queueMicrotask</code> 就可以保證不論是否有 cache 的狀況下都有一致的執行順序，但我後來想想這個範例寫得似乎有點奇怪，仔細想想通常在使用 <code>fetch</code> 呼叫 api 時都會添加 <code>await</code> 等待資料回傳回來再執行後面的程式，如此一來應該就不必特別用到 <code>queueMicrotask</code> 了吧？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Loaded data&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fetching data…&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> element.<span class="title function_">getData</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Data fetched&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">customElement.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getData</span> = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[url]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">cache</span>[url];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">fetch</span>(url)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result.<span class="title function_">arrayBuffer</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cache</span>[url] = data;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>結果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Fetching data…&#x27;</span></span><br><span class="line"><span class="string">&#x27;Loaded data&#x27;</span></span><br><span class="line"><span class="string">&#x27;Data fetched&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不論有無 cache 應該都會是這個順序，但或許 MDN 上的範例想要的執行順序是 <code>&#39;Data fetched&#39;</code> 在 <code>&#39;Loaded data&#39;</code> 前執行，如果是這樣的話就的確需要用到 <code>queueMicrotask</code> 了</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide">Using microtasks in JavaScript with queueMicrotask()</a></li>
</ul>

<style>
.log {
	color: #9c9;
  font-weight: bold;
}
</style>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>THREE.Vector3 三維空間的向量運算</title>
    <url>/blog/2023/12/23/three-vector3-%E4%B8%89%E7%B6%AD%E7%A9%BA%E9%96%93%E7%9A%84%E5%90%91%E9%87%8F%E9%81%8B%E7%AE%97/</url>
    <content><![CDATA[<p><a href="https://threejs.org/docs/#api/en/math/Vector3">THREE.Vector3</a> 是 <code>threejs</code> 中最常用到的基礎類別，代表 3 維向量的運算</p>
<h2 id="Vector3-的方法"><a href="#Vector3-的方法" class="headerlink" title="Vector3 的方法"></a>Vector3 的方法</h2><h5 id="add-v-Vector3-this"><a href="#add-v-Vector3-this" class="headerlink" title="- add(v: Vector3): this"></a><strong>- add(v: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addVector3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">addVector3.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.add&#x27;</span>, addVector3); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="addScalar-s-Float-this"><a href="#addScalar-s-Float-this" class="headerlink" title="- addScalar(s: Float): this"></a><strong>- addScalar(s: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addScalarVector3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">addScalarVector3.<span class="title function_">addScalar</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.addScalar&#x27;</span>, addScalarVector3); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="addScaledVector-v-Vector3-s-Float-this"><a href="#addScaledVector-v-Vector3-s-Float-this" class="headerlink" title="- addScaledVector(v: Vector3, s: Float): this"></a><strong>- addScaledVector(v: Vector3, s: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addScaledVector3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">addScaledVector3.<span class="title function_">addScaledVector</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.addScaledVector&#x27;</span>, addScaledVector3); <span class="comment">// &#123;x: 4, y: 4, z: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="addVectors-a-Vector3-b-Vector3-this"><a href="#addVectors-a-Vector3-b-Vector3-this" class="headerlink" title="- addVectors(a: Vector3, b: Vector3): this"></a><strong>- addVectors(a: Vector3, b: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addVectors3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">addVectors3.<span class="title function_">addVectors</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.addVectors&#x27;</span>, addVectors3); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="clone-Vector3"><a href="#clone-Vector3" class="headerlink" title="- clone(): Vector3"></a><strong>- clone(): Vector3</strong></h5><p>有時候原本的 <code>Vector3</code> 可能是某物件的屬性，為了避免修改到原始 <code>Vector3</code> 的座標，可以執行 <code>clone</code> 方法，複製新的 <code>Vector3</code> 出來</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cloneOriginalVectors = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.clone cloneOriginalVectors before&#x27;</span>, cloneOriginalVectors); <span class="comment">// &#123;x: 1, y: 1, z: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneVectors = cloneOriginalVectors.<span class="title function_">clone</span>();</span><br><span class="line">cloneVectors.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.clone cloneOriginalVectors after&#x27;</span>, cloneOriginalVectors); <span class="comment">// &#123;x: 1, y: 1, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="copy-v-Vector3-this"><a href="#copy-v-Vector3-this" class="headerlink" title="- copy(v: Vector3): this"></a><strong>- copy(v: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">copyVector.<span class="title function_">copy</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.copy&#x27;</span>, copyVector); <span class="comment">// &#123;x: 1, y: 1, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="cross-v-Vector3-this"><a href="#cross-v-Vector3-this" class="headerlink" title="- cross(v: Vector3): this"></a><strong>- cross(v: Vector3): this</strong></h5><p>計算向量外積</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crossVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">crossVector.<span class="title function_">cross</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.cross&#x27;</span>, crossVector); <span class="comment">// &#123;x: 0, y: 0, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="數學公式"><a href="#數學公式" class="headerlink" title="數學公式"></a>數學公式</h6><p>$$<br>\begin{vmatrix}<br>	\hat{i} &amp; \hat{j} &amp; \hat{k} \\<br>	1 &amp; 0 &amp; 0 \\<br>	0 &amp; 1 &amp; 0 \\<br>\end{vmatrix}<br>$$</p>
<p>$$<br>&#x3D; 0\hat{i} + 0\hat{j} + 1\hat{k}<br>$$</p>
<h5 id="crossVectors-a-Vector3-b-Vector3-this"><a href="#crossVectors-a-Vector3-b-Vector3-this" class="headerlink" title="- crossVectors(a: Vector3, b: Vector3): this"></a><strong>- crossVectors(a: Vector3, b: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crossVectors = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">crossVectors.<span class="title function_">crossVectors</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.crossVectors&quot;</span>, crossVectors); <span class="comment">// &#123;x: 0, y: 0, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="distanceTo-v-Vector3-Float"><a href="#distanceTo-v-Vector3-Float" class="headerlink" title="- distanceTo(v: Vector3): Float"></a><strong>- distanceTo(v: Vector3): Float</strong></h5><p>計算兩個向量之間的距離</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> distance = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>).<span class="title function_">distanceTo</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.distanceTo&quot;</span>, distance); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h5 id="divide-v-Vector3-this"><a href="#divide-v-Vector3-this" class="headerlink" title="- divide(v: Vector3): this"></a><strong>- divide(v: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divideVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">divideVector.<span class="title function_">divide</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.divideVector&quot;</span>, divideVector); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="divideScalar-s-Float-this"><a href="#divideScalar-s-Float-this" class="headerlink" title="- divideScalar(s: Float): this"></a><strong>- divideScalar(s: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divideScalarVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">divideScalarVector.<span class="title function_">divideScalar</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.divideScalar&quot;</span>, divideScalarVector); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="dot-v-Vector3-Float"><a href="#dot-v-Vector3-Float" class="headerlink" title="- dot(v: Vector3): Float"></a><strong>- dot(v: Vector3): Float</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dot = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">dot</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.dot&quot;</span>, dot); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>參考 <a href="/blog/2023/12/11/向量內積/" target="_blank" rel="noreferrer noopenner">向量內積</a></p>
<h5 id="equals-v-Vector3-Boolean"><a href="#equals-v-Vector3-Boolean" class="headerlink" title="- equals(v: Vector3): Boolean"></a><strong>- equals(v: Vector3): Boolean</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEqual = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).<span class="title function_">equals</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.equals&quot;</span>, isEqual); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="length-Float"><a href="#length-Float" class="headerlink" title="- length(): Float"></a><strong>- length(): Float</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>).<span class="title function_">length</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.length&quot;</span>, length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h5 id="multiply-v-Vector3-this"><a href="#multiply-v-Vector3-this" class="headerlink" title="- multiply(v: Vector3): this"></a><strong>- multiply(v: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">multiplyVector.<span class="title function_">multiply</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.multiply&quot;</span>, multiplyVector); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="multiplyScalar-s-Float-this"><a href="#multiplyScalar-s-Float-this" class="headerlink" title="- multiplyScalar(s: Float): this"></a><strong>- multiplyScalar(s: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyScalarVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">multiplyScalarVector.<span class="title function_">multiplyScalar</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.multiplyScalar&quot;</span>, multiplyScalarVector); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="multiplyVectors-a-Vector3-b-Vector3-this"><a href="#multiplyVectors-a-Vector3-b-Vector3-this" class="headerlink" title="- multiplyVectors(a: Vector3, b: Vector3): this"></a><strong>- multiplyVectors(a: Vector3, b: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyVectors = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">multiplyVectors.<span class="title function_">multiplyVectors</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.multiplyVectors&quot;</span>, multiplyVectors); <span class="comment">// &#123;x: 3, y: 3, z: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="negate-this"><a href="#negate-this" class="headerlink" title="- negate(): this"></a><strong>- negate(): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> negateVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">negateVector.<span class="title function_">negate</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.negate&quot;</span>, negateVector); <span class="comment">// &#123;x: -1, y: -1, z: -1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="normalize-this"><a href="#normalize-this" class="headerlink" title="- normalize(): this"></a><strong>- normalize(): this</strong></h5><p>正規化成單位向量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> normalizeVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">normalizeVector.<span class="title function_">normalize</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.normalize&quot;</span>, normalizeVector); <span class="comment">// &#123;x: 1, y: 0, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="set-x-Float-y-Float-z-Float-this"><a href="#set-x-Float-y-Float-z-Float-this" class="headerlink" title="- set(x: Float, y: Float, z: Float): this"></a><strong>- set(x: Float, y: Float, z: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">setVector.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.set&quot;</span>, setVector); <span class="comment">// &#123;x: 1, y: 1, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="setX-x-Float-this"><a href="#setX-x-Float-this" class="headerlink" title="- setX(x: Float): this"></a><strong>- setX(x: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setXVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setXVector.<span class="title function_">setX</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.setXVector&quot;</span>, setXVector); <span class="comment">// &#123;x: 1, y: 0, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="setY-y-Float-this"><a href="#setY-y-Float-this" class="headerlink" title="- setY(y: Float): this"></a><strong>- setY(y: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setYVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setYVector.<span class="title function_">setY</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.setYVector&quot;</span>, setYVector); <span class="comment">// &#123;x: 0, y: 1, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="setZ-z-Float-this"><a href="#setZ-z-Float-this" class="headerlink" title="- setZ(z: Float): this"></a><strong>- setZ(z: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setZVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setZVector.<span class="title function_">setZ</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.setZVector&quot;</span>, setZVector); <span class="comment">// &#123;x: 0, y: 0, z: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="sub-v-Vector3-this"><a href="#sub-v-Vector3-this" class="headerlink" title="- sub(v: Vector3): this"></a><strong>- sub(v: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">subVector.<span class="title function_">sub</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.sub&quot;</span>, subVector); <span class="comment">// &#123;x: 2, y: 2, z: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="subScalar-s-Float-this"><a href="#subScalar-s-Float-this" class="headerlink" title="- subScalar(s: Float): this"></a><strong>- subScalar(s: Float): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subScalarVector = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">subScalarVector.<span class="title function_">subScalar</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.subScalar&quot;</span>, subScalarVector); <span class="comment">// &#123;x: 2, y: 2, z: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="subVectors-a-Vector3-b-Vector3-this"><a href="#subVectors-a-Vector3-b-Vector3-this" class="headerlink" title="- subVectors(a: Vector3, b: Vector3): this"></a><strong>- subVectors(a: Vector3, b: Vector3): this</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subVectors = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">subVectors.<span class="title function_">subVectors</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.subVectors&quot;</span>, subVectors); <span class="comment">// &#123;x: 2, y: 2, z: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://codesandbox.io/p/devbox/threejs-vector3-m4s4rt?file=/src/basic/index.js">Demo</a></h2><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>threejs r159</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://threejs.org/docs/#api/en/math/Vector3">THREE.Vector3</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>Vue.nextTick() 中的 event loop</title>
    <url>/blog/2024/02/05/vue-nexttick-%E4%B8%AD%E7%9A%84-event-loop/</url>
    <content><![CDATA[<p>此為 <strong>event loop</strong> 系列文章 - 第 4 篇：</p>
<ol>
<li><a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制" target="_blank" rel="noreferrer noopenner">Javascript 中的 event loop 及瀏覽器渲染機制</a> </li>
<li><a href="/blog/2024/01/27/從程式碼角度來看-event-loop" target="_blank" rel="noreferrer noopenner">從程式碼角度來看 event loop</a> </li>
<li><a href="/blog/2024/02/04/使用原生的-queuemicrotask-處理微任務/" target="_blank" rel="noreferrer noopenner">使用原生的 queueMicrotask 處理微任務</a></li>
<li><a href="/blog/2024/02/05/vue-nexttick-中的-event-loop/" target="_blank" rel="noreferrer noopenner">Vue.nextTick() 中的 event loop</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章想藉由閱讀 <a href="https://vuejs.org/api/general.html#nexttick">Vue.nextTick()</a> 的源碼來看 <strong>event loop</strong> 的使用</p>
<h2 id="Vue-nextTick-的使用方式"><a href="#Vue-nextTick-的使用方式" class="headerlink" title="Vue.nextTick 的使用方式"></a>Vue.nextTick 的使用方式</h2><p>官方文件寫明 <code>Vue.nextTick()</code> 是拿來等待下一次 DOM 更新的方法，因為 Vue 在每次響應式數據改變後是異步去更新 DOM，所以如果在數據改變後，馬上獲取 DOM 的資料會是舊的，這時就需要用到 <code>Vue.nextTick()</code> 獲取更新後的 DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 还未更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// DOM 此时已经更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;counter&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Vue-nextTick-的源碼分析"><a href="#Vue-nextTick-的源碼分析" class="headerlink" title="Vue.nextTick 的源碼分析"></a>Vue.nextTick 的源碼分析</h2><p>目前最新版(2024&#x2F;02) 的 <a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js">Vue.nextTick 源碼</a> 如下(移除掉一些註解方便整體閱讀)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nextTick-函式"><a href="#nextTick-函式" class="headerlink" title="nextTick 函式"></a>nextTick 函式</h3><p>第 57-79 行就是我們實際在用的 <code>nextTick</code> 函式，傳入的參數有兩個，<code>cb</code> 是 DOM 更新後才執行的 callback，<code>ctx</code> 為了傳遞 <code>this</code> 的指向<br>第 59-69 行將傳入的 <code>cb</code> 放入 <code>callbacks</code> 的佇列裡，等待後續執行<br>第 70-73 行用一個 <code>pending</code> 的變數控制，讓多次呼叫 <code>nextTick</code> 函式時，<code>timerFunc</code> 可以在同一次的 <strong>更新時機(tick)</strong> 中執行所有的 <code>callbacks</code></p>
<p><strong>什麼是更新時機(tick)?</strong><br>在 <code>Vue</code> 中定義了一個叫做 <strong>tick</strong> 的專有名詞，指的是某一個特定的時間下 <code>Vue</code> 用來執行響應式資料改變、DOM 更新等邏輯，<strong>tick</strong> 執行的時機會根據之後將提到的 <code>timerFunc</code> 函式判斷是要用 <strong>event loop</strong> 中的 <strong>宏任務 (macrotask)</strong> 或是 <strong>微任務 (microtask)</strong> 方式執行。</p>
<p>第 74-78 行讓 <code>nextTick</code> 函式可以單純回傳 <code>Promise</code>，如此一來不用傳 <code>cb</code> 也可以使用</p>
<ul>
<li>使用 callback 方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 更新 DOM 前</span></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 更新 DOM 後</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用 callback 方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 更新 DOM 前</span></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;counter&#x27;</span>).<span class="property">textContent</span>) <span class="comment">// 更新 DOM 後</span></span><br></pre></td></tr></table></figure>

<h3 id="callbacks-flushCallbacks-負責執行-callback"><a href="#callbacks-flushCallbacks-負責執行-callback" class="headerlink" title="callbacks &amp; flushCallbacks - 負責執行 callback"></a>callbacks &amp; flushCallbacks - 負責執行 callback</h3><p>在 <code>nextTick</code> 中丟入的 <code>cb</code> 參數，會放入 <code>callbacks</code> 佇列裡，等待下一次適當的 <strong>更新時機(nextTick)</strong> 後，才真正執行 <code>cb</code> 函式。而真正執行 <code>cb</code> 的地方就是 <code>flushCallbacks</code> 函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 問題 2. 為什麼需要複製 callbacks 陣列？</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timerFunc-決定用哪種-event-loop-方式決定更新時機-nextTick"><a href="#timerFunc-決定用哪種-event-loop-方式決定更新時機-nextTick" class="headerlink" title="timerFunc - 決定用哪種 event loop 方式決定更新時機(nextTick)"></a>timerFunc - 決定用哪種 event loop 方式決定更新時機(nextTick)</h3><p>什麼是下一次適當的 <strong>更新時機(nextTick)</strong> 呢？在 <code>Vue</code> 中使用了 <code>timerFunc</code> 這個變數去做判斷，以下這段程式碼會根據不同的瀏覽器去做兼容控制，我們可以看到 <code>timerFunc</code> 的優先順序為： <code>Promise</code> &#x3D;&gt; <code>MutationObserver</code> &#x3D;&gt; <code>setImmediate</code> &#x3D;&gt; <code>setTimeout</code>，也就是說 <code>nextTick</code> 中傳入的 <code>callback</code> 會優先以 <strong>微任務 (microtask)</strong> 的方式執行，如果真的不行最後才會降級成 <code>setTimeout</code> 的 <strong>宏任務 (macrotask)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>為什麼優先以微任務方式執行？</strong><br>在之前系列文提到每一輪的 <strong>event loop</strong> 會挑出一個 <strong>宏任務 (macrotask)</strong> 執行，接著執行 <strong>微任務佇列 (microtask queue)</strong> 中的所有 <strong>微任務 (microtask)</strong> ，然後再進行 UI 的畫面渲染。<br>在 <code>Vue</code> 中的響應式資料改變，都有可能會修改 DOM 改變畫面，而畫面的改變當然希望是越即時越好，這部分如果使用 <code>setTimeout</code> 這種 <strong>宏任務 (macrotask)</strong> 執行 <code>Vue</code> 的更新邏輯，每一幀渲染前都只能執行一個 <strong>宏任務 (macrotask)</strong> ，這樣一定很容易遇到<a href="https://github.com/Ma63d/vue-analysis/issues/6#:~:text=Vue%E4%B8%80%E5%BC%80%E5%A7%8B%E6%9B%BE%E7%BB%8F%E6%94%B9%E8%BF%87nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%A4%E4%B8%AAjsFiddle">畫面不即時的問題</a>，所以 <code>Vue</code> 在處理資料更新以及 DOM 的修改才優先以 <strong>微任務 (microtask)</strong> 方式執行，這樣在當輪的瀏覽器渲染畫面前資料都已經更新了。</p>
<h3 id="nextTick-問題解析"><a href="#nextTick-問題解析" class="headerlink" title="nextTick 問題解析"></a>nextTick 問題解析</h3><h5 id="1-pending-變數的作用"><a href="#1-pending-變數的作用" class="headerlink" title="1. pending 變數的作用?"></a>1. pending 變數的作用?</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  callbacks.<span class="title function_">push</span>(...)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pending</code> 的初始值為 <code>false</code>，在一開始使用 <code>nextTick</code> 的時候會設為 <code>true</code>，然後在 <code>flushCallbacks</code> 中 (<code>callbacks</code> 佇列全部執行前) 會設為 <code>false</code>，這樣可以讓多次 <code>nextTick</code> 中加入的 <code>cb</code>，在同一次的 <strong>更新時機(nextTick)</strong> 中一次全部執行完</p>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cb1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cb2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">nextTick</span>(cb1)</span><br><span class="line"><span class="title function_">nextTick</span>(cb2)</span><br></pre></td></tr></table></figure>
<p>由於有 <code>pending</code> 變數的控制，第 5 行執行後 <code>callbacks = [cb1, cb2]</code>，但 <code>timerFunc()</code> 一樣只會執行一次。接著第 10 行將 <code>flushCallbacks</code> 加入 <strong>微任務佇列 (microtask queue)</strong> ，等待之後從 <strong>微任務佇列 (microtask queue)</strong> 挑出 <code>flushCallbacks</code> 時，<code>cb1</code>, <code>cb2</code> 就可以在同一次的 <strong>更新時機(nextTick)</strong> 中一併執行</p>
<h5 id="2-為什麼需要複製-callbacks-陣列？"><a href="#2-為什麼需要複製-callbacks-陣列？" class="headerlink" title="2. 為什麼需要複製 callbacks 陣列？"></a>2. 為什麼需要複製 callbacks 陣列？</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在實際執行 <code>callback</code> 前會先將整個 <code>callbacks</code> 陣列複製，原因是當 <code>nextTick</code> 中的 <code>callback</code> 使用到巢狀的 <code>nextTick</code> 時，需要讓父層與子層的 <code>callback</code> 在不同次的 <strong>更新時機(nextTick)</strong> 執行</p>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nextTick</span>(<span class="keyword">function</span> <span class="title function_">cb1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">nextTick</span>(cb2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>cb1</code> 的子層巢狀用到了 <code>cb2</code>，如果不複製 <code>callbacks</code> 陣列的話，<code>cb2</code> 也會被加入到當輪要執行的 <code>callbacks</code> 陣列裡，導致 <code>cb1</code> 與 <code>cb2</code> 都在同一次的 <strong>更新時機(nextTick)</strong> 中執行，而複製了 <code>callbacks</code> 陣列後，<code>flushCallbacks</code> 會將這一次該執行完的 <code>callbacks</code> 都跑完，而 <code>cb2</code> 被加入到的是下一次的 <code>callbacks</code> 陣列，也就是在下一次的 <strong>更新時機(nextTick)</strong> 才會執行 </p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://jiuto.github.io/jiuto_blog/guide/vue/nextTick.html#vue%E4%B8%AD-nexttick%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">vue中$nextTick的实现原理</a></li>
<li><a href="https://vue3js.cn/interview/vue/nexttick.html">面试官：Vue中的$nextTick有什么作用？</a></li>
<li><a href="https://github.com/Ma63d/vue-analysis/issues/6">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></li>
<li><a href="https://juejin.cn/post/7089980191329484830">Vue异步更新机制以及$nextTick原理</a></li>
</ul>
<br />

<ul>
<li><a href="https://stackoverflow.com/questions/33521966/mutationobserver-characterdata-usage-without-childlist">MutationObserver characterData usage without childList</a><br>講解 MutationObserver 中的 characterData 的作用</li>
</ul>
<br />

<ul>
<li><a href="https://nodejs.org/en/learn/asynchronous-work/understanding-setimmediate">Understanding setImmediate()</a></li>
<li><a href="https://nodejs.org/en/guides/event-loop-timers-and-nexttick">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
<li><a href="https://yu-jack.github.io/2021/03/14/node-event-loop/">Event Loop 運行機制解析 - Node.js 篇</a><br>瀏覽器中的 setImmediate 只有已廢棄的 IE 支援，基本上現在 setImmediate 只會在 nodejs 中被使用，以上三篇文章簡介了 Node.js 的 event loop，以及 setImmediate 的執行時機</li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 中的 event loop 及瀏覽器渲染機制</title>
    <url>/blog/2024/01/20/javascript-%E4%B8%AD%E7%9A%84-event-loop-%E5%8F%8A%E7%80%8F%E8%A6%BD%E5%99%A8%E6%B8%B2%E6%9F%93%E6%A9%9F%E5%88%B6/</url>
    <content><![CDATA[<p>此為 <strong>event loop</strong> 系列文章 - 第 1 篇：</p>
<ol>
<li><a href="/blog/2024/01/20/javascript-中的-event-loop-及瀏覽器渲染機制" target="_blank" rel="noreferrer noopenner">Javascript 中的 event loop 及瀏覽器渲染機制</a> </li>
<li><a href="/blog/2024/01/27/從程式碼角度來看-event-loop" target="_blank" rel="noreferrer noopenner">從程式碼角度來看 event loop</a> </li>
<li><a href="/blog/2024/02/04/使用原生的-queuemicrotask-處理微任務/" target="_blank" rel="noreferrer noopenner">使用原生的 queueMicrotask 處理微任務</a></li>
<li><a href="/blog/2024/02/05/vue-nexttick-中的-event-loop/" target="_blank" rel="noreferrer noopenner">Vue.nextTick() 中的 event loop</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>event loop</strong> 是 <strong>js</strong> 中一個蠻重要的概念，雖然以前知道 <strong>宏任務 (macrotask)</strong> 及 <strong>微任務 (microtask)</strong> 優先級上的差別，但似乎一直不知道 <strong>event loop</strong> 與瀏覽器渲染間的關係，而大部分的文章都只單獨介紹 <strong>event loop</strong> 或是 瀏覽器渲染流程，所以寫了這篇文章統整 <strong>event loop</strong> 與 瀏覽器渲染 間的關聯性</p>
<h2 id="event-loop-的作用"><a href="#event-loop-的作用" class="headerlink" title="event loop 的作用"></a>event loop 的作用</h2><p>以前端來說，在瀏覽器中使用者的畫面點擊、呼叫後端 api、<code>window.addEventListener</code>，這些全部都由 <strong>js</strong> 執行，但 <strong>js</strong> 是單線程的程式語言，同一時間就是只能做一件事，所以當事情同時發生時，需要讓 <strong>js</strong> 知道哪行程式碼是先被執行的、而接下來又該執行哪段程式碼，這個負責安排執行順序的東西，基本上就叫做 <strong>event loop</strong></p>
<h2 id="event-loop-的宿主環境"><a href="#event-loop-的宿主環境" class="headerlink" title="event loop 的宿主環境"></a>event loop 的宿主環境</h2><p>嚴格來說 <strong>event loop</strong> 並不是定義在 <strong>js</strong> 上的東西，而是根據不同環境有不同的 <strong>event loop</strong> 規則，以瀏覽器來說就會有瀏覽器的 <strong>event loop</strong> 規則，而 <strong>nodejs</strong> 的話又會有另一套 <strong>nodejs</strong> 的 <strong>event loop</strong> 規則，今天這篇文章只探討瀏覽器的 <strong>event loop</strong></p>
<span id="more"></span>

<h2 id="Javascript-中的程式執行"><a href="#Javascript-中的程式執行" class="headerlink" title="Javascript 中的程式執行"></a>Javascript 中的程式執行</h2><p><strong>js</strong> 中的程式，按照執行時機區分的話可以分為 <strong>同步執行 (sync)</strong> 以及 <strong>異步執行 (async)</strong>，<strong>同步執行 (sync)</strong> 的程式碼會被丟到 <strong>js 主線程(main thread)</strong> 中，從頭到尾不間斷的執行完，而 <strong>異步執行 (async)</strong> 的程式則是指那些之後才會執行的程式 (ex. 呼叫 api 會等伺服器資料回應後才執行後續的操作)，但特別需要強調的一點是，<strong>js</strong> 是單線程的程式，不論是 <strong>同步執行 (sync)</strong> 或是 <strong>異步執行 (async)</strong>，程式碼一定會在某一刻交由 <strong>js 主線程(main thread)</strong> 執行。</p>
<h4 id="同步執行-sync"><a href="#同步執行-sync" class="headerlink" title="同步執行 (sync)"></a>同步執行 (sync)</h4><p>同步執行的程式會將每一段程式碼依序放入到 <strong>堆疊(stack)</strong> 裡面，再從最上層的 <strong>堆疊(stack)</strong> 挑出要運行的任務放入 <strong>js 主線程(main thread)</strong> 中執行</p>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main script&#x27;</span>);</span><br><span class="line"><span class="title function_">A</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>首先整個 <code>main script</code> 放入 <strong>堆疊(stack)</strong> 的最底層</li>
<li>將 <strong>堆疊(stack)</strong> 最上層需執行的任務 <code>main script</code> 抓出，放入 <strong>js 主線程(main thread)</strong> 執行</li>
<li><code>main script</code> 執行到第 5 行，印出 <span class="log">main script</span></li>
<li><code>main script</code> 執行到第 6 行遇到 <code>函式A</code>，將 <code>函式A</code> 放入 <strong>堆疊(stack)</strong> 中</li>
<li>將第 1-3 行的 <code>函式A</code> 放入 <strong>js 主線程(main thread)</strong> 執行</li>
<li><code>函式A</code> 執行完畢，印出 <span class="log">A</span>，將 <code>函式 A</code> 移出 <strong>堆疊(stack)</strong></li>
<li>接續執行 <code>main script</code></li>
<li>第 6 行後整個 <code>main script</code> 執行完成，將 <code>main script</code> 移出 <strong>堆疊(stack)</strong></li>
</ol>
<br />

<img src="stack.gif" width="60%">

<p>圖片來源: <a href="https://medium.com/i-caught-a-code/javascript-event-loop-stack-queue-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-2abd083bf4e3">[學習筆記] JavaScript 的 Event Loop, Stack, Queue</a></p>
<h4 id="異步執行-async"><a href="#異步執行-async" class="headerlink" title="異步執行 (async)"></a>異步執行 (async)</h4><p>除了一氣呵成的同步執行程式以外，<strong>js</strong> 也有所謂的異步執行程式 (ex. <code>call api</code>、<code>setTimeout</code>)，以下面的例子來看，假設我們寫的程式有很多這種異步邏輯，每一個區塊看起來都很像馬上就要執行，那麼瀏覽器要怎麼判斷每一段程式碼的執行順序呢？ 此時需要的就是 <strong>event loop</strong> 來安排這些異步任務程式碼的執行順序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main script&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="異步執行的任務"><a href="#異步執行的任務" class="headerlink" title="異步執行的任務"></a>異步執行的任務</h2><p>這些異步執行的程式，可以分為兩種： <strong>宏任務 (macrotask)</strong> 及 <strong>微任務 (microtask)</strong></p>
<h6 id="宏任務-macrotask"><a href="#宏任務-macrotask" class="headerlink" title="- 宏任務 (macrotask)"></a>- <strong>宏任務 (macrotask)</strong></h6><p>在 HTML spec 的規範中，<strong>宏任務 (macrotask)</strong> 其實叫做 <strong>任務(task)</strong> ，但為了跟 <strong>微任務 (microtask)</strong> 有一個相對應的區分所以大部分的教學文章都加上了 <strong>宏(macro)</strong> 這個字，以下幾種方法都屬於 <strong>宏任務 (macrotask)</strong></p>
<ul>
<li>用 <code>&lt;script src=&quot;...&quot;&gt;</code> 方式載入的程式碼</li>
<li>setTimeout, setInterval </li>
<li>使用者交互事件 (ex. 滑鼠 click, 鍵盤 keydown 事件)</li>
</ul>
<h6 id="微任務-microtask"><a href="#微任務-microtask" class="headerlink" title="- 微任務 (microtask)"></a>- <strong>微任務 (microtask)</strong></h6><p>目前有的 <strong>微任務 (microtask)</strong> ：</p>
<ul>
<li>promise </li>
<li>DOM mutations (MutaionObserver)</li>
</ul>
<p>而不論是 <strong>宏任務 (macrotask)</strong> 或是 <strong>微任務 (microtask)</strong> 它們都是以 <strong>佇列(queue)</strong> 的資料結構存放，存放這兩種任務的 <strong>佇列(queue)</strong> 名稱，後面我分別稱呼它們為 <strong>宏任務佇列 (macrotask queue)</strong> 與 <strong>微任務佇列 (microtask queue)</strong></p>
<img src="queue.webp" style="margin-left: -10%">

<p>圖片來源: <a href="https://www.devcript.com/simple-explanation-of-stack-and-queue-with-javascript/">Simple Explanation of Stack and Queue with JavaScript</a></p>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeoutCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">promiseCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>第 1 行的 <code>setTimeout</code> 屬於 <strong>宏任務 (macrotask)</strong> ，所以 <code>timeoutCallback</code> 會被放入 <strong>宏任務佇列 (macrotask queue)</strong> 中等待之後執行</li>
<li>第 5 行的 <code>Promise.resolve()</code> 屬於 <strong>微任務 (microtask)</strong> ，所以 <code>promiseCallback</code> 會被放入 <strong>微任務佇列 (microtask queue)</strong> 中等待之後執行</li>
</ol>
<p>好的，目前為止我們知道了這些異步執行的程式們可以分為兩類 <strong>宏任務 (macrotask)</strong> 以及 <strong>微任務 (microtask)</strong> ，並且會被加入到各自的 <strong>佇列(queue)</strong> ，下一節我們會再進一步瞭解這些被加入到 <strong>佇列(queue)</strong> 中的任務們如何藉由 <strong>event loop</strong> 的安排最終丟入到 <strong>js 主線程(main thread)</strong> 執行</p>
<h2 id="event-loop-如何安排任務的執行順序"><a href="#event-loop-如何安排任務的執行順序" class="headerlink" title="event loop 如何安排任務的執行順序"></a>event loop 如何安排任務的執行順序</h2><img src="event-loop-process.jpg" width="40%">

<img src="event-loop.gif" width="50%">

<br />
圖片來源:

<p><a href="https://yeefun.github.io/event-loop-in-depth/#%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">事件迴圈的基本概念</a><br><a href="https://dev.to/rammcodes/javascript-microtask-vs-macrotask-queue-visually-explained-2209">Javascript MicroTask vs MacroTask Queue - Visually Explained Through An Animation</a></p>
<p>搭配以上這兩張圖，我們可以看到 <strong>宏任務 (macrotask)</strong> 與 <strong>微任務 (microtask)</strong> 實際上用兩個不同的 queue 控制著任務的先後執行 </p>
<ul>
<li><strong>宏任務 (macrotask)</strong> 會被放到 <strong>宏任務佇列 (macrotask queue)</strong> 裡</li>
<li><strong>微任務 (microtask)</strong> 會被放到 <strong>微任務佇列 (microtask queue)</strong> 裡</li>
</ul>
<p>而 <strong>宏任務佇列 (macrotask queue)</strong> 與 <strong>微任務佇列 (microtask queue)</strong> 會藉由 <strong>event loop</strong> 的安排，將任務依序丟往 <strong>堆疊(stack)</strong> 中，最後 <strong>js 主線程(main thread)</strong> 再以 <strong>同步執行 (sync)</strong> 的方式將 <strong>堆疊(stack)</strong> 中的任務執行完成</p>
<p>而從 <strong>event loop</strong> 的角度來看，是以下面的這個邏輯決定怎麼把任務丟到 <strong>堆疊(stack)</strong> 中執行：</p>
<ol>
<li>檢查 <strong>宏任務佇列 (macrotask queue)</strong> 裡是否有 <strong>宏任務 (macrotask)</strong> 需要被執行：<br>1-1. 如果有的話就將最前面的 <strong>宏任務 (macrotask)</strong> 拿出來丟到 <strong>堆疊(stack)</strong> 執行，並前往 <strong>步驟 2.</strong><br>1-2. 如果沒有的話，直接前往 <strong>步驟 2.</strong></li>
<li>檢查 <strong>微任務佇列 (microtask queue)</strong> 裡是否有 <strong>微任務 (microtask)</strong> 需要被執行：<br>2-1. 如果有的話將 <strong>目前所有</strong> 的 <strong>微任務 (microtask)</strong> 依序拿出來丟到 <strong>堆疊(stack)</strong> 執行，並前往 <strong>步驟 3.</strong><br>2-2. 如果沒有的話，直接前往 <strong>步驟 3.</strong></li>
<li>是否需要渲染 UI 畫面：<br>3-1. 需要渲染的話，進行渲染畫面並回到 <strong>步驟 1.</strong><br>3-2. 不需要渲染的話，直接回到 <strong>步驟 1.</strong></li>
</ol>
<p>下面我們直接用程式碼來看 <strong>event loop</strong> 運行的邏輯： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li>第 1 行的 <code>setTimeout</code> 後的 <code>callback function</code> 最初被加入到 <strong>宏任務佇列 (macrotask queue)</strong> 裡，是第一個 <strong>宏任務 (macrotask)</strong> ，等待之後執行</li>
<li>第 4 行的 <code>setTimeout</code> 後的 <code>callback function</code> 會接續加入到 <strong>宏任務佇列 (macrotask queue)</strong> 中，是第二個 <strong>宏任務 (macrotask)</strong> ，等待之後執行</li>
<li>第 8 行的 <code>promise.resolve</code> 後的 <code>callback function</code> 會加入到 <strong>微任務佇列 (microtask queue)</strong> 裡，是第一個 <strong>微任務 (microtask)</strong> ，等待之後執行</li>
<li>第 11 行的 <code>promise.resolve</code> 後的 <code>callback function</code> 會加入到 <strong>微任務佇列 (microtask queue)</strong> 裡，是第二個 <strong>微任務 (microtask)</strong> ，等待之後執行</li>
<li>第 14 行的 <code>promise.resolve</code> 後的 <code>callback function</code> 會加入到 <strong>微任務佇列 (microtask queue)</strong> 裡，是第三個 <strong>微任務 (microtask)</strong> ，等待之後執行</li>
</ol>
<p><strong>結果：</strong><br>如右上角的 .gif 動圖所示，即使兩個 <code>setTimeout</code> 在程式上的順序是先寫在前面的，但由於 <strong>微任務 (microtask)</strong> 的優先級高於 <strong>宏任務 (macrotask)</strong> ，所以 <code>Promise.resolve()</code> 後的結果會先被執行，最後才執行 <code>setTimeout</code> 的 <strong>宏任務 (macrotask)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;promise1&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise2&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise3&#x27;</span></span><br><span class="line"><span class="string">&#x27;timeout1&#x27;</span></span><br><span class="line"><span class="string">&#x27;timeout2&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="event-loop-之後-渲染畫面"><a href="#event-loop-之後-渲染畫面" class="headerlink" title="event loop 之後 - 渲染畫面"></a>event loop 之後 - 渲染畫面</h2><p>接著讓我們來看看 <strong>event loop</strong> 之後，瀏覽器怎麼進行畫面渲染：</p>
<img src="browser-render.png" width="50%">

<p>圖片來源: <a href="https://nolanlawson.github.io/css-talk-2022/#96">CSS runtime performance</a></p>
<p>上圖左側的 <strong>JavaScript</strong> 代表了我們上面所討論的 <strong>宏任務 (macrotask)</strong> 與 <strong>微任務 (microtask)</strong> ，當 <strong>JavaScript</strong> 執行完成後，瀏覽器開始準備渲染畫面，畫面的渲染大致上切分成四個部分：</p>
<ol>
<li><p><a href="https://nolanlawson.github.io/css-talk-2022/#13">Style</a><br>計算每個 DOM element 的樣式 (color, margin 等)</p>
</li>
<li><p><a href="https://nolanlawson.github.io/css-talk-2022/#14">Layout</a><br>上面的 Style 計算完後，瀏覽器會知道每個 DOM element 該有的樣式，接著就會開始計算這些 element 佔用的空間，這包含位置、寬度等等</p>
</li>
<li><p><a href="https://medium.com/@wutamy77/how-browser-rendering-works-%E7%80%8F%E8%A6%BD%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90-6236d21403b4">Paint</a><br>開始針對網頁中的每個像素點進行繪製，包括顏色、陰影等等</p>
</li>
<li><p><a href="https://medium.com/@wutamy77/how-browser-rendering-works-%E7%80%8F%E8%A6%BD%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90-6236d21403b4#:~:text=%E6%A0%BC%E5%8C%96%E6%96%B9%E5%BC%8F-,Compositing,-%EF%BC%88%E5%90%88%E6%88%90%EF%BC%89">Composite</a><br>最後一步是根據不同的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context">圖層</a> 來安排各個 element 的位置</p>
</li>
</ol>
<ul>
<li><code>requestAnimationFrame</code><br>最後特別提到的是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>，他的執行時機在 <strong>Style</strong> 之前，可以保證在每一幀的畫面渲染前執行，常用來做動畫效果或網頁 3D 場景的處理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">200</span>) <span class="keyword">return</span>;</span><br><span class="line">  dom.<span class="property">style</span>.<span class="property">marginLeft</span> = <span class="string">`<span class="subst">$&#123;i&#125;</span>px`</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(animation);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(animation);</span><br></pre></td></tr></table></figure>
<p>現在大部分的螢幕通常是以 60Hz 的頻率更新畫面，如此可以讓人眼察覺不到每一幀畫面的差別，從而做到順暢的動畫，因此瀏覽器中在每一幀更新畫面的時間約為 <code>1/60 = 17ms</code>，所以 <code>animation</code> 函式大約會每 <code>17ms</code> 就執行一次</p>
<h2 id="event-loop-的全貌"><a href="#event-loop-的全貌" class="headerlink" title="event loop 的全貌"></a>event loop 的全貌</h2><p>最後讓我們來看完整的 <strong>event loop</strong>：</p>
<img src="event-loop-60fps.png" width="50%">

<p>圖片來源: <a href="https://blog.xnim.me/event-loop-and-render-queue">Browser Event loop: micro and macro tasks, call stack, render queue: layout, paint, composite</a></p>
<p>整個完整的 <strong>event loop</strong> + 瀏覽器的畫面渲染流程如上圖所示，在一整圈的執行中，瀏覽器會盡量以 60Hz 的頻率渲染畫面，也就是說每一幀(圈)更新畫面的時間約為 <code>1/60 = 17ms</code></p>
<ol>
<li><p>最初從圖中左側開始，Javascript 會從 <strong>宏任務佇列 (macrotask queue)</strong> 挑出第一個 <strong>宏任務 (macrotask)</strong> 執行，接著執行完 <strong>微任務佇列 (microtask queue)</strong> 中所有的 <strong>微任務 (microtask)</strong></p>
</li>
<li><p>在準備進行瀏覽器渲染前會執行 <code>requestAnimationFrame</code></p>
</li>
<li><p>進入瀏覽器渲染的流程：<strong>Style</strong> &#x3D;&gt; <strong>Layout</strong> &#x3D;&gt; <strong>Paint</strong> &#x3D;&gt; <strong>Composite</strong></p>
</li>
<li><p>渲染畫面後重新回到 步驟 1. 循環執行這一整圈的 <strong>event loop</strong></p>
</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">請說明瀏覽器中的事件循環 (Event Loop)</a></p>
</li>
<li><p><a href="https://jianline.com/javascript-event-loop/">[筆記]-JavaScript Event Loop是什麼?Event Loop的3個重點</a><br>簡短的文章幫助快速的了解 event loop</p>
</li>
<li><p><a href="https://realdennis.medium.com/%E6%80%8E%E9%BA%BC%E7%90%86%E8%A7%A3-microtask-macrotask-7754939b3c2c">怎麼理解 microtask &amp; macrotask</a></p>
</li>
<li><p><a href="https://macarthur.me/posts/navigating-the-event-loop">Picking the Right Tool for Maneuvering JavaScript’s Event Loop</a><br>作者寫了一些範例演示了 同步、異步 以及 宏任務 (macrotask)、微任務 (microtask) 的程式碼如何對畫面 UI 的堵塞造成不同影響</p>
</li>
<li><p><a href="https://yeefun.github.io/event-loop-in-depth/">我知道你懂 Event Loop，但你了解到多深？</a><br>從 HTML spec 的角度詳細探討 event loop 的執行順序</p>
</li>
<li><p><a href="https://www.shubo.io/browser-rendering/">瀏覽器轉譯&#x2F;渲染(Browser Rendering)原理</a><br><a href="https://web.dev/articles/rendering-performance?hl=zh-tw">轉譯效能</a><br>完整的介紹瀏覽器渲染的各個步驟</p>
</li>
<li><p><a href="https://nolanlawson.github.io/css-talk-2022/#10">CSS runtime performance</a><br>非常豐富生動的圖描繪出瀏覽器的渲染過程</p>
</li>
<li><p><a href="https://blog.xnim.me/event-loop-and-render-queue">Browser Event loop: micro and macro tasks, call stack, render queue: layout, paint, composite</a><br>完整的從 event loop 一路介紹到瀏覽器渲染畫面的優質文章</p>
</li>
<li><p><a href="https://hentaicracker.github.io/2020/rAF.html#_1-%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe">什么是 requestAnimationFrame</a><br>從 requestAnimationFrame 的角度出發，探討分別使用 requestAnimationFrame 及 setTimeout 當作計時器的差別</p>
</li>
</ul>

<style>
.log {
	color: #9c9;
  font-weight: bold;
}
</style>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>理解 Three.js 中 texture 的 offset, repeat 及 wrap</title>
    <url>/blog/2024/02/18/%E7%90%86%E8%A7%A3-three-js-%E4%B8%AD-texture-%E7%9A%84-offset-repeat-%E5%8F%8A-wrap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Threejs 中的 texture(貼圖) 可以設置 offset, repeat 及 wrap 屬性，但大部分文章都只有文字說明而沒有視覺化的範例，所以寫了一個視覺化範例讓自己能夠理解</p>
<h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://codesandbox.io/p/devbox/threejs-texture-nds6mp?file=/src/Experience/World/objects/Plane.js:3,21">Demo</a></h5><p>圖片渲染在 (x,y) 平面上，右方橘色線為 x 軸，上方綠色線為 y 軸<br><img src="/blog/2024/02/18/理解-three-js-中-texture-的-offset-repeat-及-wrap/default.png" width="50%" height="50%"></p>
<span id="more"></span>

<h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">experience</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span> = experience;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">create</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">createDebugGUI</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 創建 PlaneGeometry 並設置 texture</span></span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">geometry</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loader</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line">    <span class="keyword">const</span> texture = <span class="variable language_">this</span>.<span class="property">loader</span>.<span class="title function_">load</span>(</span><br><span class="line">      <span class="string">&#x27;https://cdn.pixabay.com/photo/2018/07/09/17/44/baby-elephant-3526681_1280.png&#x27;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">map</span>: texture &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mesh</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(<span class="variable language_">this</span>.<span class="property">geometry</span>, <span class="variable language_">this</span>.<span class="property">material</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">scene</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">mesh</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 設置 debug gui</span></span><br><span class="line">  <span class="title function_">createDebugGUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">offset</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">      .<span class="title function_">name</span>(<span class="string">&#x27;offsetX&#x27;</span>)</span><br><span class="line">      .<span class="title function_">min</span>(-<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">max</span>(<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">step</span>(<span class="number">0.1</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">offset</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">      .<span class="title function_">name</span>(<span class="string">&#x27;offsetY&#x27;</span>)</span><br><span class="line">      .<span class="title function_">min</span>(-<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">max</span>(<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">step</span>(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">repeat</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">      .<span class="title function_">name</span>(<span class="string">&#x27;repeatX&#x27;</span>)</span><br><span class="line">      .<span class="title function_">min</span>(-<span class="number">10</span>)</span><br><span class="line">      .<span class="title function_">max</span>(<span class="number">10</span>)</span><br><span class="line">      .<span class="title function_">step</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">repeat</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">      .<span class="title function_">name</span>(<span class="string">&#x27;repeatY&#x27;</span>)</span><br><span class="line">      .<span class="title function_">min</span>(-<span class="number">10</span>)</span><br><span class="line">      .<span class="title function_">max</span>(<span class="number">10</span>)</span><br><span class="line">      .<span class="title function_">step</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>, <span class="string">&#x27;wrapS&#x27;</span>)</span><br><span class="line">      .<span class="title function_">options</span>(&#123;</span><br><span class="line">        <span class="title class_">RepeatWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">RepeatWrapping</span>,</span><br><span class="line">        <span class="title class_">ClampToEdgeWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">ClampToEdgeWrapping</span>,</span><br><span class="line">        <span class="title class_">MirroredRepeatWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">MirroredRepeatWrapping</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">onChange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span>.<span class="property">debug</span>.<span class="property">gui</span></span><br><span class="line">      .<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>, <span class="string">&#x27;wrapT&#x27;</span>)</span><br><span class="line">      .<span class="title function_">options</span>(&#123;</span><br><span class="line">        <span class="title class_">RepeatWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">RepeatWrapping</span>,</span><br><span class="line">        <span class="title class_">ClampToEdgeWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">ClampToEdgeWrapping</span>,</span><br><span class="line">        <span class="title class_">MirroredRepeatWrapping</span>: <span class="variable constant_">THREE</span>.<span class="property">MirroredRepeatWrapping</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">onChange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">material</span>.<span class="property">map</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Offset-偏移"><a href="#Offset-偏移" class="headerlink" title="Offset - 偏移"></a>Offset - 偏移</h2><p>藉由設置 offset 可以改變 uv 座標對應到的紋理圖片，預設的 offset 為 0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">material.<span class="property">map</span>.<span class="property">offset</span>.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">material.<span class="property">map</span>.<span class="property">offset</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>offset 為 0，原圖位於正中間<br><img src="default.png" width="50%" height="50%"></p>
<div style="display: flex; gap: 10px;">
  <div style="flex: 1">
    <div>offset.x 為 -0.5，圖片會往右半邊偏移</div>
    <img src="x_-0.5.png" width="100%">
  </div>
  <div style="flex: 1">
    <div>offset.x 為 0.5，圖片會往左半邊偏移</div>
    <img src="x_0.5.png" width="100%">
  </div>
</div>

<div style="display: flex; gap: 10px; margin-top: 12px;">
  <div style="flex: 1">
    <div>offset.y 為 -0.5，圖片會往上偏移</div>
    <img src="y_-0.5.png" width="100%">
  </div>
  <div style="flex: 1">
    <div>offset.y 為 0.5，圖片會往下偏移</div>
    <img src="y_0.5.png" width="100%">
  </div>
</div>

<br />

<p>這裡我一直有個疑問，為什麼 offset.x 設為 -0.5 的時候圖片是往右半邊偏移而不是往左半邊偏移呢？後來才想出一個合理的解釋，uv 座標的原點在左下角，而 <code>offset.x = -0.5</code> 的意思是整個 <code>uv 座標系.x - 0.5 = 紋理圖片的位置.x</code>，所以以右上角 uv 座標系的 (1, 1) 來看，x 減掉 0.5 後變成 (0.5, 1) 而這個 (0.5, 1) 對應到的是紋理圖片的位置，所以 offset.x 設為 -0.5 看到的結果就是圖片往右偏移了一半</p>
<img src="https://learn.foundry.com/nuke/content/resources/images/ug_images/uv_coordinates.png">

<img src="uv.png">

<p><a href="https://learn.foundry.com/nuke/content/resources/images/ug_images/uv_coordinates.png">圖片來源 1</a><br><a href="https://www.cnblogs.com/vadim-web/p/13517244.html">圖片來源 2</a></p>
<h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p>控制圖片在 uv 方向會 repeat 多少次，預設值為 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">material.<span class="property">map</span>.<span class="property">repeat</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">material.<span class="property">map</span>.<span class="property">repeat</span>.<span class="property">y</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>repeat 為 1，原圖不會重複<br><img src="default.png" width="50%" height="50%"></p>
<p>repeat.x 跟 repeat.y 都設為 2，所以圖片總共重複 4 次<br>(另外這裡還設定了 wrap 的方式為 THREE.RepeatWrapping，所以才有辦法重複)<br><img src="repeat.png" width="50%" height="50%"></p>
<p>repeat.x 為 -1，設成負數的話圖片會左右顛倒<br>(另外這裡還設定了 wrapS 的方式為 THREE.RepeatWrapping)<br><img src="repeat_minus.png" width="50%" height="50%"></p>
<h2 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h2><p>wrap 處理圖片未填滿時，如何渲染剩餘空間的方式，對應到 x, y 軸設定的屬性名稱分別是 wrapS 及 wrapT</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">material.<span class="property">map</span>.<span class="property">wrapS</span> = <span class="variable constant_">THREE</span>.<span class="property">ClampToEdgeWrapping</span>;</span><br><span class="line">material.<span class="property">map</span>.<span class="property">wrapT</span> = <span class="variable constant_">THREE</span>.<span class="property">ClampToEdgeWrapping</span>;</span><br></pre></td></tr></table></figure>

<p>threejs 中總共有三個值可以做設定：</p>
<ul>
<li>THREE.RepeatWrapping: 重複渲染圖片</li>
<li>THREE.ClampToEdgeWrapping: 最後一個像素點會延伸到邊界 (預設值)</li>
<li>THREE.MirroredRepeatWrapping: 跟 RepeatWrapping 很像，差別是會鏡像的重複渲染</li>
</ul>
<p>這三個值乍看之下很抽象，以下我們來看不同範例的演示，會比較清楚</p>
<h5 id="THREE-RepeatWrapping"><a href="#THREE-RepeatWrapping" class="headerlink" title="THREE.RepeatWrapping"></a>THREE.RepeatWrapping</h5><p>repeat.x 跟 repeat.y 都設為 2，所以圖片總共重複 4 次<br><img src="repeat.png" width="50%" height="50%"></p>
<h5 id="THREE-ClampToEdgeWrapping"><a href="#THREE-ClampToEdgeWrapping" class="headerlink" title="THREE.ClampToEdgeWrapping"></a>THREE.ClampToEdgeWrapping</h5><p>repeat.x 跟 repeat.y 都設為 2，但因為 wrapS 及 wrapT 都設為 THREE.ClampToEdgeWrapping，未填滿的地方會參考最後一個像素點做延伸，而這張大象左邊的耳朵及尾巴分別是最遠的像素點，所以會從這兩點延伸到邊界<br><img src="clamp.png" width="50%" height="50%"></p>
<h5 id="THREE-MirroredRepeatWrapping"><a href="#THREE-MirroredRepeatWrapping" class="headerlink" title="THREE.MirroredRepeatWrapping"></a>THREE.MirroredRepeatWrapping</h5><p>repeat.x 跟 repeat.y 都設為 2，所以圖片總共重複 4 次，但因為是鏡像渲染，所以上下左右的圖片分別是對稱的<br><img src="repeat_mirror.png" width="50%" height="50%"></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>threejs r159</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://juejin.cn/post/7062172473726337054">ThreeJs入门18-纹理的重复和纹理的回环</a><br><a href="https://www.cnblogs.com/vadim-web/p/13517244.html">three.js UV映射简述</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>2024/12/23 (一)</title>
    <url>/blog/2025/01/05/2024-12-23-%E4%B8%80/</url>
    <content><![CDATA[<h5 id="晚上-8-00"><a href="#晚上-8-00" class="headerlink" title="- 晚上 8:00"></a>- 晚上 8:00</h5><p>奶奶打電話很緊急的跟我說爺爺睡著人都叫不醒，而且全身都硬硬的，大聲叫我快回家看怎麼辦</p>
<p>我一回家後發現爺爺打呼超大聲，雙腳呈現交疊在一起的不正常姿勢，我趕快叫爺爺及推推他發現的確完全叫不醒，然後我趕快 google 搜尋 “老人睡覺叫不醒 打呼”，發現沒有什麼好的方式處理，這時奶奶一直推爺爺、按摩他的手、在耳朵旁邊大聲呼喊，但爺爺還是一樣大聲的打呼，雖然我覺得狀況很緊急但奶奶還是不願意打 119，最後在網路上我找不到任何方式可以喚醒爺爺，大約過了十幾分鐘後我覺得真的不行就趕快打 119</p>
<p>這是我第一次叫救護車來家裡，很快的大約十分鐘後就來了，兩位年輕男生拿著檢測心電圖的儀器一路進到爺爺的房間，檢查心電圖、血糖、脈搏、體溫等等，但似乎沒發現任何異常的地方，接著只好把爺爺移到擔架，抬出去到門外走廊的躺椅到救護車上，因為這一天天氣很冷，這時救護員提醒我拿條被子給爺爺蓋，我順手抓著家裡的毯子就跟他們上救護車</p>
<p>這是我第一次以陪病的角色上救護車，上次是我自己騎車自摔叫救護車送急診，家裡到松山醫院很快約五分鐘就到了，下救護車馬上就有個阿姨過來用個儀器看起來是量血壓之類的，然後問問爺爺的病史，爺爺非常健康大概只有高血壓，在一陣檢查後突然最後說可以接受插管嗎？(一個禮拜多後的我回想，雖然當下因為緊張記不清了，但應該是這句話)，當下我也是愣住了，什麼是插管？但都到急診室了，如果需要的話就應該就要插吧</p>
<p>後來他們就把爺爺推到裡面做了各項檢查，印象中有用原子筆畫過腳底，應該是做什麼反射測試之類的 (現在我才知道應該是<a href="https://bigheartot.com/2019/06/06/%E5%B7%B4%E8%B3%93%E6%96%AF%E5%9F%BA%E6%B8%AC%E8%A9%A6%EF%BC%8C%E4%B8%80%E7%A7%92%E6%B8%AC%E8%A9%A6%E6%9C%89%E6%B2%92%E6%9C%89%E4%B8%AD%E9%A2%A8/">巴賓斯基測試</a>)，接著爺爺身上就貼了各種量測心電圖的貼片、量測血壓等等的東西，這時我都在病床旁邊緊張的看接著要做什麼樣的檢查</p>
<p>後來第一個正式的檢查是電腦斷層 CT，照完後醫生說看不出有腦出血的現象。測試爺爺四肢的脈搏都正常，除了左手超級低我有看到大約是 57&#x2F;30，因此醫生懷疑是主動脈剝離，接著要簽同意書注射顯影劑再照一次 CT，這時我就很緊張了趕快查查主動脈剝離會怎麼樣，聽起來就是很嚴重的疾病，此時從進來醫院大概過了一個多小時了吧，大姑姑接到奶奶緊急的電話終於趕到急診室來了，後來等到第二次 CT 照完，醫師表示沒看到主動脈剝離的狀況，所以目前狀況不明，不知道造成爺爺昏迷叫不醒的原因是什麼…</p>
<h5 id="晚上-10-00"><a href="#晚上-10-00" class="headerlink" title="- 晚上 10:00"></a>- 晚上 10:00</h5><p>記得這時差不多十點左右，護士說爺爺這昏迷的狀況需要住進加護病房，但等會十二點是加護病房的交班時刻，所以最快大概也要等到凌晨兩三點才有辦法上去，聽到這我想趁現在先回家整理拿個東西再過來，走出急診室原本想路邊攔計程車回家但好像都沒有車，乾脆就直接走回家了，那天似乎還下著小雨，走到一半接到 Mei 的電話，說實在我忘記他說什麼了，但這種時候有人來打電話關心覺得很溫暖</p>
<p>原本我打算先回家吃點東西、洗個澡後再去醫院做準備，但沒想到才到家就接到大姑姑傳訊息，醫生說要在十點半前決定病人要不要插管，因為爺爺目前意識昏迷雖然呼吸正常但不知道會不會隨時停止，所以才建議插管，此時詩茵趕快塞給我兩個和菓子讓我帶去醫院吃，接著我又趕快回奶奶家，跟他說爺爺的狀況，以及是否要插管等等問題，奶奶看樣子也無法做決定，之後我打字跟他說有什麼需要急救的狀況都交給我跟大姑姑決定 ok 嗎？獲得同意後我就趕快再趕回醫院</p>
<p>回到急診室，又再一次的跟急診醫生討論，詢問為什麼突然就要決定要不要插管？半小時前不是還說沒什麼事，先觀察看看嗎？他說他有致電神經內科的醫師，他建議馬上插管，當下我們也搞不清楚只好相信急診室建議的措施，後來醫生很快的就進行插管，有用一個像大氣球塑膠瓶的東西不斷灌氣吸氣等等，旁邊圍著醫生跟五、六個護士都在幫忙，看起來就令人膽戰心驚，但還好沒有很久似乎就弄好了，這時在急診室外面的我們還是聽得到爺爺很大聲打呼的聲音</p>
<p>後來就是漫長的聊天時間了，我跟大姑姑在急診室外面等待順便聊天，聊了很多家庭、家人，以前我不知道的事情，到後來 12 點多了，大姑姑先叫計程車回去，剩下我陪爺爺等，看什麼時候上加護病房，在急診室外面來回踱步的我大概等到快三點吧，終於可以上加護病房了，我陪著爺爺的病床上去一直在旁邊跟他說沒事沒事，希望他可以聽到緩和情緒</p>
<p>進到加護病房後，護理師人很好的詢問我爺爺以前的病況，才發現上次爺爺的膀胱癌開刀竟然已經是七年前的事了，我還以為只過了三、四年左右，另外護理師又交代了加護病房的看病時間 (早上 11:00 - 11:30、晚上 7:00 - 7:30)，以及明天要購買的紙巾、乳液等等清單，最後又發了不施行心肺復甦術同意書，上面要勾選同不同意使用插管、心臟電擊、心臟按摩、藥物注射等等這些，太多東西了這些等著明天再與大姑姑討論，最後離開醫院回到家已經凌晨四點多了</p>
<div style="text-align: right">2025/01/01 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2024/12/26 (四)</title>
    <url>/blog/2025/01/06/2024-12-26-%E5%9B%9B/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>昨天中午 12:00 做的 MRI 有初步的結果了，住院醫生說爺爺腦部有大片栓塞的狀況，判斷是缺血性腦中風，從住院到現在都有用藥治療幫助疏通，另外因為他们覺得爺爺現在自己呼吸狀況不錯，所以考慮明天下午拔氣管讓他自己呼吸，但拔氣管後可能會有各種需要設想的狀況，例如：爺爺現在沒有什麼咳嗽反應，所以如果之後有痰咳不出來，又需要再插回氣管，這樣的話基本就不能再拔管了，還有其他需要考量的點，這部分他們會再幫忙約主治醫生明天詳談</p>
<h5 id="晚上-7-30-後"><a href="#晚上-7-30-後" class="headerlink" title="- 晚上 7:30 後"></a>- 晚上 7:30 後</h5><p>前一晚與大姑姑討論明天要問主治醫生的問題</p>
<ul>
<li>預計明天下午可以拔掉呼吸管</li>
<li>如果之後呼吸器再插回去是否可以繼續住在加護病房</li>
<li>如果選擇氣切的話是要轉到呼吸治療不能待在加護病房嗎？待在加護病房的條件是什麼？</li>
<li>氣切的缺點？</li>
<li>能不能選擇一直插管？</li>
<li>爺爺現在用的是哪種藥，功效如何？</li>
<li>就醫生評估爺爺再睜開雙眼的機率多大？</li>
<li>嘴巴閉起來算是有意識，不是中風的現象嗎？</li>
<li>他眼珠子跟身體會動這樣子算是什麼階段的昏迷（昏迷指數），算嚴重嗎？</li>
<li>想問怎麼樣的方式爺爺比較不痛、不辛苦？</li>
<li>我們今天有摸他的額頭，他的反應很激動，皺眉想哭，這是代表有意識嗎？</li>
<li>爺爺反應這麼大，除了眼睛無法張開，算不算意識清楚，狀況良好？</li>
<li>請看護的話榮民會有補助嗎？</li>
</ul>
<div style="text-align: right">2025/01/03 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2024/12/27 (五)</title>
    <url>/blog/2025/01/07/2024-12-27-%E4%BA%94/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>第一次與主治醫生的會面，原本昨天狀況良好，呼吸器都改成訓練模式，住院醫生說預計今天下午可以拔管，所以我們前一晚想了一堆拔管後可能面臨狀況的問題，但沒想到今天一早來到加護病房，突然說爺爺昨晚有肺部感染的狀況，痰液變多，所以呼吸器也沒辨法再用訓練模式，原本預計要拔管但目前狀況無法，隨後主治就在病床前講了一堆狀況，目前肺部感染所以有使用抗生素治療，那如果不能拔管的話，之後建議我們做氣切</p>
<p>這時候我們其實也愣住了，為什麼昨天說狀況良好可以拔管，現在突然變成要做氣切，要從脖子開一個洞進去？這樣也就算了，這時最令人不爽的是整個對話過程，我們只聽到主治一直強調要做氣切做氣切，這樣對於之後護理比較好，雖然我們之後查過資料的確是這樣，但主治講話的語氣讓我們非常不舒服，他的眼神總是飄來飄去，光看就覺得他完全沒有要專注理解我們的心情與想法，講到最後還會說「你們到底有沒有聽懂」，總之第一次與主治的討論讓我們感到極度不舒服，感覺很不被尊重，就只是一直丟給我們說要做氣切這條路</p>
<div style="text-align: right">2025/01/03 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2024/12/28 (六)</title>
    <url>/blog/2025/01/07/2024-12-28-%E5%85%AD/</url>
    <content><![CDATA[<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>今天是奶奶第一次去醫院看爺爺，原本希望他在早上 11:00 的探訪時間來的，畢竟早上探病有陽光比較好的感覺，但他說太早了起不來實在沒有辦法，在去看爺爺之前，奶奶就一直說要幫他用力按手部的穴道、拍胸，這樣就可以把他喚醒了，在奶奶進去病房後，我很小心地站在前面的位置，以防奶奶衝動動到那些管子，奶奶果然對著爺爺的手大力地狂按，說什麼要按這個穴道，爺爺之前最討厭他按這裡，只要一按他就會起來了，奶奶不斷的按不斷地叫著爺爺快起來，把他的各種名字都叫過了，鐵三？好像是爺爺小時候的小名，即使奶奶不斷的按壓手掌、手指，那按壓的力道光看著就覺得很痛，不斷的將手整個抬起來上下晃，但爺爺還是維持原樣，後來又更進階了，奶奶開始拍打爺爺的耳朵，這力道根本就是拍耳光了，接著又不斷地在胸前拍拍拍，不斷來回的折騰重複了好幾次，邊拍邊叫著「爺爺有意識了，手腳都有不時跳動，就只差眼睛沒睜開了！」不斷喊著叫爺爺眼睛睜開回家！回家！就這樣叫喊著二十幾分鐘過去了吧，最終奶奶終於撐不住腰痛，說他累不行了，爺爺再不起來自己要回家了</p>
<p>就這樣雖然我知道爺爺不可能因為按摩穴道、拍打身體，就可以成功睜開眼睛，但誰也不知道這是不是最後一次，至少今天奶奶終於來看爺爺了</p>
<div style="text-align: right">2025/01/04 筆</div>]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2024/12/31 (二)</title>
    <url>/blog/2025/01/08/2024-12-31-%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>護士說最近爺爺有水腫的狀況，可能是營養或藥物沒有吸收完全，會滲到身體四肢，的確按壓爺爺的手掌皮膚都沒有回彈起來，護士說這已經是<a href="https://www.canceraway.org.tw/page.php?IDno=1528">四價的水腫了</a>，我後來查了一下這好像是最嚴重的水腫狀況，另外也問了爺爺目前的白蛋白指數，大約是 2.5-2.7g&#x2F;dl，已經滿低的了，所以問我們要不要自費打白蛋白 1800 一罐，於是我們填了白蛋白自費同意書，整個療程共五天</p>
<h5 id="晚上-11-50"><a href="#晚上-11-50" class="headerlink" title="- 晚上 11:50"></a>- 晚上 11:50</h5><p>正在邊看電視轉播跨年演唱會邊準備錄影窗外 101 煙火的我，突然手機響了一看竟然是松山醫院打來的電話，他們說就在剛剛爺爺突然心跳停止了兩次，但用升壓藥後目前有恢復心跳，問我要不要去醫院看看爺爺</p>
<p>我馬上換個衣服騎車到加護病房，一進去裡面一、二十個護士都在忙，在元旦跨年這一天醫護人員還真是辛苦，之後住院醫生來講解說剛剛爺爺有心跳驟停的狀況，但抽血檢驗後看不出來有什麼異常，所以目前也不知道什麼原因導致的，但用了升壓藥後有恢復起來，後來醫生說建議輸血可以幫助心臟跳動的活力，於是我馬上簽了一個輸血同意書，接著我在病床旁邊跟爺爺聊著天，告訴他今天已經是民國 114 年 1 月 1 日元旦囉，新年快樂爺爺～ 跟爺爺聊著天，希望他放鬆不要擔心，直到護士要準備輸血的時候才被趕回去</p>
<div style="text-align: right">2025/01/05 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Three.js 操作 shader 畫出國旗</title>
    <url>/blog/2024/12/06/%E4%BD%BF%E7%94%A8-three-js-%E6%93%8D%E4%BD%9C-shader-%E7%95%AB%E5%87%BA%E5%9C%8B%E6%97%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這是我第一篇學習 shader 的文章，藉由上完 <a href="https://threejs-journey.com/">three.js journey lessons 27 - Shaders</a> 後，嘗試延伸用老師的範例畫出自己國家的國旗</p>
<h2 id="為什麼需要寫-shader"><a href="#為什麼需要寫-shader" class="headerlink" title="為什麼需要寫 shader?"></a>為什麼需要寫 shader?</h2><p>Three.js 裡已經有內建各式各樣的 Geometry (ex. PlaneGeometry, BoxGeometry) 可以創建不同形狀的物體，但如果需要對這些 Geometry 裡個別的頂點們進行操作 (ex. 改變位置、顏色) 就需要 Shader 來進行精細的操作</p>
<span id="more"></span>

<h2 id="著色器渲染管道-Shader-pipeline"><a href="#著色器渲染管道-Shader-pipeline" class="headerlink" title="著色器渲染管道 (Shader pipeline)"></a>著色器渲染管道 (Shader pipeline)</h2><p>實際上 Shader 的渲染是一連串操作的過程 (pipeline)，shaders 們依序處理各自負責的任務</p>
<img src="https://vulkan-tutorial.com/images/vulkan_simplified_pipeline.svg" width="50%" height="50%">

<p><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">圖片來源</a></p>
<h4 id="1-頂點數據-vertex-index-buffer"><a href="#1-頂點數據-vertex-index-buffer" class="headerlink" title="1. 頂點數據 (vertex&#x2F;index buffer)"></a>1. 頂點數據 (vertex&#x2F;index buffer)</h4><p>從 three.js 的角度來看，圖中最一開始輸入的 vertex&#x2F;index buffer 代表的是頂點數據，也就是在 <code>geometry.attribute.position</code> 裡 3D 物件的頂點座標</p>
<img src="attribute-position.png" width="75%" height="75%">

<h4 id="2-頂點著色器-vertex-shader"><a href="#2-頂點著色器-vertex-shader" class="headerlink" title="2. 頂點著色器 (vertex shader)"></a>2. 頂點著色器 (vertex shader)</h4><p>接著輸入的頂點數據會傳到 <strong>頂點著色器 (vertex shader)</strong> ，<strong>頂點著色器 (vertex shader)</strong> 最終會將這些頂點數據從 <strong>本地座標 (local coordinates)</strong> 轉換成 <strong>螢幕座標 (screen coordinates)</strong> ，這個 <strong>螢幕座標 (screen coordinates)</strong> 代表的就是最後在螢幕上使用者看到 3D 物件的樣子</p>
<h4 id="3-光柵化-rasterization"><a href="#3-光柵化-rasterization" class="headerlink" title="3. 光柵化 (rasterization)"></a>3. 光柵化 (rasterization)</h4><p>雖然 <strong>頂點著色器 (vertex shader)</strong> 已經算出各頂點該在螢幕上的哪裡出現，但螢幕有所謂的最小單位 - 像素點，也就是說一個像素點中只能是同一種顏色，在 <strong>光柵化 (rasterization)</strong> 的過程中，會輸入 <strong>頂點著色器 (vertex shader)</strong> 拿到的頂點，並決定這些頂點區域內的哪些像素是需要被渲染的(也就是圖中塗黑的塊狀部分)</p>
<h4 id="4-片段著色器-fragment-shader"><a href="#4-片段著色器-fragment-shader" class="headerlink" title="4. 片段著色器 (fragment shader)"></a>4. 片段著色器 (fragment shader)</h4><p><strong>光柵化 (rasterization)</strong> 輸出最終會被渲染到螢幕上的像素，在英文中這些需要被渲染的像素點們被叫做 - <strong>片段 fragment</strong>。決定哪些像素點需要渲染後，<strong>片段著色器 (fragment shader)</strong> 會為每一個點渲染顏色</p>
<p>以上是關於 Shader 的簡易介紹，了解這些前置知識後就可以練習如何用 three.js 來寫 shader 了</p>
<h2 id="用-three-js-寫一個最基礎的-shader"><a href="#用-three-js-寫一個最基礎的-shader" class="headerlink" title="用 three.js 寫一個最基礎的 shader"></a>用 three.js 寫一個最基礎的 shader</h2><p>在 three.js 中可以使用 <a href="https://threejs.org/docs/#api/en/materials/RawShaderMaterial">THREE.RawShaderMaterial</a> 來撰寫 shader，以下範例畫出一個紅色的平面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> vertexShader <span class="keyword">from</span> <span class="string">&#x27;./vertex.glsl&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fragmentShader <span class="keyword">from</span> <span class="string">&#x27;./fragment.glsl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">RawShaderMaterial</span>(&#123;</span><br><span class="line">  vertexShader,</span><br><span class="line">  fragmentShader</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line"><span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_Position</span> = projectedPosition;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>沒有接觸過的 shader 的我，看到這些完全一頭霧水，uniform mat4 是什麼東東？啥是 modelMatrix？為什麼三種 matrix 接續乘在一起等於 gl_Position? 還好最基本的 shader 程式並不長，接著讓我們來一步步學習</p>
<h4 id="Vertex-shader-做的事情"><a href="#Vertex-shader-做的事情" class="headerlink" title="Vertex shader 做的事情"></a>Vertex shader 做的事情</h4><p>從前面可以知道在整個 shader pipeline 中，<strong>vertex shader</strong> 負責把 <strong>輸入的頂點數據</strong> 轉換為 <strong>螢幕座標 (screen coordinates)</strong> ，這也就是最後一行 <code>gl_Position</code> 所代表的意思，而中間使用到的 <code>modelMatrix</code>, <code>viewMatrix</code>, <code>projectionMatrix</code> 其實也就是對不同座標系進行轉換的矩陣</p>
<img src="https://learnopengl.com/img/getting-started/coordinate_systems.png" width="75%" height="75%">

<p><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">圖片來源</a></p>
<ul>
<li><code>modelMatrix</code> 將 <strong>本地座標 (local coordinate)</strong> 轉換到 <strong>世界座標 (world coordinates)</strong></li>
<li><code>viewMatrix</code> 將 <strong>世界座標 (world coordinates)</strong> 轉換到 <strong>視圖座標 (view coordinates)</strong></li>
<li><code>projectionMatrix</code> 將 <strong>視圖座標(view coordinates)</strong> 轉換到 <strong>裁剪座標 (clip coordinates)</strong></li>
<li>最後會有一個 <strong>視圖轉換 (viewport transform)</strong> 的過程，會根據每個螢幕不同的大小 (ex. 800x600, 1440x900 等) 將 <strong>裁剪座標(clip coordinates)</strong> 轉換為 <strong>螢幕座標 (screen coordinate)</strong> ，此時就是我們實際在螢幕上看到 3D 物件呈現的樣貌了</li>
</ul>
<h4 id="Fragment-shader-做的事情"><a href="#Fragment-shader-做的事情" class="headerlink" title="Fragment shader 做的事情"></a>Fragment shader 做的事情</h4><p><strong>Fragment shader</strong> 會拿到 <strong>vertex shader</strong> 那邊過來每個點的座標，在這裡需要決定每個點渲染出來的顏色並傳遞到 <code>gl_FragColor</code> 中，<code>gl_FragColor</code> 是一個四個向量的 <code>vec4</code> 代表 <strong>(r, g, b, a)</strong> ，最後一個 <code>a</code> 是 <strong>alpha</strong> 代表透明度 - 從 0.0 的完全透明 到 1.0 完全不透明</p>
<p>而 rgb 的範圍也是從 0.0 ~ 1.0，從 0.0 的顏色越淺 到 1.0 的顏色越深，所以 <code>gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)</code> 這行程式渲染出來的會是不透明的純紅顏色</p>
<h4 id="Shader-的變量類型"><a href="#Shader-的變量類型" class="headerlink" title="Shader 的變量類型"></a>Shader 的變量類型</h4><p>到目前為止我們已經了解 shader 渲染的過程了，接著讓我們來看看如何撰寫 shader 的關鍵 - 定義 shader 中的變量類型</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br></pre></td></tr></table></figure>

<p>定義一個變量時前面會有兩個關鍵字，以 <code>modelMatrix</code> 來說就是 <code>uniform</code> 及 <code>mat4</code></p>
<p><code>uniform</code> 代表的是這個變量的作用域，有點類似 Javascript 中 <code>const</code>, <code>let</code> 的感覺，他的意思是這個變量的數值在整個 shader 的繪圖過程中都是保持不變的，而 <code>mat4</code> 是這個變量的數據型別代表 4x4 的矩陣</p>
<p>接著來看看除了 <code>uniform</code> 外還有哪幾種關鍵字可以定義變量的作用域：</p>
<table>
<thead>
<tr>
<th>關鍵字</th>
<th>使用範圍</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>uniform</td>
<td>vertex shader &amp; fragment shader</td>
<td>全局變量，數值在整個繪圖過程中都保持不變</td>
</tr>
<tr>
<td>attribute</td>
<td>vertex shader</td>
<td>頂點數據，也就是 geometry.attribute 裡的那些數值 (預設有 position, uv, normal)</td>
</tr>
<tr>
<td>varying</td>
<td>vertex shader &amp; fragment shader</td>
<td>插值變量，用於將數值從 vertex shader 傳遞到 fragment shader</td>
</tr>
</tbody></table>
<p>另外下表列出一些常見的數值類型：</p>
<table>
<thead>
<tr>
<th>數值類型</th>
<th>說明</th>
<th>範例</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>整數</td>
<td>int a &#x3D; 10;</td>
</tr>
<tr>
<td>float</td>
<td>浮點數</td>
<td>float b &#x3D; 3.14;</td>
</tr>
<tr>
<td>vec2</td>
<td>二維向量</td>
<td>vec2 c &#x3D; vec2(0.5, 1.0);</td>
</tr>
<tr>
<td>vec3</td>
<td>三維向量</td>
<td>vec3 d &#x3D; vec3(1.0, 0.0, 0.0);</td>
</tr>
<tr>
<td>vec4</td>
<td>四維向量</td>
<td>vec4 e &#x3D; vec4(1.0, 0.0, 0.0, 1.0);</td>
</tr>
<tr>
<td>mat4</td>
<td>4x4 矩陣</td>
<td>mat4 m &#x3D; mat4(1.0);</td>
</tr>
<tr>
<td>sampler2D</td>
<td>二維紋理取樣器</td>
<td>uniform sampler2D texture1;</td>
</tr>
</tbody></table>
<p>一開始看到這些想必也是霧煞煞的，不知道實際應用的地方，但沒關係接下來要開始利用目前學到的東西來畫出自己國家的國旗，下面我們會用到各種 attribute, varying, vec4, sampler2D 等關鍵字，學習如何定義變數類型及使用的地方</p>
<h4 id="Shader-數值的精度設置"><a href="#Shader-數值的精度設置" class="headerlink" title="Shader 數值的精度設置"></a>Shader 數值的精度設置</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br></pre></td></tr></table></figure>

<p>在 <strong>fragment shader</strong> 中，我們可以看到這一行的設置，這行的意思是將 <code>float</code> 類型變數的精度設置為 <code>mediump</code>，在 <strong>fragment shader</strong> 中開發者可以根據渲染 3D 物件、場景的需求，去設定變數數值的精細度需要多高</p>
<table>
<thead>
<tr>
<th>精細度</th>
<th>說明</th>
<th>適用場景</th>
</tr>
</thead>
<tbody><tr>
<td>highp</td>
<td>高精度 (32 位浮點數)</td>
<td>需要高精度的計算，例如：光照、物理模擬等</td>
</tr>
<tr>
<td>mediump</td>
<td>中精度 (16 位浮點數)</td>
<td>對精度要求中等的場景，例如：紋理 UV 坐標、顏色</td>
</tr>
<tr>
<td>lowp</td>
<td>低精度 (8 位浮點數)</td>
<td>不太需要精度的場景，例如：簡單的顏色計算</td>
</tr>
</tbody></table>
<hr>
<h2 id="範例：操作-shader-畫出國旗"><a href="#範例：操作-shader-畫出國旗" class="headerlink" title="範例：操作 shader 畫出國旗"></a>範例：操作 shader 畫出國旗</h2><h5 id="Online-Demo"><a href="#Online-Demo" class="headerlink" title="Online Demo"></a><a href="https://codesandbox.io/p/devbox/threejs-shader-flag-9qfn3w">Online Demo</a></h5><img src="flag.gif" width="50%" height="50%">

<h4 id="1-創建平面"><a href="#1-創建平面" class="headerlink" title="1. 創建平面"></a>1. 創建平面</h4><p>一開始先利用 <a href="https://threejs.org/docs/#api/en/geometries/PlaneGeometry">THREE.PlaneGeometry</a> 創建平面，並將這個 Plane 的 material 設置成 <a href="https://threejs.org/docs/#api/en/materials/RawShaderMaterial">THREE.RawShaderMaterial</a> 用來載入自己寫的 shaders</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> vertexShader <span class="keyword">from</span> <span class="string">&#x27;./shaders/vertex.glsl&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fragmentShader <span class="keyword">from</span> <span class="string">&#x27;./shaders/fragment.glsl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> textureLoader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">flagTexture</span> = textureLoader.<span class="title function_">load</span>(<span class="string">&#x27;/flag.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">geometry</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">RawShaderMaterial</span>(&#123;</span><br><span class="line">  vertexShader,</span><br><span class="line">  fragmentShader,</span><br><span class="line">  <span class="attr">uniforms</span>: &#123;</span><br><span class="line">    <span class="attr">uFrequency</span>: &#123; <span class="attr">value</span>: <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>(<span class="number">10</span>, <span class="number">5</span>) &#125;,</span><br><span class="line">    <span class="attr">uTime</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    <span class="attr">uTexture</span>: &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">flagTexture</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">mesh</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(<span class="variable language_">this</span>.<span class="property">geometry</span>, <span class="variable language_">this</span>.<span class="property">material</span>);</span><br></pre></td></tr></table></figure>

<p>這裡創建了 3 個 <code>uniforms</code> 傳遞給 <strong>vertex shader</strong></p>
<ul>
<li><p><code>uFrequency</code><br>調整國旗在 x, y 軸方向的起伏頻率，結合右上角的控制滑動條，可以看到起伏頻率改變的效果</p>
</li>
<li><p><code>uTime</code><br>一個不斷隨時間增加的變數，主要是讓國旗隨著時間有動態的起伏，而不是只在螢幕上顯示靜態的國旗</p>
</li>
<li><p><code>uTexture</code><br>引入國旗的圖案，之後會將這個 texture 丟入到 <strong>fragment shader</strong> 將國旗圖片渲染到平面上</p>
</li>
</ul>
<h4 id="2-撰寫-vertex-shader"><a href="#2-撰寫-vertex-shader" class="headerlink" title="2. 撰寫 vertex shader"></a>2. 撰寫 vertex shader</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> uFrequency;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> uv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> elevation = <span class="built_in">sin</span>(modelPosition.x * uFrequency.x - uTime) * <span class="number">0.1</span>;</span><br><span class="line">    elevation += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y - uTime) * <span class="number">0.1</span>;</span><br><span class="line">    modelPosition.z += elevation;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line">    <span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = projectedPosition;</span><br><span class="line"></span><br><span class="line">    vUv = uv;</span><br><span class="line">    vElevation = elevation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>elevation</code><br>運用 sin 函數可以控制輸出在 -1 ~ +1 的特性，達到 x, y 軸有上下起伏的效果<br>第一次計算 <code>elevation</code> 時輸入 <code>modelPosition.x * uFrequency.x</code>，讓控制條可以調整 x 軸起伏的次數<br>第二次計算 <code>elevation</code> 時輸入 <code>modelPosition.y * uFrequency.y</code>，讓控制條可以調整 y 軸起伏的次數<br>在 sin 函數中還加入 <code>uTime</code> 的變數，讓國旗可以有不斷飄揚的效果<br>最後將計算的 <code>elevation</code> 加到 <code>modelPosition.z</code> 上，這樣在視線的方向上就可以看到高低起伏的國旗飄揚</p>
</li>
<li><p><code>varying</code><br>這裡定義了兩個 <code>varying</code> - <code>vUv</code> 跟 <code>vElevation</code>，作用其實很簡單就只是把 <strong>vertex shader</strong> 中的數值傳遞到 <strong>fragment shader</strong> 中用</p>
</li>
</ul>
<h4 id="3-撰寫-fragment-shader"><a href="#3-撰寫-fragment-shader" class="headerlink" title="3. 撰寫 fragment shader"></a>3. 撰寫 fragment shader</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uTexture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(uTexture, vUv);</span><br><span class="line">    textureColor.rgb *= vElevation * <span class="number">2.0</span> + <span class="number">0.65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(textureColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sampler2D</code><br><code>sampler2D</code> 是一個特殊的語法，用途是取出圖片中的顏色<br>在這裡輸入的第一個參數 <code>uTexture</code> 是從 three.js 傳過來的國旗圖片，第二個的參數 <code>vUv</code> 則是平面的 uv 座標，輸出 <code>textureColor</code> 代表的是圖片中每個點的顏色</p>
</li>
<li><p><code>vElevation</code><br><code>textureColor.rgb *= vElevation * 2.0 + 0.65;</code> 這一行目的是讓每個點的亮度隨著 <code>vElevation</code> 的大小改變，當 <code>vElevation</code> 越小的時候計算出來的 rgb 就越小也就是越暗，所以在畫面上可以看到在谷底(遠離視線)的地方會有比較暗的陰影效果</p>
</li>
</ul>
<h2 id="延伸補充"><a href="#延伸補充" class="headerlink" title="延伸補充"></a>延伸補充</h2><h4 id="1-THREE-RawShaderMaterial-與-THREE-ShaderMaterial-的差別"><a href="#1-THREE-RawShaderMaterial-與-THREE-ShaderMaterial-的差別" class="headerlink" title="1. THREE.RawShaderMaterial 與 THREE.ShaderMaterial 的差別"></a>1. THREE.RawShaderMaterial 與 THREE.ShaderMaterial 的差別</h4><p>上面都使用 <code>THREE.RawShaderMaterial</code> 引入 shader，但其實還可以用 <code>THREE.ShaderMaterial</code> 簡化寫法</p>
<p><code>ShaderMaterial</code> 跟 <code>RawShaderMaterial</code> 幾乎是一樣的，差別只是使用 <code>ShaderMaterial</code> 時，<strong>vertex shader</strong> 跟 <strong>fragment shader</strong> 都會在最上面自動注入預設變量，可以少寫幾行程式</p>
<p>例如：原本使用 <code>THREE.RawShaderMaterial</code> 載入 <strong>vertex shader</strong> 需要定義 <code>modelMatrix</code>, <code>viewMatrix</code>, <code>projectionMatrix</code> 跟 <code>position</code></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line"><span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_Position</span> = projectedPosition;</span><br></pre></td></tr></table></figure>

<p>但使用 <code>THREE.ShaderMaterial</code> 後會自動在 <strong>vertex shader</strong> 檔案最上面注入這些變數，就不用再自己寫了</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line"><span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_Position</span> = projectedPosition;</span><br></pre></td></tr></table></figure>

<h4 id="2-為什麼-vertex-shader-不用設置變數精細度？"><a href="#2-為什麼-vertex-shader-不用設置變數精細度？" class="headerlink" title="2. 為什麼 vertex shader 不用設置變數精細度？"></a>2. 為什麼 vertex shader 不用設置變數精細度？</h4><p>根據 OpenGL ES 2.0 的規範，如果沒有顯式設置 <code>float</code> 類型的預設精度，則預設為 <code>highp</code>。而 <strong>fragment shader</strong> 沒有 <code>float</code> 類型的預設精度，所以必須要自己設置</p>
<p><a href="https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader">Why it is necessary to set precision for the fragment shader?</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://threejs-journey.com/">three.js journey lessons 27 - Shaders</a></p>


<style>
table {
  th, td {
   padding: 8px 12px;
  } 
}
</style>


]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</title>
    <url>/blog/2025/02/13/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-1-%E4%BB%80%E9%BA%BC%E6%98%AF%E6%B7%B1%E5%BA%A6%E6%B8%AC%E8%A9%A6%EF%BC%9F/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-1-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-1-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 1 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 1 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我想許多人一開始接觸 <strong>Three.js</strong> 中關於 <strong>深度測試(Depth testing)</strong> 的時候，常會聽到 <code>depthTest</code>, <code>depthWrite</code>，雖然看過很多文章講解這兩者的差別以及應用場景，但說真的還是無法體會兩者差在哪，於是萌生了研究深度測試的想法。而隨著對於深度測試的了解後才發現深挖的東西越來越多，所以才有了這一系列相關的文章</p>
<span id="more"></span>

<h2 id="什麼是深度測試"><a href="#什麼是深度測試" class="headerlink" title="什麼是深度測試"></a>什麼是深度測試</h2><p>當人的眼睛四處看的時候，會看到許多不同的物體，這些物體有些近、有些遠，遠的物體會被近的擋住，而當 <strong>Three.js</strong> 要渲染 3D 物件在場景上時也是一樣的道理，將物體呈現在畫面上時，需要了解每個物體相對於相機(也就是眼睛)之間的遠近關係，而如何判斷物體遠近關係，決定誰要呈現在前面最終將物體渲染到 2D 螢幕上的這種技術就是所謂的深度測試</p>
<h2 id="深度測試是如何運作的"><a href="#深度測試是如何運作的" class="headerlink" title="深度測試是如何運作的"></a>深度測試是如何運作的</h2><p>深度測試會將每個 <strong>像素(fragment)</strong> 的深度值存儲在 <strong>深度緩衝區 (Depth Buffer or z-buffer)</strong> 中，每個 <strong>像素(fragment)</strong> 深度值的範圍都會在 <strong>[0, 1]</strong> 之間，<strong>0</strong> 代表這個 <strong>像素(fragment)</strong> 離相機最近，而 <strong>1</strong> 代表離相機最遠，以 <a href="https://threejs.org/docs/?q=camera#api/en/cameras/PerspectiveCamera">PerspectiveCamera</a> 來說，0 與 1 分別代表的位置就是相機的 <strong>近平面(near plane)</strong> 與 <strong>遠平面(far plane)</strong></p>
<img src="https://learnopengl.com/img/guest/2021/Frustum_culling/VisualCameraFrustum.png" style="width: 50%"/>

<p><a href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">圖片來源</a></p>
<p>在深度測試的過程中，會比較相機視線方向上所有物體的深度值，深度值較大的物體其 <strong>像素(fragment)</strong> 會被丟棄而不會繪製到畫面上。例如：A 物體與 B 物體都在相機的視線方向上，A 較近、B 較遠，當 A 物體先被繪製時，場景上都還沒有東西，這些空白場景 <strong>像素(fragment)</strong> <a href="https://open.gl/depthstencils#:~:text=The%20default%20clear%20value%20for%20the%20depth%20is%201.0f%2C%20which%20is%20equal%20to%20the%20depth%20of%20your%20far%20clipping%20plane%20and%20thus%20the%20furthest%20depth%20that%20can%20be%20represented.%20All%20fragments%20will%20be%20closer%20than%20that%2C%20so%20they%20will%20no%20longer%20be%20discarded.">預設的深度值是 1.0</a>，而 A 物體因為在近平面與遠平面之間，代表深度值會落在 [0, 1] 間，比預設的深度值 1.0 小，因此深度測試判斷 A 物體通過深度測試將其繪製到畫面上，接著繪製 B 時因為他比 A 還要遠，代表 B 的深度值大於 A 的深度值，此時深度測試判斷失敗把 B 的 <strong>像素(fragment)</strong> 丟棄，最終 B 就不會被繪製到畫面上</p>
<h2 id="深度測試的啟用"><a href="#深度測試的啟用" class="headerlink" title="深度測試的啟用"></a>深度測試的啟用</h2><p>在 <strong>Three.js</strong> 中深度測試的啟用定義在 <a href="https://threejs.org/docs/#api/en/materials/Material.depthTest">Material.depthTest</a>，預設值是 <code>true</code>，也就是說在繪製 <strong>Material</strong> 時，會先將 <strong>Material</strong> 中的每個 <strong>像素(fragment)</strong> 與原有 <strong>深度緩衝區</strong> 中的深度值進行比較，如果新的 <strong>像素(fragment)</strong> 比較近(也就是深度值較小) 就會繪製在畫面上，相反來說如果比較遠的話就將這個 <strong>像素(fragment)</strong> 丟棄，不會繪製到畫面上。而如果深度測試關閉的話，代表在繪製 <strong>Material</strong> 時不需要判斷其 <strong>像素(fragment)</strong> 與原有 <strong>深度緩衝區</strong> 中深度值的關係，也就是說這個 <strong>Material</strong> 中的 <strong>像素(fragment)</strong> 不管他所處的位置是遠是近，最終都會被繪製到畫面上</p>
<h2 id="深度測試函式"><a href="#深度測試函式" class="headerlink" title="深度測試函式"></a>深度測試函式</h2><p>指的是當比較兩個 <strong>像素(fragment)</strong> 比較深度值時使用的方式，前面有提到近的物體深度值較小、遠的物體深度值較大，而在進行深度測試時，深度值較小的物體會通過深度測試，為什麼深度值較小的代表通過深度測試呢？原因是定義在 <a href="https://threejs.org/docs/#api/en/materials/Material.depthFunc">Material.depthFunc</a> 的深度測試函式，其預設值是 <code>LessEqualDepth</code>，代表當前 <strong>像素(fragment)</strong> 的深度值小於或等於 <strong>深度緩衝區</strong> 原有的深度值時通過測試，也就是渲染在畫面上。除了預設的 <code>LessEqualDepth</code> 外，還有以下幾種不同的比較方法：</p>
<table>
<thead>
<tr>
<th>運算符名稱</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LessEqualDepth</td>
<td>當前深度值小於或等於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>LessDepth</td>
<td>當前深度值小於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>GreaterEqualDepth</td>
<td>當前深度值大於或等於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>GreaterDepth</td>
<td>當前深度值大於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>EqualDepth</td>
<td>當前深度值等於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>NotEqualDepth</td>
<td>當前深度值不等於緩衝區原有的深度值時通過測試。</td>
</tr>
<tr>
<td>AlwaysDepth</td>
<td>始終通過深度測試，不論深度值如何。</td>
</tr>
<tr>
<td>NeverDepth</td>
<td>始終不通過深度測試，所有片段都會被丟棄。</td>
</tr>
</tbody></table>
<h2 id="是否寫入深度緩衝區"><a href="#是否寫入深度緩衝區" class="headerlink" title="是否寫入深度緩衝區"></a>是否寫入深度緩衝區</h2><p>前面提到運行深度測試的時候會比較兩個 <strong>像素(fragment)</strong> 的深度值，比較後會將深度值較大的 <strong>像素(fragment)</strong> 丟棄，並把深度值較小的 <strong>像素(fragment)</strong> 寫入 <strong>深度緩衝區</strong>，特別的是要不要將深度值寫入 <strong>深度緩衝區</strong> 是可以自行設定的。在 <strong>Three.js</strong> 中是否寫入 <strong>深度緩衝區</strong> 的開關定義在 <a href="https://threejs.org/docs/#api/en/materials/Material.depthWrite">Material.depthWrite</a>，預設值是 <code>true</code>，代表在繪製 <strong>Material</strong> 時，如果深度測試通過會把新 <strong>像素(fragment)</strong> 的深度值寫入 <strong>深度緩衝區</strong>。以兩個物體 A 與 B 來舉例，一開始 A 物體中的 <strong>像素(fragment)</strong> 寫入了深度值為 0.5，接著繪製 B 物體的 <strong>像素(fragment)</strong> 其深度值是 0.3，發現 B 物體中其 <strong>像素(fragment)</strong> 的深度值比較小通過深度測試，就會將 0.3 寫入<strong>深度緩衝區</strong> 中，在下次深度值比較的時候就會將新 <strong>像素(fragment)</strong> 的深度值拿來跟 0.3 進行比較了</p>
<h2 id="了解深度測試的行為"><a href="#了解深度測試的行為" class="headerlink" title="了解深度測試的行為"></a>了解深度測試的行為</h2><p>下面藉由幾個例子更好的了解深度測試是如何運作的，請搭配 <a href="https://codesandbox.io/p/github/bcjohnblue/threejs-what-is-depth-test/main">線上 Demo 版</a> 自行操作</p>
<p>在這個例子中我創建了兩個平面，一個是紅色的平面(z&#x3D;0)，另一個是藍色的平面(z&#x3D;-1)，而相機視野的方向設定是朝向 -z 軸的，所以一開始可以看到紅色的平面在前而藍色的平面在後，下面這張圖是我稍微把相機拉高，所以可以看到後面的藍色平面</p>
<img src="./init.png" style="width: 50%" />

<p>另外值得一提的是，在這個例子中我先繪製的是紅色的平面，接著才是藍色的平面，繪製順序對於後面分析物體遠近關係是很重要的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first draw</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">redPlane</span> = <span class="keyword">new</span> <span class="title class_">Plane</span>(experience);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">redPlane</span>.<span class="property">mesh</span>.<span class="property">position</span>.<span class="property">z</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">redPlane</span>.<span class="property">mesh</span>.<span class="property">material</span>.<span class="property">color</span> = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;#ff0000&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// second draw</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">bluePlane</span> = <span class="keyword">new</span> <span class="title class_">Plane</span>(experience);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">bluePlane</span>.<span class="property">mesh</span>.<span class="property">position</span>.<span class="property">z</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">bluePlane</span>.<span class="property">mesh</span>.<span class="property">material</span>.<span class="property">color</span> = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;#0000ff&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Case-1-切換深度測試的開關"><a href="#Case-1-切換深度測試的開關" class="headerlink" title="Case 1. 切換深度測試的開關"></a>Case 1. 切換深度測試的開關</h4><ol>
<li>紅色平面的 <code>depthTest</code> 設為 <code>false</code> &#x3D;&gt; 藍色平面被繪製上去<br>繪製紅色平面時因為沒有開啟深度測試，因此紅色平面 <strong>像素(fragment)</strong> 的深度值也不會寫入 <strong>深度緩衝區</strong> 中，後面當繪製藍色平面時，藍色平面 <strong>像素(fragment)</strong> 比較的深度值都是 <strong>深度緩衝區</strong> 中預設的 1.0，藍色平面 <strong>像素(fragment)</strong> 都比 1.0 小通過深度測試，所以最終藍色平面覆蓋紅色平面繪製到畫面上</li>
</ol>
<img src="./depth-test-red-disabled.png" style="width: 50%" />

<ol start="2">
<li>藍色平面的 <code>depthTest</code> 設為 <code>false</code> &#x3D;&gt; 藍色平面被繪製上去<br>繪製藍色平面時因為沒有開啟深度測試，也就不會將藍色平面中的 <strong>像素(fragment)</strong> 去與原先 <strong>深度緩衝區</strong> 的值進行比較，最終藍色平面會直接繪製在畫面上。這邊可以看到一個特性，就是當 <code>depthTest</code> 關閉時，完全不需要管原有 <strong>深度緩衝區</strong> 中的深度值是多少，只要後畫的物體都一定會在畫面上呈現</li>
</ol>
<img src="./depth-test-blue-disabled.png" style="width: 50%" />

<h4 id="Case-2-改變深度測試函式"><a href="#Case-2-改變深度測試函式" class="headerlink" title="Case 2. 改變深度測試函式"></a>Case 2. 改變深度測試函式</h4><ol>
<li>紅色平面的 <code>depthFunc</code> 改為 <code>GreaterEqualDepth</code> &#x3D;&gt; 紅色平面沒有被畫上去<br>當繪製紅色平面時，由於紅色平面的位置在 <strong>遠平面(far plane)</strong> 之內，代表其 <strong>像素(fragment)</strong> 的深度值都小於 1，而改成 <code>GreaterEqualDepth</code> 後，代表深度值需要大於原有 <strong>深度緩衝區</strong> 的深度值，深度測試才會成功，但預設 <strong>深度緩衝區</strong> 中的深度值為 1.0，因此紅色平面的深度測試失敗，最終不會繪製出來</li>
</ol>
<img src="./depth-func-red-greater.png" style="width: 50%" />

<ol start="2">
<li>藍色平面的 <code>depthFunc</code> 改為 <code>GreaterEqualDepth</code> &#x3D;&gt; 藍色平面被畫上去<br>跟上面的原因一樣，原本藍色平面的位置就在紅色平面之後，藍色平面的深度值都比紅色平面大，當 <code>depthFunc</code> 改為 <code>GreaterEqualDepth</code> 後，藍色平面的深度測試就都通過了，因此藍色平面被繪製出來</li>
</ol>
<img src="./depth-func-blue-greater.png" style="width: 50%" />

<h4 id="Case-3-改變是否寫入深度緩衝區"><a href="#Case-3-改變是否寫入深度緩衝區" class="headerlink" title="Case 3. 改變是否寫入深度緩衝區"></a>Case 3. 改變是否寫入深度緩衝區</h4><ol>
<li>紅色平面的 <code>depthWrite</code> 改為 <code>false</code> &#x3D;&gt; 藍色平面被畫上去<br>因為紅色平面 <strong>像素(fragment)</strong> 其深度值並沒有被寫入 <strong>深度緩衝區</strong>，所以當繪製藍色平面時，藍色平面的 <strong>像素(fragment)</strong> 都是與 <strong>深度緩衝區</strong> 中預設的 1.0 比較，也就通過深度測試被繪製出來了</li>
</ol>
<img src="./depth-write-red-disabled.png" style="width: 50%" />

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/01%20Depth%20testing/">深度测试</a></p>


<style>
table {
  th, td {
   padding: 8px 12px;
  } 
}
</style>


]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (2) - 左手/右手座標系與齊次座標</title>
    <url>/blog/2025/02/28/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-2-%E5%B7%A6%E6%89%8B-%E5%8F%B3%E6%89%8B%E5%BA%A7%E6%A8%99%E7%B3%BB%E8%88%87%E9%BD%8A%E6%AC%A1%E5%BA%A7%E6%A8%99/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-2-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-2-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 2 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 2 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇系列文中，我們了解深度測試中不同 <strong>像素(fragment)</strong> 是如何藉由比較各自的深度值來決定誰會渲染在畫面上，接著我們將討論深度值在數學上是如何計算出來的，但在那之前需要一些必備的知識幫助我們理解後續的數學推導，所以第二篇的系列文我們來學習這部分 - 左手&#x2F;右手座標系、齊次座標</p>
<span id="more"></span>

<h2 id="左手-右手座標系"><a href="#左手-右手座標系" class="headerlink" title="左手&#x2F;右手座標系"></a>左手&#x2F;右手座標系</h2><p>3D 圖學中的左手&#x2F;右手座標系統代表了 $ x, y, z $ 軸指向的定義</p>
<ul>
<li>左手座標系</li>
</ul>
<ol>
<li>伸出左手使正 y 軸沿著手往上</li>
<li>使大拇指向右邊</li>
<li>讓食指指向上方</li>
<li>向下 90 度彎曲中指</li>
</ol>
<p>&#x3D;&gt; 此時大拇指指向正 x 軸方向、食指朝向正 y 軸方向、中指朝向正 z 軸方向，如下左圖所示</p>
<ul>
<li>右手座標系</li>
</ul>
<ol>
<li>伸出右手使正 y 軸沿著手往上</li>
<li>使大拇指向右邊</li>
<li>讓食指指向上方</li>
<li>向下 90 度彎曲中指</li>
</ol>
<p>&#x3D;&gt; 此時大拇指指向正 x 軸方向、食指朝向正 y 軸方向、中指朝向正 z 軸方向，如下右圖所示</p>
<p>左&#x2F;右手座標系可以幫助我們之後在不同座標系統進行正確的數值轉換，事實上左&#x2F;手座標軸的數學轉換很簡單就只是將 <strong>+z</strong> 的座標數值變成 <strong>-z</strong></p>
<img src="https://perry.cz/articles/0C__Martin_Programing_OpenGL-ES_Tutorials_left_right_hand.gif" width="50%" height="50%" >

<p><a href="https://perry.cz/articles/ProjectionMatrix.xhtml">圖片來源</a></p>
<p>由於 <strong>Three.js</strong> 的底層 <strong>OpenGL</strong> 採用的是右手座標系，所以使用 <a href="https://threejs.org/docs/#api/en/helpers/AxesHelper">AxesHelper</a> 時，可以看到 <strong>+z</strong> 軸(藍色的線)指向面對我們的方向 (藍色的線可能太細，放大圖片比較好看到)</p>
<img src="./threejs-coordinate.png" width="50%" height="50%" >
 
<hr>
<h2 id="齊次座標-Homogeneous-coordinates"><a href="#齊次座標-Homogeneous-coordinates" class="headerlink" title="齊次座標 (Homogeneous coordinates)"></a>齊次座標 (Homogeneous coordinates)</h2><p>一開始聽到 <strong>齊次座標</strong> 這個專有名詞時，真的不懂他是個什麼樣的東西，後來經過一陣子的研究後，我發現 <strong>齊次座標</strong> 一言以蔽之就是 <strong>一種用 N + 1 個位數表示 N 維座標的技巧</strong>，如何理解 <strong>齊次座標</strong> 代表的意義呢？我覺得從實際應用的場景來看就可以體會到他厲害的地方，<strong>齊次座標</strong> 在 3D 圖學中主要應用於兩點，第一點是 <strong>矩陣變換 (Matrix transformations)</strong> ，第二點是 <strong>透視變換 (Perspective transformation)</strong></p>
<h3 id="1-矩陣變換-Matrix-transformations"><a href="#1-矩陣變換-Matrix-transformations" class="headerlink" title="1. 矩陣變換 (Matrix transformations)"></a>1. 矩陣變換 (Matrix transformations)</h3><p>假設在 3D 空間中有個點 $ P $ 其座標以 $ (x, y, z) $ 表示，我們希望對這個點進行座標轉換，像是平移、縮放、旋轉等，雖然 $ P $ 點是一個三維的座標，但數學家發現如果將這個三維座標以四維表示，而平移、縮放、旋轉這些行為也用一個 4x4 的矩陣來表示，座標轉換都可以用矩陣來表示，這裡我們將原本三維空間中的點 $ P $ 轉換成四維座標：</p>


$$
P = \begin{bmatrix} x \\ y \\ z \end{bmatrix} \quad => \quad P = \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}
$$



<h4 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移 (Translation)"></a>平移 (Translation)</h4><p>假設我們想要將 $ P $ 點加上一個平移的向量 $ (\color{red}{T_x}, \color{green}{T_y}, \color{blue}{T_z} \textcolor{black}{)} $，新的向量  $ P' = (x + \color{red}{T_x} \color{black}{,} \;\; y + \color{green}{T_y} \color{black}{,} \;\; z + \color{blue}{T_z} \textcolor{black}{)} $ ，我們可以用一個簡單的 4x4 平移矩陣乘以四維的 $ P $ 點求得平移後的座標</p>


$$
\begin{bmatrix}
\color{red}{1} & \color{red}{0} & \color{red}{0} & \color{red}{T_x} \\
\color{green}{0} & \color{green}{1} & \color{green}{0} & \color{green}{T_y} \\
\color{blue}{0} & \color{blue}{0} & \color{blue}{1} & \color{blue}{T_z} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix} \cdot
\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} =
\begin{bmatrix} x+\color{red}{T_x} \\ y+\color{green}{T_y} \\ z+\color{blue}{T_z} \\ 1 \end{bmatrix}
$$



<h4 id="縮放-Scaling"><a href="#縮放-Scaling" class="headerlink" title="縮放 (Scaling)"></a>縮放 (Scaling)</h4><p>接著我們打算將 $ P $ 點進行縮放 $ (\color{red}{S_x}, \color{green}{S_y}, \color{blue}{S_z} \textcolor{black}{)} $，新的向量  $ P' = (\color{red}{S_x} \color{black} \cdot {x,} \;\; \color{green}{S_y} \color{black} \cdot {y,} \;\; \color{blue}{S_z} \color{black} \cdot {z}\textcolor{black}{)} $ ，一樣我們可以套用以下縮放矩陣求得 $ P $ 點縮放後的座標</p>


$$
\begin{bmatrix}
\color{red}{S_x} & \color{red}{0} & \color{red}{0} & \color{red}{0} \\
\color{green}{0} & \color{green}{S_y} & \color{green}{0} & \color{green}{0} \\
\color{blue}{0} & \color{blue}{0} & \color{blue}{S_z} & \color{blue}{0} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix} \cdot
\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} =
\begin{bmatrix} \color{red}{S_x} \color{black} \cdot x \\ \color{green}{S_y} \color{black} \cdot y  \\ \color{blue}{S_z} \color{black} \cdot z  \\ 1 \end{bmatrix}
$$



<h4 id="旋轉-Rotation"><a href="#旋轉-Rotation" class="headerlink" title="旋轉 (Rotation)"></a>旋轉 (Rotation)</h4><p>最後我們來探討是旋轉矩陣，旋轉矩陣不像平移及縮放矩陣一樣可以直覺的了解，中間牽涉一些座標軸轉換的數學推導，這裡我們跳過複雜的<a href="https://www.cnblogs.com/MetaWang/p/10094784.html">推導過程</a>，只留下最後的結果</p>
<p>沿 <strong>y</strong> 軸旋轉的旋轉矩陣長這樣：</p>


$$
\begin{bmatrix}
\color{red}{\cos\theta} & \color{red}{0} & \color{red}{\sin\theta} & \color{red}{0} \\
\color{green}{0} & \color{green}{1} & \color{green}{0} & \color{green}{0} \\
\color{blue}{-\sin\theta} & \color{blue}{0} & \color{blue}{\cos\theta} & \color{blue}{0} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix}
\cdot
\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}
=
\begin{bmatrix}
\color{red}{\cos\theta} \color{black} \cdot x + \color{red}{\sin\theta} \color{black} \cdot z \\
y \\
\color{blue}{-\sin\theta} \color{black} \cdot x + \color{blue}{\cos\theta} \color{black} \cdot z \\
1
\end{bmatrix}
$$



<h4 id="矩陣的組合"><a href="#矩陣的組合" class="headerlink" title="矩陣的組合"></a>矩陣的組合</h4><p>最後我們嘗試混合平移、縮放及旋轉矩陣，希望將原本的點 $ P (1, 1, 1) $ 座標</p>
<ol>
<li>沿著 <strong>y</strong> 軸旋轉 $ 180^\circ (\pi) $</li>
<li>將長度放大為兩倍</li>
<li>平移座標 $ (1, 0, 0) $</li>
</ol>
<br />

<ol>
<li>點 $ P (1, 1, 1) $，沿著 <strong>y</strong> 軸旋轉 $ 180^\circ &#x3D;&gt; P’ (-1, 1, 1) $</li>
</ol>


$$
\begin{bmatrix}
\color{red}{\cos\pi} & \color{red}{0} & \color{red}{\sin\pi} & \color{red}{0} \\
\color{green}{0} & \color{green}{1} & \color{green}{0} & \color{green}{0} \\
\color{blue}{-\sin\pi} & \color{blue}{0} & \color{blue}{\cos\pi} & \color{blue}{0} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix}
\cdot
\begin{bmatrix}
1 \\ 1 \\ 1 \\ 1
\end{bmatrix}
=
\begin{bmatrix}
\color{red}{-1} \color{black} \cdot 1 + \color{red}{0} \color{black} \cdot 1 \\
1 \\
\color{blue}{-0} \color{black} \cdot 1 + \color{blue}{1} \color{black} \cdot 1 \\
1
\end{bmatrix}
=
\begin{bmatrix}
-1 \\
1 \\
1 \\
1
\end{bmatrix}
$$



<div style="display: flex; justify-content: center;">
  <img src="./rotate-180.png" width="75%" height="75%" >
</div>

<ol start="2">
<li>點 $ P (-1, 1, 1) $，將長度放大為兩倍 $ &#x3D;&gt; P’ (-2, 2, 2) $</li>
</ol>


$$
\begin{bmatrix}
\color{red}{2} & \color{red}{0} & \color{red}{0} & \color{red}{0} \\
\color{green}{0} & \color{green}{2} & \color{green}{0} & \color{green}{0} \\
\color{blue}{0} & \color{blue}{0} & \color{blue}{2} & \color{blue}{0} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix} \cdot
\begin{bmatrix} -1 \\ 1 \\ 1 \\ 1 \end{bmatrix} =
\begin{bmatrix} -2 \\ 2  \\ 2 \\ 1 \end{bmatrix}
$$



<div style="display: flex; justify-content: center;">
  <img src="./scale-2.png" width="75%" height="75%" >
</div>

<ol start="3">
<li>點 $ P (-2, 2, 2) $，平移座標 $ (1, 0, 0) &#x3D;&gt; P’ (-1, 2, 2) $</li>
</ol>


$$
\begin{bmatrix}
\color{red}{1} & \color{red}{0} & \color{red}{0} & \color{red}{1} \\
\color{green}{0} & \color{green}{1} & \color{green}{0} & \color{green}{0} \\
\color{blue}{0} & \color{blue}{0} & \color{blue}{1} & \color{blue}{0} \\
\color{purple}{0} & \color{purple}{0} & \color{purple}{0} & \color{purple}{1}
\end{bmatrix} \cdot
\begin{bmatrix} -2 \\ 2 \\ 2 \\ 1 \end{bmatrix} =
\begin{bmatrix} -1 \\ 2 \\ 2 \\ 1 \end{bmatrix}
$$



<div style="display: flex; justify-content: center;">
  <img src="./transition.png" width="75%" height="75%" >
</div>

<p>最後我們可以理解 <strong>齊次座標</strong> 在 <strong>矩陣變換</strong> 中的重要性了，單純只是將三維座標 $ (x, y, z) $ 添加一個額外的維度變成四維座標 $ (x, y, z, 1) $ 後，平移、縮放、旋轉這些複雜的座標轉換都可以輕鬆的用矩陣乘法來解決</p>
<h3 id="2-透視變換-Perspective-transformation"><a href="#2-透視變換-Perspective-transformation" class="headerlink" title="2. 透視變換 (Perspective transformation)"></a>2. 透視變換 (Perspective transformation)</h3><p><strong>透視 (perspective)</strong> 指的是物體離相機越遠會變得越小的狀況，這跟人眼看到的狀況相符，<strong>Three.js</strong> 中用 <a href="https://threejs.org/docs/#api/en/cameras/PerspectiveCamera">PerspectiveCamera</a> 來代表這種行為，下圖我們可以看到鐵軌兩側的軌道是平行的，但當軌道延伸到無限遠處時，人眼看起來就會匯聚於一點</p>
<div style="display: flex; justify-content: center;">
  <img src="https://learnopengl.com/img/getting-started/perspective.png" width="35%" height="35%" >
  <a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/08%20Coordinate%20Systems/"
    style="align-self: flex-end;">
  圖片來源
  </a>
</div>

<h4 id="如何讓兩條平行線相交"><a href="#如何讓兩條平行線相交" class="headerlink" title="如何讓兩條平行線相交"></a>如何讓兩條平行線相交</h4><p>從小就有學過一般的 <strong>歐幾里得空間(Euclidean space)</strong> 可以用以下方程式表示兩條平行線：</p>


$

\left\{
\begin{array}{l}
Ax + By + C = 0 \\
Ax + By + D = 0
\end{array}
\right.

$



<br />
<br />

<p>由於是兩條不同的平行線，$ C $ 與 $ D $ 的值不同，這種情況下不論 $ x, y $ 的值是多少都無法使等式成立，也代表兩條平行線是不會有交點的</p>
<p>但以下我們套用 <strong>齊次座標</strong> 的概念來重寫以上兩條等式，將原本的 $ x, y $ 分別替換成 $ \displaystyle \frac{x}{w}, \frac{y}{w} $</p>


$

\left\{
\begin{array}{l}
\displaystyle
\frac{A x}{w} + \frac{B y}{w} + C = 0 \\
\displaystyle
\frac{A x}{w} + \frac{B y}{w} + D = 0
\end{array}
\right.
\quad \Rightarrow \quad
\left\{
\begin{array}{l}
Ax + By + Cw = 0 \\
Ax + By + Dw = 0
\end{array}
\right.
\quad \Rightarrow \quad
Cw - Dw = 0
\quad \Rightarrow \quad
(C-D)w = 0
$



<br />
<br />

<p>此時我們獲得一個解當 $ w &#x3D; 0 $ 可以使等式成立，也就是轉換過後的 $ \displaystyle x’ &#x3D; \frac{x}{w} &#x3D; \frac{x}{0} &#x3D; \infty $<br>這意味著兩條平行線會在 $ (x, y, 0) $ 處相交，而這相交點處位在無窮遠的地方</p>
<h3 id="齊次座標的-w-分量"><a href="#齊次座標的-w-分量" class="headerlink" title="齊次座標的 w 分量"></a>齊次座標的 w 分量</h3><p>我們可以將一個二維的座標 $ (x, y) $ 表示成 <strong>齊次座標</strong> $ (x, y, w) $，反過來也可以將 <strong>齊次座標</strong> $ (x, y, w) $ 轉換回二維的座標 $ \displaystyle (\frac{x}{w}, \frac{y}{w}) $</p>
<p>當 $ w &#x3D; 0 $ 的時候，轉換回二維座標 $ x, y $ 會變成無窮大，此時 $ (x, y) $ 座標代表的不是點，而是一條延伸到無窮遠處的向量，這就是上面 <a href="./#2-透視變換-Perspective-transformation">透視變換</a> 提到鐵軌兩側的平行線</p>
<p>當 $ w &gt; 0 $ 的時候，是上面 <a href="./#1-矩陣變換-Matrix-transformations">矩陣變換</a> 的狀況，<strong>齊次座標</strong> $ (1, 1, 1, 1) $ 轉換為三維座標為 $ (1, 1, 1) $ 代表的是三維空間中的點，由於轉換回三維座標是除以 $ w $ 分量，所以其實以下的 <strong>齊次座標</strong> 代表的都對應到三維空間中的同一個點 $ (1, 1, 1) $</p>


$

\begin{array}{l}
(1, 1, 1, 1) \\
(2, 2, 2, 2) \\
(3, 3, 3, 3) \\
... \\
... \\
(n, n, n, n)
\end{array}

$



<br />
<br />

<p>這就是 <strong>齊次 (Homogeneous)</strong> 所代表的意義，n + 1 維空間中 <strong>齊次座標</strong> 中的許多點其實都對應到 n 維空間中的同一個點</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/07%20Transformations/">变换</a><br><a href="https://www.songho.ca/math/homogeneous/homogeneous.html">Homogeneous Coordinates</a><br><a href="https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">Explaining Homogeneous Coordinates &amp; Projective Geometry</a><br><a href="https://juejin.cn/post/7246334166950527034">一看就懂的OpenGL ES教程——走进3D的世界之坐标系统（下篇）</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>理解 Three.js 的 shader 架構</title>
    <url>/blog/2025/02/08/%E7%90%86%E8%A7%A3-three-js-%E7%9A%84-shader-%E6%9E%B6%E6%A7%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>繼上一篇 <a href="https://bcjohnblue.github.io/blog/2024/12/06/%E4%BD%BF%E7%94%A8-three-js-%E6%93%8D%E4%BD%9C-shader-%E7%95%AB%E5%87%BA%E5%9C%8B%E6%97%97/">使用 Three.js 操作 shader 畫出國旗</a> 後，這一篇文章希望了解 Three.js 裡的 shader 架構</p>
<h2 id="WebGL-裡的-shader-綁定"><a href="#WebGL-裡的-shader-綁定" class="headerlink" title="WebGL 裡的 shader 綁定"></a>WebGL 裡的 shader 綁定</h2><p>因為 Three.js 的底層就是 WebGL 所以我們可以先從 WebGL 是如何綁定 shader 來找到 Three.js 中處理 shader 的起始點</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WebGL 綁定 shader 部分片段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;webgl&#x27;</span>); <span class="comment">// WebGL 1.0</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;webgl2&#x27;</span>); <span class="comment">// WebGL 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 創建 shader</span></span><br><span class="line"><span class="keyword">const</span> vertexShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">VERTEX_SHADER</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 撰寫 shader code</span></span><br><span class="line"><span class="keyword">const</span> vertexShaderSource = <span class="string">`</span></span><br><span class="line"><span class="string">    attribute vec4 aPosition;</span></span><br><span class="line"><span class="string">    void main() &#123;</span></span><br><span class="line"><span class="string">        gl_Position = aPosition;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">gl.<span class="title function_">shaderSource</span>(vertexShader, vertexShaderSource);</span><br><span class="line"></span><br><span class="line">gl.<span class="title function_">compileShader</span>(vertexShader); <span class="comment">// 3. 編譯 shader</span></span><br><span class="line"><span class="keyword">const</span> shaderProgram = gl.<span class="title function_">createProgram</span>(); <span class="comment">// 4. 創建 program</span></span><br><span class="line">gl.<span class="title function_">attachShader</span>(shaderProgram, vertexShader); <span class="comment">// 5. 附加 shader 到 program</span></span><br><span class="line">gl.<span class="title function_">linkProgram</span>(shaderProgram); <span class="comment">// 6. 連接 program</span></span><br><span class="line">gl.<span class="title function_">useProgram</span>(shaderProgram); <span class="comment">// 7. 使用 program</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在 Three.js 的原始碼裡面也可以看到類似的邏輯，利用 <code>WebGLShader</code> 這個函式將寫好的 shader 以 <code>string</code> 的變數名稱傳入 <code>gl.shaderSource</code>，接著就是往上找看什麼地方用到 <code>WebGLShader</code> 並且找到傳入的 <code>string</code> 是什麼</p>
<p><a href="https://github.com/mrdoob/three.js/blob/426c39aa0ea42d4612dcc3fd9e20862af6413a30/src/renderers/webgl/WebGLShader.js">WebGLShader.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WebGLShader</span>(<span class="params">gl, type, string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shader = gl.<span class="title function_">createShader</span>(type);</span><br><span class="line"></span><br><span class="line">  gl.<span class="title function_">shaderSource</span>(shader, string);</span><br><span class="line">  gl.<span class="title function_">compileShader</span>(shader);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">WebGLShader</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Three-js-裡預定義的-shaders"><a href="#Three-js-裡預定義的-shaders" class="headerlink" title="Three.js 裡預定義的 shaders"></a>Three.js 裡預定義的 shaders</h2><p>接著可以找到在 <code>WebGLProgram.js</code> 這個檔案裡使用了 <code>WebGLShader</code> 函式，會發現傳入 <code>WebGLShader</code> 函式的 <code>string</code> 實際上是三個變數加起來的字串，因為 <code>vertexGlsl</code> 跟 <code>fragmentGlsl</code> 字串連接的邏輯看起來是類似的，下面我們就只繼續往下看 <code>vertexGlsl</code> 中的 <code>versionString</code>, <code>prefixVertex</code> 跟 <code>vertexShader</code> 這三個變數是什麼東西</p>
<p><a href="https://github.com/mrdoob/three.js/blob/426c39aa0ea42d4612dcc3fd9e20862af6413a30/src/renderers/webgl/WebGLProgram.js#L895">WebGLProgram.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vertexGlsl = versionString + prefixVertex + vertexShader;</span><br><span class="line"><span class="keyword">const</span> fragmentGlsl = versionString + prefixFragment + fragmentShader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glVertexShader = <span class="title class_">WebGLShader</span>(gl, gl.<span class="property">VERTEX_SHADER</span>, vertexGlsl);</span><br><span class="line"><span class="keyword">const</span> glFragmentShader = <span class="title class_">WebGLShader</span>(gl, gl.<span class="property">FRAGMENT_SHADER</span>, fragmentGlsl);</span><br><span class="line"></span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, glVertexShader);</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, glFragmentShader);</span><br></pre></td></tr></table></figure>

<h3 id="versionString">1. versionString</h3>

<p><code>versionString</code> 標記使用的 <strong>glsl</strong> 版本，<a href="https://threejs.org/docs/#api/en/materials/ShaderMaterial.glslVersion">parameters.glslVersion</a> 是可以藉由 <strong>ShaderMaterial</strong> 傳入的其中一個參數</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> versionString = parameters.<span class="property">glslVersion</span></span><br><span class="line">  ? <span class="string">&#x27;#version &#x27;</span> + parameters.<span class="property">glslVersion</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  : <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="prefixVertex">2. prefixVertex</h3>

<p><code>prefixVertex</code> 會隨著 <code>parameters.isRawShaderMaterial</code> 的有無，串接不同的字串</p>
<p>首先來看 <code>parameters.isRawShaderMaterial = true</code> 的狀況，這裡定義了兩個 shader 變數 <code>SHADER_TYPE</code> 跟 <code>SHADER_NAME</code> 分別是從 <strong>material</strong> 來的 <a href="https://threejs.org/docs/?q=material#api/en/materials/Material.type">type</a> 跟 <a href="https://threejs.org/docs/?q=material#api/en/materials/Material.name">name</a>，而 <a href="https://threejs.org/docs/#api/en/materials/ShaderMaterial.defines">parameters.defines</a> 則是 <code>ShaderMaterial</code> 中傳進來自定義的數值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defines = parameters.<span class="property">defines</span>;</span><br><span class="line"><span class="keyword">const</span> customDefines = <span class="title function_">generateDefines</span>(defines);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parameters.<span class="property">isRawShaderMaterial</span>) &#123;</span><br><span class="line">  prefixVertex = [</span><br><span class="line">    <span class="string">&#x27;#define SHADER_TYPE &#x27;</span> + parameters.<span class="property">shaderType</span>,</span><br><span class="line">    <span class="string">&#x27;#define SHADER_NAME &#x27;</span> + parameters.<span class="property">shaderName</span>,</span><br><span class="line"></span><br><span class="line">    customDefines</span><br><span class="line">  ]</span><br><span class="line">    .<span class="title function_">filter</span>(filterEmptyLine)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prefixVertex.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    prefixVertex += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而另一個狀況是 <code>parameters.isRawShaderMaterial = false</code>，可以看到相比上面這邊定義了很多 <code>#define</code> 開頭的數值，全部大約有一兩百多個吧，因為太多的關係所以下面的程式碼只節錄了前面的幾個</p>
<p>目前為止會發現在 <code>isRawShaderMaterial = false</code> 的狀況下，Three.js 偷偷在 shader 程式碼的開頭塞了很多東西，這也是前一篇文章提出的疑問 - <a href="https://bcjohnblue.github.io/blog/2024/12/06/%E4%BD%BF%E7%94%A8-three-js-%E6%93%8D%E4%BD%9C-shader-%E7%95%AB%E5%87%BA%E5%9C%8B%E6%97%97/#:~:text=THREE.RawShaderMaterial%20%E8%88%87%20THREE.ShaderMaterial%20%E7%9A%84%E5%B7%AE%E5%88%A5">THREE.RawShaderMaterial 與 THREE.ShaderMaterial 的差別</a> ，當使用 <a href="https://threejs.org/docs/#api/en/materials/RawShaderMaterial">RawShaderMaterial</a> 時 <code>isRawShaderMaterial</code> 會設成 <code>true</code>，前面就不會偷塞一堆 <code>#define</code> 的東西，但當使用 <a href="https://threejs.org/docs/#api/en/materials/ShaderMaterial">ShaderMaterial</a> 時 Three.js 偷塞入的東西就是下面這一堆</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prefixVertex = [</span><br><span class="line">  <span class="title function_">generatePrecision</span>(parameters),</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;#define SHADER_TYPE &#x27;</span> + parameters.<span class="property">shaderType</span>,</span><br><span class="line">  <span class="string">&#x27;#define SHADER_NAME &#x27;</span> + parameters.<span class="property">shaderName</span>,</span><br><span class="line"></span><br><span class="line">  customDefines,</span><br><span class="line"></span><br><span class="line">  parameters.<span class="property">extensionClipCullDistance</span> ? <span class="string">&#x27;#define USE_CLIP_DISTANCE&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">batching</span> ? <span class="string">&#x27;#define USE_BATCHING&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">batchingColor</span> ? <span class="string">&#x27;#define USE_BATCHING_COLOR&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">instancing</span> ? <span class="string">&#x27;#define USE_INSTANCING&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">instancingColor</span> ? <span class="string">&#x27;#define USE_INSTANCING_COLOR&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">instancingMorph</span> ? <span class="string">&#x27;#define USE_INSTANCING_MORPH&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  parameters.<span class="property">useFog</span> &amp;&amp; parameters.<span class="property">fog</span> ? <span class="string">&#x27;#define USE_FOG&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">useFog</span> &amp;&amp; parameters.<span class="property">fogExp2</span> ? <span class="string">&#x27;#define FOG_EXP2&#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下略 ...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>接著讓我們來看看 Three.js 偷塞的這一堆東西會有什麼樣的影響，我們先找一個比較簡單的例子看起 <code>parameters.useFog &amp;&amp; parameters.fog ? &#39;#define USE_FOG&#39; : &#39;&#39;,</code> 這一行看起來就是開啟霧氣效果的特效，而當我們搜尋 <code>USE_FOG</code> 這個關鍵字的時候發現有四個檔案分別都用到了這個變數 - <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_fragment.glsl.js">fog_fragment.glsl.js</a>, <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js">fog_pars_fragment.glsl.js</a>, <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js">fog_pars_vertex.glsl.js</a>, <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_vertex.glsl.js">fog_vertex.glsl.js</a>，而且這四個檔案都放在 <code>src/renderers/shaders/ShaderChunk</code> 的這個資料夾底下，看來 <code>ShaderChunk</code> 資料夾下放的就是專門處理 three.js 預定義的這些 shader 邏輯，但到底 <code>ShaderChunk</code> 資料夾底下的這些 shader 檔案是怎麼實際套用到 shader 裡的呢？</p>
<p>讓我們先往下看 <code>vertexGlsl</code> 變數中串接的第三個 <code>vertexShader</code> 字串是從哪裡來的後，再回頭總結講這些 <code>ShaderChunk</code> 資料夾底下的 shader 們會比較全面</p>
<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_fragment.glsl.js">fog_fragment.glsl.js</a> - 看起來就是處理 fog 的相關 shader 程式碼</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#ifdef USE_FOG</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #ifdef FOG_EXP2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #else</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="glsl-的版本程式碼轉換"><a href="#glsl-的版本程式碼轉換" class="headerlink" title="glsl 的版本程式碼轉換"></a>glsl 的版本程式碼轉換</h3><p>另外這邊額外想講的是 <code>prefixVertex</code> 這個變數最後還做了一個 glsl 的版本程式碼轉換，看起來是把舊版本的一些關鍵字轉成新版本的 (例如：<code>attribute</code> 變成 <code>in</code>)，這邊這樣寫看起來是使用非 <code>RawShaderMaterial</code> 的 <code>Material</code> 時，一律都認為瀏覽器可以支援 WebGL 2.0，所以 shader 的關鍵字可以轉換為 <code>in</code>, <code>out</code> 這些 glsl 較新的文法</p>
<p>推測是因為 WebGL 2.0 2016 年就推出了，現在瀏覽器的支援率也達到 <a href="https://caniuse.com/webgl2">96% 以上</a>，所以預設的 <code>Material</code> 都直接使用 WebGL 2.0 文法就好，而需要兼容舊 glsl (WebGL 1.0) 的人就需要使用 <code>RawShaderMaterial</code> 撰寫自己的 shader 並設定 <a href="https://threejs.org/docs/#api/en/materials/ShaderMaterial.glslVersion">glslVersion</a></p>
<p>關於 glsl 程式碼關鍵字新舊版本的差異，請看 <a href="https://shaderfans.com/post/ban-ben-shu-li/index.html">OpenGL ES 与 GLSL ES 版本的对应关系</a> 及 <a href="https://www.cnblogs.com/George1994/p/6418013.html">OpenGL 和 GLSL 版本更迭</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameters.<span class="property">isRawShaderMaterial</span> !== <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// GLSL 3.0 conversion for built-in materials and ShaderMaterial</span></span><br><span class="line"></span><br><span class="line">  versionString = <span class="string">&#x27;#version 300 es\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  prefixVertex =</span><br><span class="line">    [</span><br><span class="line">      customVertexExtensions,</span><br><span class="line">      <span class="string">&#x27;#define attribute in&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;#define varying out&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;#define texture2D texture&#x27;</span></span><br><span class="line">    ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>) +</span><br><span class="line">    <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    prefixVertex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vertexShader">3. vertexShader</h3>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vertexShader = parameters.<span class="property">vertexShader</span>;</span><br><span class="line"></span><br><span class="line">vertexShader = <span class="title function_">resolveIncludes</span>(vertexShader);</span><br><span class="line">vertexShader = <span class="title function_">replaceLightNums</span>(vertexShader, parameters);</span><br><span class="line">vertexShader = <span class="title function_">replaceClippingPlaneNums</span>(vertexShader, parameters);</span><br><span class="line"></span><br><span class="line">vertexShader = <span class="title function_">unrollLoops</span>(vertexShader);</span><br></pre></td></tr></table></figure>

<p>來到最後 <code>vertexShader</code> 的部分了，首先這裡最重要的函式是 <code>resolveIncludes</code>，這會講的比較冗長，所以我們先把其他三個函式看完後再回頭來看 <code>resolveIncludes</code> 的作用</p>
<p><code>replaceLightNums</code>, <code>replaceClippingPlaneNums</code> 及 <code>unrollLoops</code> 這三個函式其實做的事情都類似，把接進來 <code>vertexShader</code> 的特定字串替換成 <code>parameters</code> 裡的數值就這樣，以下只節錄 <code>replaceLightNums</code> 函式部分讓大家有點感覺</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceLightNums</span>(<span class="params">string, parameters</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numSpotLightCoords =</span><br><span class="line">    parameters.<span class="property">numSpotLightShadows</span> +</span><br><span class="line">    parameters.<span class="property">numSpotLightMaps</span> -</span><br><span class="line">    parameters.<span class="property">numSpotLightShadowsWithMaps</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> string</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/NUM_DIR_LIGHTS/g</span>, parameters.<span class="property">numDirLights</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/NUM_SPOT_LIGHTS/g</span>, parameters.<span class="property">numSpotLights</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/NUM_SPOT_LIGHT_MAPS/g</span>, parameters.<span class="property">numSpotLightMaps</span>);</span><br><span class="line">  <span class="comment">// ... 下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著的 <code>resolveIncludes</code> 就是一切關鍵的鑰匙了，這個函式串連了我們上面所有講的部分，以及也解釋了 Three.js 這些預定義的 <code>#define</code> 字串是如何變成實際的 shader 程式碼而做出類似霧氣這些效果的，其實 <code>resolveIncludes</code> 做的事情意外的簡單，實際上就是在傳進來的 <code>vertexShader</code> 這一長串的字串中，找到 <code>#include</code> 開頭的字串，並替換成 <code>ShaderChunk</code> 資料夾底下各檔案實際撰寫的 shader 程式碼</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resolve Includes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> includePattern = <span class="regexp">/^[ \t]*#include +&lt;([\w\d./]+)&gt;/gm</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveIncludes</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> string.<span class="title function_">replace</span>(includePattern, includeReplacer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shaderChunkMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">includeReplacer</span>(<span class="params">match, include</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="title class_">ShaderChunk</span>[include];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (string === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newInclude = shaderChunkMap.<span class="title function_">get</span>(include);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newInclude !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      string = <span class="title class_">ShaderChunk</span>[newInclude];</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;THREE.WebGLRenderer: Shader chunk &quot;%s&quot; has been deprecated. Use &quot;%s&quot; instead.&#x27;</span>,</span><br><span class="line">        include,</span><br><span class="line">        newInclude</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Can not resolve #include &lt;&#x27;</span> + include + <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolveIncludes</span>(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這麼講好像還是有點模糊，讓我們舉一個實際的例子就會很簡單了，我們以 <a href="https://threejs.org/docs/?q=basic#api/en/materials/MeshBasicMaterial">MeshBasicMaterial</a> 當作範例解釋：</p>
<p>在 <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLPrograms.js">WebGLPrograms.js</a> 裡，注意！這個檔案是 <strong>“s”</strong> 結尾的，跟上面最一開始提到的 <code>WebGLProgram.js</code> 檔案是處理完全不一樣的東西，在 <code>WebGLPrograms.js</code> 這個檔案裡會根據不同的 <code>Material</code> 種類產出 <code>parameter.vertexShader</code> 而這個 <code>parameter.vertexShader</code> 變數會傳到 <code>WebGLProgram.js</code> 去，對應到的就是一開始提到的 <code>vertexGlsl</code> 變數中的第三個變數 <code>vertexShader</code></p>
<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLPrograms.js">WebGLPrograms.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ShaderLib</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../shaders/ShaderLib.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shaderIDs = &#123;</span><br><span class="line">  <span class="title class_">MeshBasicMaterial</span>: <span class="string">&#x27;basic&#x27;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getParameters</span>(<span class="params">material, lights, shadows, scene, object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shaderID = shaderIDs[material.<span class="property">type</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shaderID) &#123;</span><br><span class="line">    <span class="keyword">const</span> shader = <span class="title class_">ShaderLib</span>[shaderID];</span><br><span class="line"></span><br><span class="line">    vertexShader = shader.<span class="property">vertexShader</span>;</span><br><span class="line">    fragmentShader = shader.<span class="property">fragmentShader</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parameters = &#123;</span><br><span class="line">    vertexShader,</span><br><span class="line">    fragmentShader</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib.js">ShaderLib.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ShaderChunk</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./ShaderChunk.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ShaderLib</span> = &#123;</span><br><span class="line">  <span class="attr">basic</span>: &#123;</span><br><span class="line">    <span class="attr">uniforms</span>: <span class="comment">/*@__PURE__*/</span> <span class="title function_">mergeUniforms</span>([</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">common</span>,</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">specularmap</span>,</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">envmap</span>,</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">aomap</span>,</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">lightmap</span>,</span><br><span class="line">      <span class="title class_">UniformsLib</span>.<span class="property">fog</span></span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    <span class="attr">vertexShader</span>: <span class="title class_">ShaderChunk</span>.<span class="property">meshbasic_vert</span>,</span><br><span class="line">    <span class="attr">fragmentShader</span>: <span class="title class_">ShaderChunk</span>.<span class="property">meshbasic_frag</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk.js">ShaderChunk.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> meshbasic <span class="keyword">from</span> <span class="string">&#x27;./ShaderLib/meshbasic.glsl.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ShaderChunk</span> = &#123;</span><br><span class="line">  <span class="attr">meshbasic_vert</span>: meshbasic.<span class="property">vertex</span>,</span><br><span class="line">  <span class="attr">meshbasic_frag</span>: meshbasic.<span class="property">fragment</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有 Three.js 定義的 <code>Material</code> 都有自己的一個 shader 模板，為什麼我稱它叫做 shader 模板呢？因為它有一堆字串，並且這些字串包含著許多 <code>#include ...</code> 的關鍵字，每一行的 <code>#include ...</code> 之後都會被替換成可以實際執行 shader 的程式碼，以 <code>MeshBasicMaterial</code> 來說在 <code>WebGLPrograms.js</code> 檔案中 <code>getParameters</code> 函式傳出來的 <code>vertexShader</code> 及 <code>fragmentShader</code>，其來源的 shader 模板就是 <code>./ShaderLib/meshbasic.glsl.js</code></p>
<ul>
<li><code>vertexShader</code> 實際的值就是 <code>meshbasic.glsl.js</code> 匯出的 <code>vertex</code></li>
<li><code>fragmentShader</code> 實際的值就是 <code>meshbasic.glsl.js</code> 匯出的 <code>fragment</code></li>
</ul>
<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshbasic.glsl.js">meshbasic.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> vertex = <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#include &lt;common&gt;</span></span><br><span class="line"><span class="string">#include &lt;batching_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;uv_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;envmap_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;color_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;fog_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;morphtarget_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;skinning_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;logdepthbuf_pars_vertex&gt;</span></span><br><span class="line"><span class="string">#include &lt;clipping_planes_pars_vertex&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #include &lt;uv_vertex&gt;</span></span><br><span class="line"><span class="string">  #include &lt;color_vertex&gt;</span></span><br><span class="line"><span class="string">  #include &lt;morphinstance_vertex&gt;</span></span><br><span class="line"><span class="string">  #include &lt;morphcolor_vertex&gt;</span></span><br><span class="line"><span class="string">  #include &lt;batching_vertex&gt;</span></span><br><span class="line"><span class="string">  // ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fragment = <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">uniform vec3 diffuse;</span></span><br><span class="line"><span class="string">uniform float opacity;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifndef FLAT_SHADED</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  varying vec3 vNormal;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  vec4 diffuseColor = vec4( diffuse, opacity );</span></span><br><span class="line"><span class="string">  #include &lt;clipping_planes_fragment&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #include &lt;logdepthbuf_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;map_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;color_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;alphamap_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;alphatest_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;alphahash_fragment&gt;</span></span><br><span class="line"><span class="string">  #include &lt;specularmap_fragment&gt;</span></span><br><span class="line"><span class="string">  // ...</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>所以讓我們來看看以第 ７ 行 <code>#include &lt;fog_pars_vertex&gt;</code> 來說，這一行字串最後會藉由 <code>resolveIncludes</code> 這個函式，將 <code>#include</code> 後面的 <code>&lt;fog_pars_vertex&gt;</code> 字串挑出並替換成 <code>ShaderChunk</code> 資料夾底下同名的檔案 <code>fog_pars_vertex.glsl.js</code> 引入真正的 shader 程式碼</p>
<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js">fog_pars_vertex.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#ifdef USE_FOG</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  varying float vFogDepth;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>到此我們終於搞清楚了 Three.js 裡整個 shader 的架構，首先是判斷是不是使用 <code>RawShaderMaterial</code>，如果是的話，就代表整個 shader 的程式碼使用者自己輸入，而如果是使用 <code>ShaderMaterial</code> 的話，Three.js 會幫你引用一堆預定義好的 shader 功能，例如: fog，而這整個套用預定義 shader 的流程會從每個各自的 Material shader 模板出發 (ex. <code>meshbasic.glsl.js</code>)，這個 shader 模板裡面寫有一堆 <code>#include ...</code> 開頭的字串，之後藉由 <code>resolveIncludes</code> 函式解析出 <code>#include</code> 後的字串是代表要開啟什麼樣的 shader 效果 (ex. <code>#include &lt;fog_pars_vertex&gt;</code>)，並引用 <code>ShaderChunk</code> 資料夾底下相對應的 shader 檔案替換成真正的 shader 程式碼 (ex. <code>fog_pars_vertex.glsl.js</code>)</p>
<p><strong>P.S. fog shader 廢除</strong><br>這裡我們用 fog 當作範例來講解 shader 的架構，但在看原始碼時我發現 fog 的 shader 使用方式應該是已經廢除了，原因是下面這一部分的程式會判斷 <code>parameters.useFog</code> 為 <code>true</code> 時才開啟 <code>USE_FOG</code> 的功能，但可以發現 <code>parameters.useFog = material.fog === true</code>, 而在官方的 <a href="https://threejs.org/docs/?q=Material#api/en/materials/Material">Material</a> 文件裡已經沒有 <code>fog</code> 的屬性了，看樣子 <code>fog</code> 之類的功能已經額外移出來到 <a href="https://threejs.org/docs/?q=fog#api/en/scenes/Fog">Fog
</a> 跟 <a href="https://threejs.org/docs/#api/en/scenes/FogExp2">FogExp2</a> 了</p>
<p><a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js">WebGLProgram.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prefixVertex = [</span><br><span class="line">  parameters.<span class="property">useFog</span> &amp;&amp; parameters.<span class="property">fog</span> ? <span class="string">&#x27;#define USE_FOG&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  parameters.<span class="property">useFog</span> &amp;&amp; parameters.<span class="property">fogExp2</span> ? <span class="string">&#x27;#define FOG_EXP2&#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下略 ...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>P.S. ShaderLib 與 ShaderChunk 資料夾</strong><br>藉由以上的討論可以知道 <code>ShaderLib</code> 底下放的就是所謂的 shader 模板 (許多 <code>#include ...</code> 開頭的字串)，而 <code>ShaderChunk</code> 底下則是放實際可以執行 shader 的程式碼 (ex. <code>fog_pars_vertex.glsl.js</code>)，這其實對應的就是官方文件的 <a href="https://threejs.org/docs/#api/en/renderers/shaders/ShaderChunk">ShaderChunk</a> 與 <a href="https://threejs.org/docs/#api/en/renderers/shaders/ShaderLib">ShaderLib</a> 頁面</p>
<hr>
<h2 id="改變-Three-js-內建的-shader-程式碼"><a href="#改變-Three-js-內建的-shader-程式碼" class="headerlink" title="改變 Three.js 內建的 shader 程式碼"></a>改變 Three.js 內建的 shader 程式碼</h2><p>上面我們搞清楚了整個 Three.js 中 shader 的架構，下面想要分享的是開發者可以透過 <a href="https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile">Material.onBeforeCompile</a> 這個函式塞入自己寫的 shader 邏輯，下面我們直接拿 Three.js 官方的範例 - <a href="https://threejs.org/examples/#webgl_materials_modified">webgl_materials_modified</a> 來做例子</p>
<p>首先在這個範例中使用 <code>GLTFLoader</code> 載入了一個叫做 <code>LeePerrySmith.glb</code> 的 3D 模型並創建了兩個人臉的 mesh，兩個 mesh 所使用的 material 是藉由 <code>buildTwistMaterial</code> 這個函式產生出來的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="title class_">GLTFLoader</span>();</span><br><span class="line">loader.<span class="title function_">load</span>(<span class="string">&#x27;models/gltf/LeePerrySmith/LeePerrySmith.glb&#x27;</span>, <span class="keyword">function</span> (<span class="params">gltf</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> geometry = gltf.<span class="property">scene</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">geometry</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, <span class="title function_">buildTwistMaterial</span>(<span class="number">2.0</span>));</span><br><span class="line">  mesh.<span class="property">position</span>.<span class="property">x</span> = -<span class="number">3.5</span>;</span><br><span class="line">  mesh.<span class="property">position</span>.<span class="property">y</span> = -<span class="number">0.5</span>;</span><br><span class="line">  scene.<span class="title function_">add</span>(mesh);</span><br><span class="line"></span><br><span class="line">  mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, <span class="title function_">buildTwistMaterial</span>(-<span class="number">2.0</span>));</span><br><span class="line">  mesh.<span class="property">position</span>.<span class="property">x</span> = <span class="number">3.5</span>;</span><br><span class="line">  mesh.<span class="property">position</span>.<span class="property">y</span> = -<span class="number">0.5</span>;</span><br><span class="line">  scene.<span class="title function_">add</span>(mesh);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>buildTwistMaterial</code> 中使用了 <code>Material.onBeforeCompile</code> 更改 Three.js 內置的 shader 達到人臉左右扭曲的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildTwistMaterial</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshNormalMaterial</span>();</span><br><span class="line">  material.<span class="property">onBeforeCompile</span> = <span class="keyword">function</span> (<span class="params">shader</span>) &#123;</span><br><span class="line">    shader.<span class="property">uniforms</span>.<span class="property">time</span> = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    shader.<span class="property">vertexShader</span> = <span class="string">&#x27;uniform float time;\n&#x27;</span> + shader.<span class="property">vertexShader</span>;</span><br><span class="line">    shader.<span class="property">vertexShader</span> = shader.<span class="property">vertexShader</span>.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="string">&#x27;#include &lt;begin_vertex&gt;&#x27;</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">`float theta = sin( time + position.y ) / <span class="subst">$&#123;amount.toFixed(<span class="number">1</span>)&#125;</span>;`</span>,</span><br><span class="line">        <span class="string">&#x27;float c = cos( theta );&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;float s = sin( theta );&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vec3 transformed = vec3( position ) * m;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vNormal = vNormal * m;&#x27;</span></span><br><span class="line">      ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    material.<span class="property">userData</span>.<span class="property">shader</span> = shader;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure WebGLRenderer doesn&#x27;t reuse a single program</span></span><br><span class="line"></span><br><span class="line">  material.<span class="property">customProgramCacheKey</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> amount.<span class="title function_">toFixed</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先來看第 3 行 <code>onBeforeCompile</code> 中取得的 <code>shader</code> 是什麼？可以從 three.js 的原始碼中找到在 <a href="https://github.com/mrdoob/three.js/blob/e0b7bd9ca547889d6a57dfcd32596317f2ccf28c/src/renderers/WebGLRenderer.js#L1693">WebGLRenderer.js</a> 中呼叫了 <code>material.onBeforeCompile</code> 並把 <code>parameters</code> 傳進去</p>
<p><a href="https://github.com/mrdoob/three.js/blob/e0b7bd9ca547889d6a57dfcd32596317f2ccf28c/src/renderers/WebGLRenderer.js#L1693">WebGLRenderer.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parameters.<span class="property">uniforms</span> = programCache.<span class="title function_">getUniforms</span>(material);</span><br><span class="line"></span><br><span class="line">material.<span class="title function_">onBeforeCompile</span>(parameters, _this);</span><br><span class="line"></span><br><span class="line">program = programCache.<span class="title function_">acquireProgram</span>(parameters, programCacheKey);</span><br><span class="line">programs.<span class="title function_">set</span>(programCacheKey, program);</span><br></pre></td></tr></table></figure>

<p>接著會發現 <code>parameters</code> 是從 <code>programCache.getParameters</code> 來的，而 <code>programCache</code> 是 <a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/webgl/WebGLPrograms.js#L9">WebGLPrograms.js</a> 產生出來的實例</p>
<p><a href="https://github.com/mrdoob/three.js/blob/e0b7bd9ca547889d6a57dfcd32596317f2ccf28c/src/renderers/WebGLRenderer.js#L1652">WebGLRenderer.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">programCache = <span class="keyword">new</span> <span class="title class_">WebGLPrograms</span>(</span><br><span class="line">  _this,</span><br><span class="line">  cubemaps,</span><br><span class="line">  cubeuvmaps,</span><br><span class="line">  extensions,</span><br><span class="line">  capabilities,</span><br><span class="line">  bindingStates,</span><br><span class="line">  clipping</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parameters = programCache.<span class="title function_">getParameters</span>(</span><br><span class="line">  material,</span><br><span class="line">  lights.<span class="property">state</span>,</span><br><span class="line">  shadowsArray,</span><br><span class="line">  scene,</span><br><span class="line">  object</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> programCacheKey = programCache.<span class="title function_">getProgramCacheKey</span>(parameters);</span><br></pre></td></tr></table></figure>

<p>最終在 <code>WebGLPrograms.js</code> 檔案裡終於找到了定義 <code>parameters</code> 變數的地方，看到這裡有沒有覺得熟悉了起來，這裡的 <code>vertexShader</code> 跟 <code>fragmentShader</code>，這兩個東西就是剛剛上面在探討的 <a href="#vertexShader">3. vertexShader</a>，所以這裡的 <code>vertexShader</code> 跟 <code>fragmentShader</code> 都是從 <code>ShaderLib</code> 資料夾底下的 shader 模板來的</p>
<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/webgl/WebGLPrograms.js#L177">WebGLPrograms.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shaderID) &#123;</span><br><span class="line">  <span class="keyword">const</span> shader = <span class="title class_">ShaderLib</span>[shaderID];</span><br><span class="line"></span><br><span class="line">  vertexShader = shader.<span class="property">vertexShader</span>;</span><br><span class="line">  fragmentShader = shader.<span class="property">fragmentShader</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parameters = &#123;</span><br><span class="line">  <span class="attr">shaderID</span>: shaderID,</span><br><span class="line">  <span class="attr">shaderType</span>: material.<span class="property">type</span>,</span><br><span class="line">  <span class="attr">shaderName</span>: material.<span class="property">name</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">vertexShader</span>: vertexShader,</span><br><span class="line">  <span class="attr">fragmentShader</span>: fragmentShader,</span><br><span class="line">  <span class="attr">defines</span>: material.<span class="property">defines</span></span><br><span class="line">  <span class="comment">// ... 下略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回到上面 <code>buildTwistMaterial</code> 函式中用到的是 <a href="https://threejs.org/docs/#api/en/materials/MeshNormalMaterial">MeshNormalMaterial</a>，對應到的 shader 模板是 <code>ShaderLib</code> 資料夾底下的 <code>meshnormal.glsl.js</code></p>
<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/shaders/ShaderLib/meshnormal.glsl.js">meshnormal.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  #include &lt;uv_vertex&gt;</span><br><span class="line">  #include &lt;batching_vertex&gt;</span><br><span class="line"></span><br><span class="line">  #include &lt;beginnormal_vertex&gt;</span><br><span class="line">  #include &lt;morphinstance_vertex&gt;</span><br><span class="line">  #include &lt;morphnormal_vertex&gt;</span><br><span class="line">  #include &lt;skinbase_vertex&gt;</span><br><span class="line">  #include &lt;skinnormal_vertex&gt;</span><br><span class="line">  #include &lt;defaultnormal_vertex&gt;</span><br><span class="line">  #include &lt;normal_vertex&gt;</span><br><span class="line"></span><br><span class="line">  #include &lt;begin_vertex&gt;</span><br><span class="line">  #include &lt;morphtarget_vertex&gt;</span><br><span class="line">  #include &lt;skinning_vertex&gt;</span><br><span class="line">  #include &lt;displacementmap_vertex&gt;</span><br><span class="line">  #include &lt;project_vertex&gt;</span><br><span class="line">  #include &lt;logdepthbuf_vertex&gt;</span><br><span class="line">  #include &lt;clipping_planes_vertex&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在 <code>buildTwistMaterial</code> 函式中是將第 14 行的 <code>#include &lt;begin_vertex&gt;</code> 這一行程式碼替換為自己所撰寫的 shader，關鍵的一行是 <code>mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );</code> 這裡創建了一個繞 Y 軸的旋轉矩陣，將原本的 vertex 位置 <code>vec3( position )</code> 及法線向量 <code>vNormal</code> 都乘上這個旋轉矩陣，做到模型圍繞著 Y 軸進行旋轉的效果</p>
<p>至於為什麼 <code>mat3( c, 0, s, 0, 1, 0, -s, 0, c )</code> 是圍繞著 Y 軸的旋轉矩陣呢？請參考這兩篇文章 <a href="https://www.cnblogs.com/MetaWang/p/10094784.html">旋轉矩陣</a> 以及 <a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/07%20Transformations/">变换</a></p>
<p><code>buildTwistMaterial</code> 函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">material.<span class="property">onBeforeCompile</span> = <span class="keyword">function</span> (<span class="params">shader</span>) &#123;</span><br><span class="line">  shader.<span class="property">uniforms</span>.<span class="property">time</span> = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  shader.<span class="property">vertexShader</span> = <span class="string">&#x27;uniform float time;\n&#x27;</span> + shader.<span class="property">vertexShader</span>;</span><br><span class="line">  shader.<span class="property">vertexShader</span> = shader.<span class="property">vertexShader</span>.<span class="title function_">replace</span>(</span><br><span class="line">    <span class="string">&#x27;#include &lt;begin_vertex&gt;&#x27;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">`float theta = sin( time + position.y ) / <span class="subst">$&#123;amount.toFixed(<span class="number">1</span>)&#125;</span>;`</span>,</span><br><span class="line">      <span class="string">&#x27;float c = cos( theta );&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;float s = sin( theta );&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vec3 transformed = vec3( position ) * m;&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vNormal = vNormal * m;&#x27;</span></span><br><span class="line">    ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  material.<span class="property">userData</span>.<span class="property">shader</span> = shader;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外還有一個問題是為什麼最後改變的變數名稱是 <code>transformed</code> 跟 <code>vNormal</code> 呢？原因是要看後面套用的 shader 程式碼，<code>transformed</code> 這個變數之後會在 <code>project_vertex.glsl.js</code> 裡最終傳遞給 <code>gl_Position</code>，而 <code>vNormal</code> 則是會在 <code>normal_fragment_begin.glsl.js</code> 檔案中轉換成 <code>normal</code>，<code>normal</code> 最終會在 <code>meshnormal.glsl.js</code> 檔案中傳給 <code>gl_FragColor</code> 決定每個像素點的顏色</p>
<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/shaders/ShaderChunk/project_vertex.glsl.js">project_vertex.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">vec4 mvPosition = vec4( transformed, 1.0 );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef USE_BATCHING</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  mvPosition = batchingMatrix * mvPosition;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef USE_INSTANCING</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  mvPosition = instanceMatrix * mvPosition;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mvPosition = modelViewMatrix * mvPosition;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gl_Position = projectionMatrix * mvPosition;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js">normal_fragment_begin.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#ifdef <span class="variable constant_">FLAT_SHADED</span></span><br><span class="line"></span><br><span class="line">  vec3 fdx = <span class="title function_">dFdx</span>( vViewPosition );</span><br><span class="line">  vec3 fdy = <span class="title function_">dFdy</span>( vViewPosition );</span><br><span class="line">  vec3 normal = <span class="title function_">normalize</span>( <span class="title function_">cross</span>( fdx, fdy ) );</span><br><span class="line"></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  vec3 normal = <span class="title function_">normalize</span>( vNormal );</span><br><span class="line"></span><br><span class="line">  #ifdef <span class="variable constant_">DOUBLE_SIDED</span></span><br><span class="line"></span><br><span class="line">    normal *= faceDirection;</span><br><span class="line"></span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/shaders/ShaderLib/meshnormal.glsl.js">meshnormal.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fragment = <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="customProgramCacheKey"><a href="#customProgramCacheKey" class="headerlink" title="customProgramCacheKey"></a>customProgramCacheKey</h3><p>最後的最後還有個小問題，不知道大家有沒有注意到除了 <code>onBeforeCompile</code>，另外還定義了一個 <a href="https://threejs.org/docs/#api/en/materials/Material">customProgramCacheKey</a>，這似乎是因為 Three.js 會覆用一個叫做 <code>program</code> 的變數，而每個 <code>program</code> 的變數是用一個叫做 <code>programCacheKey</code> 去記錄這個 <code>program</code> 唯一的 key 值</p>
<p><code>buildTwistMaterial</code> 函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make sure WebGLRenderer doesn&#x27;t reuse a single program</span></span><br><span class="line"></span><br><span class="line">material.<span class="property">customProgramCacheKey</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> amount.<span class="title function_">toFixed</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/WebGLRenderer.js#L1653">WebGLRenderer.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> programCacheKey = programCache.<span class="title function_">getProgramCacheKey</span>(parameters);</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/renderers/webgl/WebGLPrograms.js#L377">WebGLPrograms</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getProgramCacheKey</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">  <span class="comment">// ... 上略</span></span><br><span class="line">  array.<span class="title function_">push</span>(parameters.<span class="property">customProgramCacheKey</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而預設的 <code>Material.customProgramCacheKey()</code> 只會將 <code>onBeforeCompile</code> 函數整個 <code>toString()</code> 當作唯一的 cacheKey</p>
<p><a href="https://github.com/mrdoob/three.js/blob/7b4b9ff3f75ac97054b0f9e60bb5fe17815fde8d/src/materials/Material.js#L109">Material.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">customProgramCacheKey</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">onBeforeCompile</span>.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在 <code>buildTwistMaterial</code> 函式才需要根據 <code>amount</code> 的值去定義不同的 cacheKey，如果沒有自定義 <code>material.customProgramCacheKey</code> 這一段的話，兩個人臉 mesh 因為 <code>onBeforeCompile</code> 的函數一樣就會變成他們的 <code>programCacheKey</code> 也都相同了</p>
<p>最後關於這個範例，我也照樣複製了一個 <a href="https://codesandbox.io/p/github/bcjohnblue/threejs-onBeforeCompile-example/main">線上版本</a> 出來，有興趣的人可以去更改自定義的 shader 讓整個變形的方向改成是圍繞 x 軸或是 z 軸旋轉</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>這篇研究 shader 架構採用的版本是 three.js r173</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://juejin.cn/post/6850418117509414925">通过方法 onBeforeCompile 为 three.js 现有材质增加功能</a><br><a href="http://www.webgl3d.cn/pages/b7b8ff/">threejs 材质的 shader 代码</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/01（三）</title>
    <url>/blog/2025/01/11/2025-01-01%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>護士說早上有嘗試把升壓藥的濃度降低，但又出現一次心跳驟停的狀況，當下把濃度再調回去後有恢復正常，另外昨晚注射白蛋白後，水腫已經好很多了，爺爺的右手不像昨天那樣按下去都沒有反彈，現在看起來就跟我的手回彈程度差不多了，後來回奶奶家，跟他說爺爺這兩天的狀況不好，昨天晚上心臟有停止的狀況，但奶奶似乎沒有覺得很嚴重，他一直都覺得爺爺手腳有動來動去，應該快好了啊</p>
<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>傍晚小姑姑突然跑來我們家找紗紗玩，想說他都跑來了剛好也可以去看爺爺，今天奶奶也說要去看爺爺，這是他第二次出門來看爺爺，昨天似乎就跟我說這次要把爺爺翻過身來，看看背後有沒有躺太久有一些褥瘡、發炎的狀況，看起來今天也要注意奶奶不要讓他動到管子、儀器等造成危險。後來，今天是大姑姑他們陪著奶奶一起進去加護病房，聽說奶奶在裡面把爺爺動來動去，好像把什麼探測儀器弄掉了導致紅燈亮起大響，護士還緊急的跑進來提醒，果然奶奶一出動就會弄得天翻地覆的</p>
<h5 id="晚上-10-15"><a href="#晚上-10-15" class="headerlink" title="- 晚上 10:15"></a>- 晚上 10:15</h5><p>今天又突然接到醫院的電話，現在只要電話響起來都會很緊張，沒想到昨天的心臟驟停今天又發生了，我趕快到醫院陪爺爺看看情況，剛到醫院，又接到醫院打來的電話說爺爺剛打了強心針後，狀況有穩定下來了，看我要不要隔天再過來看就好，但我已經在加護病房的門口了。一進去我就跟爺爺說，我又來跟你說新年快樂了，今天應該是我第四次還是第五次來跟你說新年快樂了吧，今天是元旦 114 年 1 月 1 日喔，又是新的一年，過了今天爺爺你就已經 98 還是 99 歲了呢</p>
<p>後來住院醫生又來解釋病況，說心臟驟停有可能是年紀大心臟的訊號有時會不正常的傳導導致，後來是打了一劑強心針加上把升壓藥的濃度從 2 調到 5 後狀況有穩定點了，但我看著心電圖顯示的心跳 117、120，看起來打完強心針心跳瞬間就會跳得很快，後來跟護士討論以及<a href="https://www.imeddy.com/content/233.html">自己查的一些資料</a>，護士直接表明了強心針的使用治標不治本，說白了就是拖時間，哎，如果每次強心針的使用都會都只是延緩痛苦，那是不是乾脆之後不要再用強心針對爺爺來說會比較輕鬆呢？只是這樣護士說那當下次同樣發生心臟驟停時，瞬間心電圖就會是一條線，一切都會來得很快</p>
<div style="text-align: right">2025/01/05 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/02 (四)</title>
    <url>/blog/2025/01/11/2025-01-02-%E5%9B%9B/</url>
    <content><![CDATA[<p>今天約了早上 11:00 第二次與主治醫生會面，預先想好的問題是爺爺腦部的損傷程度、昨晚打的強心針、還有安寧照護的可能性等，總共問了以下問題：</p>
<ol>
<li><p>問：MRI 結果顯示目前的腦部的受損狀況如何？很嚴重嗎？<br>答：今天醫生不像第一次會面時講的比較保守了，直接說要能夠清醒的機率很低</p>
</li>
<li><p>問：之前有聽護士說爺爺的瞳孔反射微弱，加上這次腦幹中風似乎受損很嚴重，這樣算是腦死的狀況嗎？<br>答：沒有沒有，這樣還沒有到腦死，如果是腦死的話一兩天內就會走了</p>
</li>
<li><p>問：昨天跟前天晚上爺爺都有心跳驟停的狀況，有補一劑強心針，想問這種心跳驟停的狀況之後會時常發生嗎？另外強心針是可以一直打的嗎？<br>答：心跳驟停這個狀況只要發生一次，之後就會常常發生，強心針的話就是一種治療的方式，搭配升壓藥一起使用讓病人的心臟可以跳回來</p>
</li>
<li><p>問：爺爺目前的狀況符合安寧照護嗎？<br>答：當然符合，如果有需要的話會知會安寧小組，之後安排時間跟家屬共同討論</p>
</li>
</ol>
<p>後來零星又提到了強心針之類的問題，這時令我印象最深刻的是一聽到強心針，爺爺就突然動得很激烈，右手、胸部、頭都有很明顯的移動，這時候我覺得很難過，在病人的床前討論安寧照護、抉擇是否要繼續打強心針的事情，不知道爺爺聽完後認為是想打強心針或不想打，雖然我有分別問他想打或不想打的話可以動動右手讓我們知道，但其實訊號也沒有很明顯，我也只能跟爺爺說沒事沒事放鬆，我們會做出讓爺爺不那麼辛苦的決定的</p>
<p>最後來回大概討論了十分多鐘，達成一些結論是：</p>
<ol>
<li>如果有呼吸管堵塞等問題，需要更換的狀況下，決定不再次插管</li>
<li>藥物注射先持續使用，包括升壓藥、強心針等</li>
<li>醫院會聯絡安寧小組跟我們約時間一起討論 (沒想到後來下午兩點多就接到醫院的電話說約好隔天的下午兩點招開會議討論)</li>
</ol>
<p>很感謝這時旁邊的護士一直都直接在手上記錄下我們討論的內容，主治醫生也沒有第一次會面時的這麼冷漠不屑，能感覺得到他比較耐心的解釋</p>
<h5 id="中午"><a href="#中午" class="headerlink" title="- 中午"></a>- 中午</h5><p>決定要走安寧照護這條路後，該跟奶奶告知目前的狀況了，之前奶奶來病房看過爺爺兩次，每次都很激動地按摩他的手、大力拍他的臉、胸，試圖想要叫醒他，每次看完出來都會說爺爺的手腳都在動，還緊抓住他的手，應該很快就會清醒了</p>
<p>「爺爺這次是腦中風+心臟衰竭，狀況越來越不好，可能只剩兩三天就要走了」，我只好開門見山的打字給奶奶看，奶奶看完後說怎麼可能之前去爺爺都手腳都動得很厲害，「那個是肌肉反射，爺爺現在腦部受損沒有意識」，我也只能把醫生的觀點跟奶奶說，雖然奶奶一開始不相信，但過了一會他似乎慢慢接受了，開始會碎念這樣一個人要怎麼辦… 後來，不知道為什麼拿出了一堆東西叫我不要亂丟，像是舅公當初搬去美國時，送給爺爺的一個台灣形狀的花盆？還有爺爺在民國 77 年退役頒發的獎牌，那時我都還沒出生呢</p>
<img src="./退役獎牌.jpg" style="width: 30%" />

<h5 id="晚上"><a href="#晚上" class="headerlink" title="- 晚上"></a>- 晚上</h5><p>晚上我跟大姑姑一樣七點去看爺爺，這時大姑姑有打 wechat 給在大陸的爸爸遠端通話，但很明顯他對這件事沒有想要關心的意思，後來又因為以前的事情在那邊吵起來，最後直接掛電話，還記得上次爺爺膀胱癌住院他有回台灣來照顧，結果也是弄到半夜四五點在那邊不爽吵架就大罵離開，真的是每次有他參與的場合就在幫倒忙</p>
<div style="text-align: right">2025/01/02 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (3) - 深度值的計算方式</title>
    <url>/blog/2025/02/28/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-3-%E6%B7%B1%E5%BA%A6%E5%80%BC%E7%9A%84%E8%A8%88%E7%AE%97%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-3-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-3-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 3 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 3 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇提到了所有 <strong>像素(fragment)</strong> 對應的深度值都會落在 <strong>[0, 1]</strong> 區間內，<strong>0</strong> 代表這個 <strong>像素(fragment)</strong> 離相機最近，而 <strong>1</strong> 代表離相機最遠。但每個物體與相機之間的距離都不一樣，要如何把這些距離都轉換到深度值的 <strong>[0, 1]</strong> 區間內呢？這篇文章將討論如何將物體的距離($ z $ 值)轉換成 <strong>[0, 1]</strong> 區間內的深度值</p>
<span id="more"></span>

<h2 id="深度值的線性轉換"><a href="#深度值的線性轉換" class="headerlink" title="深度值的線性轉換"></a>深度值的線性轉換</h2><p>要將所有物體的 $ z $ 值轉換到 <strong>[0, 1]</strong> 區間，最簡單的方式就是所謂的線性轉換：</p>


$$
\large z_{depth} = \frac{z - \text{near}}{\text{far} - \text{near}}
$$



<p>套用以上方程式後</p>
<ul>
<li>在 <strong>近平面</strong> 上的物體 $ z &#x3D; near &#x3D;&gt; z_{depth} &#x3D; 0 $</li>
<li>在 <strong>遠平面</strong> 上的物體 $ z &#x3D; far &#x3D;&gt; z_{depth} &#x3D; 1 $</li>
</ul>
<p>假設 $ near &#x3D; 1, far &#x3D; 50 $ 可以畫出以下的圖，在 <code>near</code> 與 <code>far</code> 之間的所有 $ z $ 值，都轉換到了 <strong>[0, 1]</strong> 之間的深度值</p>
<div style="display: flex; justify-content: center;">
  <img src="./linear.png" />
</div>

<h2 id="實際上深度值的轉換函式"><a href="#實際上深度值的轉換函式" class="headerlink" title="實際上深度值的轉換函式"></a>實際上深度值的轉換函式</h2><p>雖然上面線性轉換的方式可以把所有 $ z $ 值都轉換到 <strong>[0, 1]</strong> 的區間內，但實際上並不會使用這種簡單的線性轉換，原因是人的眼睛對於近處的物體比遠處的還要敏感，眼前的物體能很好的辨別他們之間的前後關係，至於越遠的物體在視野內會顯得越小就會更難分辨他們的前後關係。因此上面的線性方程不能很好的模擬人眼實際看起來的狀況，為了要模擬人眼這種近處分辨率高、遠處分辨率低的狀況，實際上深度值的轉換函式 $ z_{depth} $ 是和 $ 1&#x2F;z $ 成正比的：</p>


$$
\large z_{depth} = \frac{1/z - 1/near}{1/far - 1/near}
$$



<ul>
<li>在 <strong>近平面</strong> 上的物體 $ z &#x3D; near &#x3D;&gt; z_{depth} &#x3D; 0 $</li>
<li>在 <strong>遠平面</strong> 上的物體 $ z &#x3D; far &#x3D;&gt; z_{depth} &#x3D; 1 $</li>
</ul>
<div style="display: flex; justify-content: center;">
  <img src="./reciprocal.png" />
</div>

<p>以 $ z &#x3D; 10 $ 來看，原本的線性函式大約只涵蓋了 <strong>[0, 0.2]</strong> 區間的範圍，而這個與 $ 1&#x2F;z $ 成正比的函式則是涵蓋了約 <strong>[0, 0.9]</strong> 這麼廣的深度值範圍，這代表與 $ 1&#x2F;z $ 成正比進行轉換的函式，對於近處的物體有更大範圍的深度值可以去覆蓋，也就是近處要比遠處更能分辨物體的前後關係</p>
<p>與 $ 1&#x2F;z $ 成正比的轉換函式可以很好的將原本的 $ z $ 值轉換到深度值的 <strong>[0, 1]</strong> 區間，也符合實際上人眼的感知狀況，但為什麼用以上函式就可以很好的模擬人眼感知的狀況呢？下面我們打算用數學推導出這個與 $ 1&#x2F;z $ 成正比的轉換函式</p>
<h2 id="3D-投影到-2D"><a href="#3D-投影到-2D" class="headerlink" title="3D 投影到 2D"></a>3D 投影到 2D</h2><p>在進入正式的數學推導前我們需要了解一些關於投影的技巧，由於 3D 的物體最終要呈現在 2D 的電腦螢幕上，所以勢必有一個將 3D 座標投影到 2D 座標的技術，最常見的有 <strong>透視投影 (Perspective projection)</strong> 跟 <strong>正交投影 (Orthographic projection)</strong></p>
<p><strong>透視投影</strong>如下面左圖所示，以相機為原點，會定義一個 <strong>近平面 (Near plane)</strong> 與 <strong>遠平面 (Far plane)</strong>，在<strong>近平面</strong>與<strong>遠平面</strong>之中的這個類梯形區域有個專有名詞叫做 <a href="https://zh.wikipedia.org/zh-tw/%E8%A7%86%E4%BD%93">視錐體 (frustum)</a>，在<strong>視錐體</strong>區域內的所有物體最終都會被投影到<strong>近平面</strong>上，如紅球跟黃球，而在<strong>視錐體</strong>區域外的物體會被排除，如綠球，稱之為 <a href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">視錐體剔除 (Frustum Culling)</a>，另外<strong>透視投影</strong>的一個特性是他就像人眼一樣，近處的物體看起來會較大、遠處物體看起來較小，因為黃球比較近、紅球比較遠，所以可以看到最後在 2D <strong>近平面</strong> 上的投影，黃球比較大而紅球比較小，而右下圖的<strong>正交投影</strong>就沒有這個特性，即使黃球比紅球近，但<strong>正交投影</strong>到<strong>近平面</strong>上時，兩顆球的大小是一樣的</p>
<img src="https://glumpy.readthedocs.io/en/latest/_images/projection.png" />

<p><a href="https://glumpy.readthedocs.io/en/latest/tutorial/cube-ugly.html#projection-matrix">圖片來源</a></p>
<h2 id="OpenGL-中的投影"><a href="#OpenGL-中的投影" class="headerlink" title="OpenGL 中的投影"></a>OpenGL 中的投影</h2><p>接著來看 <strong>Three.js</strong> 的底層 <strong>OpenGL</strong> 中是如何將 3D 的物體投影到 2D 的平面上，在 <a href="https://bcjohnblue.github.io/blog/2024/12/06/%E4%BD%BF%E7%94%A8-three-js-%E6%93%8D%E4%BD%9C-shader-%E7%95%AB%E5%87%BA%E5%9C%8B%E6%97%97/#Vertex-shader-%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85">Vertex shader 做的事情</a> 這篇文章中提過物體的頂點數據會轉換到不同的座標系統，從一開始的 <strong>本地座標 (local coordinate)</strong> 最後轉換到顯示在螢幕上的 <strong>螢幕座標 (screen coordinate)</strong> ，而投影這件事是將物體以相機為原點的 3D 座標系投影到 2D <strong>近平面</strong> 上，而以相機為原點的座標系就是下圖中的 <strong>View space 觀察座標 (view coordinates)</strong>，<strong>觀察座標 (view coordinates)</strong> 會經過一個 <strong>投影矩陣 (projection matrix)</strong> 的計算進而變成 <strong>Clip space 裁剪座標 (clip coordinates)</strong>，這其實就是上面所說的將 3D 物體投影到 2D 平面的過程，而中間的數學計算是將 3D 物體所在的 <strong>觀察座標 (view coordinates)</strong> 乘以 <strong>投影矩陣 (projection matrix)</strong> 變成 2D 平面的 <strong>裁剪座標 (clip coordinates)</strong></p>
<img src="https://learnopengl.com/img/getting-started/coordinate_systems.png" />

<p><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">圖片來源</a></p>
<h3 id="透視投影的過程"><a href="#透視投影的過程" class="headerlink" title="透視投影的過程"></a>透視投影的過程</h3><img src="https://leeyngdo.github.io/assets/images/computer-graphics/rendering-pipeline/vertex-processing.png" />

<p><a href="https://leeyngdo.github.io/blog/computer-graphics/2024-02-29-graphics-pipeline/">圖片來源</a></p>
<p>以下我們特別專注來看<strong>透視投影</strong>在 <strong>OpenGL</strong> 中是經由哪些過程，最終轉換為我們在電腦螢幕上看到的畫面：</p>
<h4 id="1-物體座標-Object-coordinates"><a href="#1-物體座標-Object-coordinates" class="headerlink" title="1. 物體座標 (Object coordinates)"></a>1. 物體座標 (Object coordinates)</h4><p>指的是以物體自身中心為原點的座標系，這對應到上圖中的 <strong>1. Local space</strong></p>
<h4 id="2-相機座標-Camera-coordinates"><a href="#2-相機座標-Camera-coordinates" class="headerlink" title="2. 相機座標 (Camera coordinates)"></a>2. 相機座標 (Camera coordinates)</h4><p><strong>物體座標</strong> 經由 Model &amp; View Transform (也就是乘以 Model matrix 及 View Matrix) 後，會轉換為<strong>相機座標</strong>，<strong>相機座標</strong>指的是以相機為原點的座標系，對應到的是上圖中的 <strong>3. View space</strong></p>
<h4 id="3-裁剪座標-Clip-coordinates"><a href="#3-裁剪座標-Clip-coordinates" class="headerlink" title="3. 裁剪座標 (Clip coordinates)"></a>3. 裁剪座標 (Clip coordinates)</h4><p><strong>相機座標</strong>經過<strong>透視投影</strong>到<strong>近平面</strong>上後變成<strong>裁剪座標</strong>，上面提到的黃球因為離相機比較近、紅球比較遠，所以<strong>透視投影</strong>到<strong>裁剪座標</strong>後，黃球相較於紅球會看起來比較大，在這個階段也會執行一個叫做 <strong>裁剪踢除(Clipping culling)</strong> 的過程，跟上面所提的 <strong>視錐體剔除 (Frustum culling)</strong> 是一樣的意思，以上面例子來看就是指綠球在<strong>視錐體</strong>的區域外而無法投影到<strong>近平面</strong>上</p>
<h4 id="4-標準化設備座標-Normalized-Device-Coordinates"><a href="#4-標準化設備座標-Normalized-Device-Coordinates" class="headerlink" title="4. 標準化設備座標 (Normalized Device Coordinates)"></a>4. 標準化設備座標 (Normalized Device Coordinates)</h4><p>簡寫做 <strong>NDC</strong>，<strong>NDC</strong> 是物體最終呈現在畫面上的前一個座標系，目的是讓座標系限制在一個固定的區間，在 <strong>OpenGL</strong> 中 <strong>NDC</strong> 的座標被限制在 <strong>[-1, 1]</strong> 之間，在轉換為 <strong>NDC</strong> 座標前會經過一個叫做 <strong>透視除法 (Perspective division)</strong> 的過程，這個東西有點難用文字敘述，比較適合用數學來說明，所以我們將在下面的數學推導中提及</p>
<h4 id="5-螢幕座標-Screen-coordinates"><a href="#5-螢幕座標-Screen-coordinates" class="headerlink" title="5. 螢幕座標 (Screen coordinates)"></a>5. 螢幕座標 (Screen coordinates)</h4><p>在得知螢幕寬高後就可以將 <strong>NDC</strong> 座標轉換為<strong>螢幕座標</strong>，<strong>NDC</strong> 座標中的 <strong>[-1, -1]</strong> 對應到螢幕的左下角、<strong>[0, 0]</strong> 對應到螢幕的中間、<strong>[1, 1]</strong> 對應到螢幕的右上角，這個轉換的過程稱之為<strong>視口變換(Viewport transform)</strong>，假設螢幕的寬高為 1440*900，那麼 <strong>NDC</strong> 座標的 <strong>[0, 0]</strong> 代表的就是<strong>螢幕座標</strong>的 <strong>[720, 450]</strong></p>
<p>到目前為止我們講了許多關於<strong>透視投影</strong>的過程，為的就是讓大家在進入下面的數學推導時可以清楚了解各個座標是如何進行轉換的，接著就要開始數學推導了，以下藉由<strong>透視投影</strong>最終推導出深度值 $ Z_{depth} $ 與 $ 1&#x2F;z $ 成正比的深度轉換函式</p>
<hr>
<h3 id="透視投影-Perspective-projection"><a href="#透視投影-Perspective-projection" class="headerlink" title="透視投影 (Perspective projection)"></a>透視投影 (Perspective projection)</h3><p><strong>透視投影</strong>將 <strong>觀察座標 $ (x_e, y_e, z_e, w_e) $</strong> 乘以一個的 $ 4x4 $ <strong>投影矩陣 (projection matrix)</strong> 轉換成 <strong>裁剪座標 $ (x_p, y_p, z_p, w_p) $</strong>，接下來的目標是求出這個 $ 4x4 $ 的<strong>投影矩陣</strong></p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
projection \; matrix \cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<br />
<br />

<p>第一步我們先從 $ z $ 軸看起，轉換 $ z $ 軸座標很簡單，由於每個點最後都會投影到<strong>近平面</strong>上，所以 $ z $ 軸的座標值一律都會變成 $ -n $，也就是 $ z_p &#x3D; -n $</p>
<p>P.S. $ -n $ 指的是<strong>近平面</strong>所在的 $ z $ 軸數值，請看 <a href="./#標準化設備座標-Normalized-Device-Coordinates">NDC 座標圖片</a> 的左圖</p>
<p>下一步讓我們來推導 $ x $ 及 $ y $ 軸投射到近平面上的座標，從下面左圖 $ x, z $ 軸的剖面可知 <strong>觀察座標</strong> $ (x_e, y_e, z_e) $ 投影到<strong>近平面</strong>的 <strong>裁剪座標</strong> $ (x_p, y_p, z_p) $ 時會形成兩個直角三角形，而我們可以利用直角三角形邊長成比例的關係得到：</p>
<p>$$<br>\displaystyle<br>\frac{x_p}{x_e} &#x3D; \frac{z_p}{z_e} \quad \Rightarrow \quad x_p &#x3D; \frac{-n}{z_e} \times x_e \tag{1}<br>$$</p>
<p>同理右圖以 $ y, z $ 軸的剖面可得：</p>
<p>$$<br>\displaystyle<br>\frac{y_p}{y_e} &#x3D; \frac{z_p}{z_e} \quad \Rightarrow \quad y_p &#x3D; \frac{-n}{z_e} \times y_e \tag{2}<br>$$</p>
<div class="two-column">
  <img src="https://www.songho.ca/opengl/files/gl_projectionmatrix03.png" />
  <img src="https://www.songho.ca/opengl/files/gl_projectionmatrix04.png" />
</div>

<p><a href="https://www.songho.ca/opengl/gl_projectionmatrix.html">圖片來源</a></p>
<h3 id="透視除法-Perspective-division"><a href="#透視除法-Perspective-division" class="headerlink" title="透視除法 (Perspective division)"></a>透視除法 (Perspective division)</h3><p>還記得我們上一篇系列文中提到的齊次矩陣嗎？<strong>裁剪座標</strong> $ (x_p, y_p, z_p) $ 的齊次座標表示為 $ (x_p, y_p, z_p, w_p) $，而將齊次座標轉換回三維座標時會將每個維度都除以 $ w_p $，這就是透視除法的含義</p>
<p>從上面直角三角形邊長成比例的推導我們發現 $ x_p $ 與 $ y_p $ 都除以 $ -z_e $，根據<strong>透視除法</strong>會將每個維度都除以 $ w_p $ 的定義，我們可以讓 $ w_p &#x3D; -z_e $ 於是首先求出投影矩陣第四列的數值</p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
\begin{bmatrix}
. & . & . & . \\
. & . & . & . \\
. & . & . & . \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<h4 id="標準化設備座標-Normalized-Device-Coordinates"><a href="#標準化設備座標-Normalized-Device-Coordinates" class="headerlink" title="標準化設備座標 (Normalized Device Coordinates)"></a>標準化設備座標 (Normalized Device Coordinates)</h4><p>執行完 <strong>透視除法 (Perspective division)</strong> 的下一步就是將座標轉換為 <strong>NDC</strong>，在 <strong>OpenGL</strong> 中 <strong>NDC</strong> 的範圍被定義在 <strong>[-1.0, 1.0]</strong> 之間</p>
<p>這裡我們以 $ l, r, t, b, n, f $ 分別代表左、右、上、下、近平面、遠平面的座標數值，如此一來從<strong>裁剪座標</strong>轉換到 <strong>NDC</strong> 所做的映射為：</p>
<ul>
<li>x 軸： $ [l, r] \Rightarrow [-1, 1] $</li>
<li>y 軸： $ [b, t] \Rightarrow [-1, 1] $</li>
<li>z 軸： $ [n, f] \Rightarrow [-1, 1] $</li>
</ul>
<p>這裡需要特別注意的是，<strong>裁剪座標</strong>是右手座標系而 <strong>NDC</strong> 是左手座標系，下圖可以很明顯的看出來 $ z $ 軸的數值是相反的</p>
<img src="https://www.songho.ca/opengl/files/gl_projectionmatrix01.png" />

<p><a href="https://www.songho.ca/opengl/gl_projectionmatrix.html">NDC 座標圖片</a></p>
<h4 id="NDC-座標轉換"><a href="#NDC-座標轉換" class="headerlink" title="NDC 座標轉換"></a>NDC 座標轉換</h4><p>下面我們藉由 <strong>NDC</strong> 座標範圍被定義在 <strong>[-1.0, 1.0]</strong> 之間，嘗試求出投影矩陣中第一及第二列的數值</p>
<h5 id="計算-x-ndc"><a href="#計算-x-ndc" class="headerlink" title="計算 $ x_{ndc} $"></a>計算 $ x_{ndc} $</h5><p>由於 $ x_p $ 會映射到 <strong>NDC</strong> 座標的 -1 到 1 之間，這裡我們採用線性轉換的方式計算 $ x_{ndc} $</p>
<p>$$<br>\displaystyle<br>x_{ndc} &#x3D; \frac{1 - (-1)}{r - l} x_p + \beta<br>$$</p>
<p>將 $ (x_p, x_{ndc}) $ 分別帶入 $ (r, 1) $ 進去：</p>
<p>$$<br>\displaystyle<br>1 &#x3D; \frac{2r}{r - l} + \beta<br>$$</p>
<p>接著求出 $ \beta $：</p>
<p>$$<br>\displaystyle<br>\beta &#x3D; 1 - \frac{2r}{r - l} &#x3D; \frac{r - l}{r - l} - \frac{2r}{r - l} &#x3D; \frac{-l - r}{r - l} &#x3D; -\frac{r + l}{r - l}<br>$$</p>
<p>所以我們得出：</p>
<p>$$<br>\displaystyle<br>x_{ndc} &#x3D; \frac{2x_p}{r - l} - \frac{r + l}{r - l}<br>$$</p>
<p>將 $ x_p $ 套入 $ (1) $ 式計算的結果：</p>


$$
\begin{align*}
x_{ndc} &= \frac{\displaystyle 2 \cdot \frac{n x_e}{-z_e}}{r - l} - \frac{r + l}{r - l} \\
&= \frac{2n \cdot x_e}{(r - l)(-z_e)} - \frac{r + l}{r - l} \\
&= \frac{\displaystyle \frac{2n}{r-l} \cdot x_e}{-z_e} + \frac{\displaystyle \frac{r+l}{r-l} \cdot z_e}{-z_e} \\
&= \left( \underbrace{\frac{2n}{r-l} \cdot x_e + \frac{r+l}{r-l} \cdot z_e}_{\displaystyle x_p} \right) \cdot \frac{1}{-z_e}
\end{align*}
$$



<p>至此我們推導出投影矩陣的第一列了</p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
\begin{bmatrix}
\displaystyle \frac{2n}{r-l} & 0 & \displaystyle \frac{r+l}{r-l} & 0 \\
. & . & . & . \\
. & . & . & . \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<h5 id="計算-y-ndc"><a href="#計算-y-ndc" class="headerlink" title="計算 $ y_{ndc} $"></a>計算 $ y_{ndc} $</h5><p>將 $ y_{ndc} $ 也套用上面計算 $ x_{ndc} $ 一樣的方式</p>
<p>$$<br>\displaystyle<br>y_{ndc} &#x3D; \frac{1 - (-1)}{t - b} y_p + \beta<br>$$</p>
<p>將 $ (y_p, y_{ndc}) $ 分別帶入 $ (t, 1) $ 進去：</p>
<p>$$<br>\displaystyle<br>1 &#x3D; \frac{2t}{t - b} + \beta<br>$$</p>
<p>求出 $ \beta $：</p>
<p>$$<br>\displaystyle<br>\beta &#x3D; 1 - \frac{2t}{t - b} &#x3D; \frac{t - b}{t - b} - \frac{2t}{t - b} &#x3D; \frac{-b - t}{t - b} &#x3D; -\frac{t + b}{t - b}<br>$$</p>
<p>所以我們得出：</p>
<p>$$<br>\displaystyle<br>y_{ndc} &#x3D; \frac{2y_p}{t - b} - \frac{t + b}{t - b}<br>$$</p>
<p>將 $ y_p $ 套入 $ (2) $ 式計算的結果：</p>


$$
\begin{align*}
x_{ndc} &= \frac{\displaystyle 2 \cdot \frac{n y_e}{-z_e}}{t - b} - \frac{t + b}{t - b} \\
&= \frac{2n \cdot y_e}{(t - b)(-z_e)} - \frac{t + b}{t - b} \\
&= \frac{\displaystyle \frac{2n}{t-b} \cdot y_e}{-z_e} + \frac{\displaystyle \frac{t+b}{t-b} \cdot z_e}{-z_e} \\
&= \left( \underbrace{\frac{2n}{t-b} \cdot y_e + \frac{t+b}{t-b} \cdot z_e}_{\displaystyle y_p} \right) \cdot \frac{1}{-z_e}
\end{align*}
$$



<p>於是我們也推導出投影矩陣的第二列</p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
\begin{bmatrix}
\displaystyle \frac{2n}{r-l} & 0 & \displaystyle \frac{r+l}{r-l} & 0 \\
0 & \displaystyle \frac{2n}{t-b} & \displaystyle \frac{t+b}{t-b} & 0 \\
. & . & . & . \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<h5 id="計算-z-ndc"><a href="#計算-z-ndc" class="headerlink" title="計算 $ z_{ndc} $"></a>計算 $ z_{ndc} $</h5><p>最後來求投影矩陣第三列的數值，因為 $ z_p $ 是<strong>觀察座標</strong>投影到<strong>近平面</strong>上的 $ z $ 值，這代表他的數值跟原本的 $ x_e, y_e $ 都沒有關係，所以我們可以設 $ z_p &#x3D; A \cdot z_e + B \cdot w_e $，於是投影矩陣變成</p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
\begin{bmatrix}
\displaystyle \frac{2n}{r-l} & 0 & \displaystyle \frac{r+l}{r-l} & 0 \\
0 & \displaystyle \frac{2n}{t-b} & \displaystyle \frac{t+b}{t-b} & 0 \\
0 & 0 & A & B \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<p>另外根據 $ z $ 軸 <strong>NDC</strong> 座標的定義：</p>
<p>$$<br>\displaystyle<br>z_{ndc} &#x3D; \frac{z_p}{w_p} &#x3D; \frac{Az_e + Bw_e}{-z_e}<br>$$</p>
<p>在觀察空間 $ w_e &#x3D; 1 $ 所以：</p>
<p>$$<br>\displaystyle<br>z_{ndc} &#x3D; \frac{z_p}{w_p} &#x3D; \frac{Az_e + B}{-z_e} \tag{3}<br>$$</p>
<p>接著將 $ (z_e, z_{ndc}) $ 帶入 $ (-n, -1) $ 進去：</p>
<p>$$<br>\displaystyle<br>\frac{-An+B}{n} &#x3D; -1 \Rightarrow -An+B &#x3D; -n<br>$$</p>
<p>於是可以求出 $ B $：</p>
<p>$$<br>\displaystyle<br>B &#x3D; An - n<br>$$</p>
<p>同樣的將 $ (z_e, z_{ndc}) $ 帶入 $ (-f, 1) $ 進去：</p>
<p>$$<br>\displaystyle<br>\frac{-Af+B}{f} &#x3D; 1 \Rightarrow -Af+B &#x3D; f \Rightarrow -Af + (An - n) &#x3D; f \Rightarrow -(f-n)A &#x3D; f+n<br>$$</p>
<p>可以求出 $ A $：</p>
<p>$$<br>\displaystyle<br>A &#x3D; -\frac{f+n}{f-n}<br>$$</p>
<p>接著我們把 $ A $ 的數值帶回去以求出 B：</p>
<p>$$<br>\begin{align*}<br>B &#x3D; -\frac{f + n}{f - n} n -n \<br>&#x3D; -\left( 1 + \frac{f + n}{f - n} \right) n \<br>&#x3D; -\frac{f - n + f + n}{f - n} n \<br>&#x3D; -\frac{2 f n}{f - n}<br>\end{align*}<br>$$</p>
<p>好不容易終於把投影矩陣都求出來了！</p>


$$
\begin{bmatrix} x_p \\ y_p \\ z_p \\ w_p \end{bmatrix}
=
\begin{bmatrix}
\displaystyle \frac{2n}{r-l} & 0 & \displaystyle \frac{r+l}{r-l} & 0 \\
0 & \displaystyle \frac{2n}{t-b} & \displaystyle \frac{t+b}{t-b} & 0 \\
0 & 0 & \displaystyle -\frac{f+n}{f-n} & \displaystyle -\frac{2 f n}{f - n} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix} x_e \\ y_e \\ z_e \\ w_e \end{bmatrix}
$$



<h2 id="深度測試的-z-值"><a href="#深度測試的-z-值" class="headerlink" title="深度測試的 z 值"></a>深度測試的 z 值</h2><p>我們如此辛苦的推導出<strong>透視投影</strong>的投影矩陣，目的是想知道深度測試中的深度值是怎麼被算出來的，以下我們用 $ z_{depth} $ 表示深度值</p>
<p>根據定義，$ z $ 軸 <strong>NDC</strong> 座標 ($ z_{ndc} $)的範圍在 <strong>[-1, 1]</strong> 之間，而深度值 ($ z_{depth} $) 範圍在 <strong>[0, 1]</strong> 之間，所以我們會將 $ z_{ndc} $ 從 <strong>[-1, 1]</strong> 轉換到 <strong>[0, 1]</strong> 之間以表示 $ z_{depth} $</p>
<p>$$<br>z_{depth} &#x3D; \frac{z_{ndc} + 1}{2}<br>$$</p>
<p>根據 $ (3) $ 式 $ z_{ndc} $ 等於：</p>


$$
\begin{align*}
\displaystyle
z_{ndc} &= \frac{Az_e + B}{-z_e} = \frac{\displaystyle -\frac{f+n}{f-n}z_e - \frac{2 f n}{f - n}}{-z_e} = \displaystyle \frac{f+n}{f-n} + \frac{2fn}{(f - n)z_e}
\end{align*}
$$



<p>於是 $ z_{depth} $ 等於：</p>


$$
\begin{align*}
\displaystyle
z_{depth} &= \frac{\displaystyle \frac{f+n}{f-n} + \frac{2fn}{(f - n)z_e} + 1}{2} \\
&= \frac{\displaystyle \frac{f+n}{f-n} + \frac{2fn}{(f - n)z_e} + \frac{f-n}{f-n}}{2} \\
&= \frac{\displaystyle \frac{2f}{f-n} + \frac{2fn}{(f - n)z_e}}{2} \\
&= \frac{\displaystyle f + \frac{fn}{z_e}}{f-n} \\
\end{align*}
$$



<p>共同除以 $ f \cdot n $：</p>


$$
\begin{align*}
\displaystyle
z_{depth} &= \frac{\displaystyle \frac{1}{n} + \frac{1}{z_e}}{\displaystyle \frac{1}{n}-\frac{1}{f}} = \frac{\displaystyle - \frac{1}{z_e} -\frac{1}{n}}{\displaystyle \frac{1}{f}-\frac{1}{n}}
\end{align*}
$$



<p>分子的 $ \displaystyle z_e $ 位於右手座標系的<strong>觀察座標</strong>，也就是說<strong>近平面</strong>及<strong>遠平面</strong>的座標是 $ (-n, -f) $，如果我們希望改為左手座標系表示，也就是以 $ (n, f) $ 代表<strong>近平面</strong>及<strong>遠平面</strong>，z 軸的正負號會被反轉，所以最終 $ z_{depth} $ 會等於：</p>


$$
\begin{align*}
\displaystyle
z_{depth} &= \frac{\displaystyle \frac{1}{z} -\frac{1}{n}}{\displaystyle \frac{1}{f}-\frac{1}{n}}
\end{align*}
$$



<p>這就是一開始提到 <a href="./#實際上深度值的轉換函式">實際上深度值的轉換函式</a> 了，深度值與 $ 1&#x2F;z $ 成正比的關係</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>一開始我們打算讓深度值做最簡單的線性轉換，但這種轉換方式不符合人眼的看東西的狀況，接著我們學習了 3D 投影到 2D 的方式 - <strong>透視投影</strong> 跟 <strong>正交投影</strong>，以及學習 <strong>OpenGL</strong> 中<strong>透視投影</strong>經過了哪些座標系的轉換過程，最終我們藉由<strong>透視投影</strong>中的數學將<strong>觀察座標</strong>轉換成<strong>裁剪座標</strong>的過程中證明<strong>透視投影</strong>的深度值 $ z_{depth} $ 是與 $ 1&#x2F;z $ 成正比的關係</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://hackmd.io/@23657689/projection_matrix#">Projection Matrix</a> - 數學推導的主要參考文章<br><a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/01%20Depth%20testing/">深度测试</a><br><a href="https://www.youtube.com/watch?v=3xGKu4T4SCU">OpenGL Tutorial 14 - Depth Buffer</a><br><a href="https://www.mauriciopoppe.com/notes/computer-graphics/viewing/projection-transform/">Transformation matrix for projection of 3D objects into a 2D plane (projection transform)</a><br><a href="https://juejin.cn/post/7246334166950527034">一看就懂的 OpenGL ES 教程——走进 3D 的世界之坐标系统（下篇）</a><br><a href="https://www.zhihu.com/question/319254559">OpenGL 的归一化设备坐标系明明是左手坐标系，为什么其他教程上都说 OpenGL 是右手坐标系？</a></p>


<style>
.two-column {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;

  img {
    width: calc(37.5% - 5px);
    object-fit: cover;
  }
}

@media (max-width: 600px) {
  img {
      width: 100%;
  }
}

@media (min-width: 601px) {
  img {
      width: 75%;
  }
}
</style>


]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/03 (五)</title>
    <url>/blog/2025/01/11/2025-01-03-%E4%BA%94/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>今天一樣來跟爺爺講話，一到病房跟他說從第一天爺爺睡著叫不醒到送去急診室住進加護病房的這一連串事情，之前都還沒跟爺爺說過為什麼他躺在這邊好多天的原因呢，一開始不知道該怎麼講，但最終我覺得還是需要把我們打算進行安寧治療的決定當面跟爺爺說，一到病房我有跟爺爺說他的大女兒、姑丈、大女兒的兩個小孩、小女兒、兒子昨天有視訊，還有我跟我老婆都有在這幾天裡來探望陪他唷，以及你那剛出生的曾孫女小紗寶之前也有去家裡看過你你兩次喔，一次你拿著鳳梨酥的袋子陪他玩、一次他就被抱著在你房間外面盯著你看一直對你笑，很可愛吧</p>
<p>過了一會住院醫師過來講解爺爺今天的狀況，昨天晚上意外的沒有再發生心臟驟停了，想說覺得不錯，但沒想到醫師說早上的抽血結果，檢驗一個叫做<a href="https://takecareof.com.tw/articles/myocardial-infarction/">心臟酵素的濃度</a>，濃度越高代表心肌梗塞的機率越高，而醫生說爺爺驗出來的濃度是正常值的五、六十倍高….</p>
<p>之後再跟爺爺說我們下午三點會開一個安寧治療的討論會議，會決定怎麼做讓爺爺比較輕鬆，跟爺爺說現在這狀況其實就跟他常跟我說的都是年紀的關係啊，慢慢的走路不方便、失智的影響導致同樣的話五秒鐘後就會再問一遍，這都是年紀的關係啊，現在也是一樣，爺爺年紀大了突然叫不醒後查出原因是腦部血管堵塞中風，心臟會有點問題也是年紀大的關係啊，這一切其實都是很自然的，當我活到像爺爺一樣的七八十歲、八九十歲的這種年紀，這種事情也會在在我身上發生的，不用擔心，現在先好好休息吧，因為現在爺爺你也沒有意識，無法知道爺爺你到底想不想打強心針，所以就讓我幫你決定吧，強心針這種東西可以幫助心臟跳動，但他其實也是有副作用的，會讓你心跳加速可能身體不舒服，為了爺爺好，下午的會議我們決定之後會不打強心針，希望爺爺你可以理解，但爺爺你不用擔心我們都會陪在你的身邊，等到百年之後我還會去天上找你聊天陪你玩的，如果你想我的話，我每天都很會做夢，隨時都可以來我的夢中找我喔</p>
<h5 id="中午"><a href="#中午" class="headerlink" title="- 中午"></a>- 中午</h5><p>回到奶奶家，一看到我他就說很累昨天都沒睡，今天什麼事情都沒辦法做，然後我還是一樣打字給奶奶說爺爺目前的狀況：「今天早上醫生有抽血，說有心肌梗塞的狀況，可能隨時心跳會停止」，沒想到奶奶看完後又變得不相信了，「我覺得不會啊，怎麼可能，我感覺他狀況很好，馬上就會醒過來了，我冥冥中就是有這種感覺」，我也不知道該怎麼繼續說下去，暫時就先這樣吧</p>
<h5 id="下午三點"><a href="#下午三點" class="headerlink" title="- 下午三點"></a>- 下午三點</h5><p>在加護病房會議室裡招開安寧小組會議，有很多人包括住院醫師、安寧專科醫生、護理長、社工師、心理師等等，一開始由住院醫師說明爺爺的狀況，今天比較嚴重的問題是抽血檢測心臟酵素指數很高，正常值是 50，但抽血出來的結果是 15000…，接著由安寧專科醫生講解關於安寧的三種選擇：安寧病房、安寧居家、安寧共照，安寧病房目前松山醫院沒有所以暫不需考慮，如果要轉院的話最近的內湖三總床位也只有 15 床，並且聽說幾乎都是滿的需要排隊，安寧居家是拔除管子以及其他儀器後回到家裡，每週會有一兩次安寧護理師到家訪視，但因為奶奶之前有告誡過不能拔管，所以這條路也不用考慮了，最後的安寧共照是安寧護理師會在醫院審視爺爺的狀況，提供一些護理的建議，例如：如果有拉肚子現象的話，需要吃什麼藥或做什麼樣的調整，依照目前的狀況我們最終選擇的是安寧共照，希望安寧團隊的加入可以幫助緩和爺爺的痛苦，給予我們資源及支持</p>
<p>最後我有詢問關於強心針還要不要使用，根據我查到的資料跟護士的說明，強心針是種治標不治本的藥物，雖然打下去可以馬上使人心跳快速，但如果真的是病情末期，或許這也只是拖時間的措施而已，我希望爺爺最後不要太痛苦，所以希望可以簽署不施行強心針的注射，但沒想到安寧專科的邱醫生說他覺得有沒有打強心針對於病人應該沒有太大的差別，畢竟心臟如果到最後無法跳動就是無法跳動了，不管打幾劑強心針都不會有作用。原本下定決心不施打強心針的我，聽到醫生這麼說就也妥協了，關於急救部分我們還是一樣維持原方案，施行藥物注射、插管治療，但不施行電擊跟心臟按摩</p>
<div style="text-align: right">2025/01/03 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/07 (二)</title>
    <url>/blog/2025/01/11/2025-01-07-%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>今天早上在公司上班，突然電話響了是醫院打來的，還好接起來後是安寧護理師打過來告知爺爺今天的狀況，今天是繼上次安寧小組會議後，護理師第一次來照顧爺爺，我覺得護理師人真的很好，因為醫院打出來的電話每通最長只有 5 分鐘，時間到了就要重打，這次通話護理師總共重打了至少五、六次吧，為了跟我詳細解釋狀況以及回答我的問題</p>
<p>首先護理師說爺爺現在的狀況大概比較穩定了，所以在加護病房最多住 21 天，如果滿 21 天後還是需要呼吸器就會移去呼吸照護病房，如果移去那邊的話也會換主治醫師，到時看會有什麼其他治療的方式，但重點是根據護理師多年來的經驗，他說看過很多的病人在呼吸照護病房其實可以住很長的時間，甚至兩年、三年的都有看過，但呼吸加護病房很容易有各種感染源，之後大部分的病人都會來回呼吸病房與加護病房之間，狀況好了就移到呼吸病房，有感染症狀就移到加護病房如此來回，而每一次的感染都會稍微削弱病人的體力，就這樣慢慢的直到某一次病人最終體力耗盡而離去，他說他看過大部分在呼吸病房的病人最後都是這樣…</p>
<p>而另一種方式是考慮拔管，但這也不是可以想拔就拔，基本上規定是可以藉由呼吸器的訓練模式，訓練自主呼吸 5 天後，醫生就會評估可以拔管，之後看是要住到一般病房或是回家都可以</p>
<p>最後我還問了強心針與升壓藥方面的問題，爺爺之前有兩次心臟驟停的狀況，後來是靠著強心針跟升壓藥拉回心跳跟脈搏的，原本在上次安寧小組會議的時候我就有考慮要不要停用強心針，於是今天趕快把握時機詢問潘護理師有什麼看法，他說如果爺爺之前是心肌梗塞的狀況，或許我們決定不施打這些急救藥物也是一種可以讓爺爺不用忍受痛苦自然走的方式</p>
<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>晚上一到加護病房，護士很快地就進來，他希望盡快跟我們確定爺爺之後是否要住進呼吸照護病房，因為接下來的一兩個禮拜，他們的加護病房、呼吸病房似乎都要搬到新大樓去了，所以如果要移去呼吸病房的話最好提早通知他們安排床位，或是另外一種方式，這好像是護士比較推薦的，因為他也說移到呼吸病房的病人，在醫院這種環境很容易受到感染，加上呼吸病房跟加護病房一樣有固定的探病時間，我們就無法一直陪在爺爺旁邊，所以他提出看爺爺如果明天早上照的肺部 x 光跟抽血的結果沒什麼感染的狀況下，就可以試著開始進行訓練呼吸了，如果連續訓練 5 天都很順利，這樣在出加護病房的時候就可以拔管了，之後再看要去一般病房、回家或是療養院之類都可以，當然我們是希望爺爺能盡快拔管，畢竟今天看到爺爺有時會有咳嗽的反應，咳起來臉上都揪做一團，緊緊皺眉看起來就很痛的樣子…</p>
<p>陪完爺爺後，我跟大姑姑坐在加護病房外的椅子討論著下一步該如何走，我先分享早上跟護理師對話的內容，接著再分享我的想法，我大概是家人中最偏安寧派的，從 MRI 的結果出來是腦中風後，其實大概就知道腦細胞是無法恢復的，何況 MRI 的結果出來時離爺爺昏迷的當天都已經過三、四天了，如果之後還能甦醒就真的是奇蹟了，所以我傾向最好的結果是能順利完成 5 天的訓練後拔管，而之後如果再發生同樣的狀況，就不要再插管增加痛苦了，或是另一種方式，我們不要再使用強心針或升壓劑，這樣下次如果脈搏過低或又有心臟驟停發生時，那就自然地睡著吧</p>
<p>原本我以為大姑姑傾向之後繼續住呼吸病房，但沒想到他今天竟然同意拔管的想法，畢竟他之前也比較樂觀，覺得爺爺手腳都還很有活力在動，如果我們決定拔管的話豈不是擅自幫別人決定生死，更何況是自己的爸爸，但或許是這幾天爺爺的狀況沒有顯著改善以及護士等等給予的建議，才讓大姑姑同意這些安寧醫療的想法，對我而言當然太好了，畢竟我不希望之後，當每天早上我們都在上班同時，爺爺卻必須獨自插著管忍受面對這不知道還算不算是人生的狀態…</p>
<p>最後就是看如何跟奶奶講了，或許是說服或許是告知，先看看明天是不是可以順利進行拔管訓練吧</p>
<div style="text-align: right">2025/01/07 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/08 (三)</title>
    <url>/blog/2025/01/11/2025-01-08-%E4%B8%89/</url>
    <content><![CDATA[<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>原本以為今天狀況好的話爺爺就可以進入五天的訓練模式慢慢脫離呼吸器，但果然事情都不會這麼樂觀，護士說早上的肺部 x 光檢查爺爺的肺部還是有浸潤的現象，所以目前不太可能進入訓練的階段…</p>
<p>今天照顧爺爺的護士人很好，已經看過他好幾次了，他今天也花時間跟我們聊了很多，昨天晚上提到的加護病房 21 天限制，很意外地，他說目前還沒有聽到主治醫生說是否 21 天就要移到其他病房，不確定昨天跟我們說的護士是轉達主治醫生的說法或他只是想先提醒我們 21 天到了後就可能要移出去</p>
<p>之後又跟護士討論到關於安寧治療，他提供了兩種想法，一種是安寧拔管，這個方式主要是針對末期無法治癒的病人，需要兩位專科醫生都認同的狀況，才可以進行撤管，這個方法需要兩個醫生的認定，再加上奶奶前陣子表達不准拔管，這大概不會是我們目前可以進行的選擇。而另一種是急救藥物的使用，如同昨晚與大姑姑討論的決議，我們希望之後不再用強心針，而這時護士又拋出了另一個狀況，單獨不使用強心針可以，那麽升壓藥呢？目前用的只有 easydopa，之前爺爺心臟停止的時候將濃度調到最大 20 後心跳脈搏就有回來，那未來如果即使濃度調升到最大，心跳還是沒有回來，要同意使用其他三種的升壓藥嗎？</p>
<p>雖然原本從檢查出來是腦中風的時候，我就傾向走安寧這條路了，但真正要做決定的現在，才感到這種巨大的壓力，可以的話我希望明天再簽或後天再簽，而不是現在，但回到最初的本意，我們希望爺爺不要再受苦了，插了兩個禮拜的管子，雖然爺爺看起來昏迷無意識，但時不時還是會看到他咳嗽的反應，緊皺著眉這種看起來像是在忍受痛苦的表情，所以趁現在大姑姑可以一起做決定時，我額外簽了不施打強心針、也不使用額外 3 種的升壓藥的 <a href="https://tw.news.yahoo.com/dnr%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9Fdnr%E5%90%8C%E6%84%8F%E6%9B%B8%E8%AA%B0%E5%8F%AF%E4%BB%A5%E7%B0%BD%EF%BC%9F%E7%B0%BD%E4%BA%86%E9%86%AB%E7%94%9F%E5%B0%B1%E4%B8%8D%E6%9C%83%E6%95%91%E4%BA%86%E5%97%8E%EF%BC%9F-071325571.html">DNR</a></p>
<p>雖然不知道怎麼講出口，但我還是在病床旁邊跟爺爺說著「爺爺你之前總會說因為年紀的關係，走路會不方便、會開始忘東忘西，現在也是因為年紀的關係啊，有些器官心臟啊等等的都會變得比較衰弱，這都是自然的結果，我們希望之後就不使用強心針了，這樣會讓爺爺你比較輕鬆一點」就在講這些話的時候，爺爺竟然變得很有活力，右眼可以半開到看到眼珠了，右手也動來動去抓著我的手，但還是一樣皺著眉看起來很辛苦的樣子，「沒事沒事爺爺你辛苦了，放輕鬆我們都會陪著你的」我覺得爺爺聽到這些話一定會覺得很緊張，從他的反應動作看起來也是這樣，說真的我也不知道該怎麼做，我想到的就只能叫爺爺放輕鬆不要緊張，多多睡覺恢復體力</p>
<div style="text-align: right">2025/01/08 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/10 (五)</title>
    <url>/blog/2025/01/12/2025-01-10-%E4%BA%94/</url>
    <content><![CDATA[<h5 id="早上-11：00"><a href="#早上-11：00" class="headerlink" title="- 早上 11：00"></a>- 早上 11：00</h5><p>接到醫院邱個管師打來的電話，因為我們昨天有去參觀呼吸病房，他今天就打來介紹病房的設施狀況，主要大概提到幾點</p>
<ol>
<li><p>院內配合的看護一個人會同時照顧六到七位病人，費用是一個月 36000，並且戶籍都是大陸或本國籍的，如果我們要自己找外面的看護也是可以的</p>
</li>
<li><p>當爺爺使用呼吸器 21 天後，可以申請呼吸重大傷病卡，有這個的話在呼吸病房的耗材、食物營養補充物之類都會健保支付</p>
</li>
<li><p>另外他說有在使用升壓藥的狀況下可能還不會下轉到呼吸病房，會等目前的主治醫生與之後的主治醫生討論過後，覺得爺爺的狀況比較穩定，才會轉到呼吸病房</p>
</li>
</ol>
<p>大概是這樣，看樣子爺爺是否轉到呼吸病房的時間還需要等目前的主治醫生與之後呼吸病房的主治討論過後才會移過去</p>
<div style="text-align: right">2025/01/11 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/12 (日)</title>
    <url>/blog/2025/01/13/2025-01-12-%E6%97%A5/</url>
    <content><![CDATA[<h5 id="早上-11-00"><a href="#早上-11-00" class="headerlink" title="- 早上 11:00"></a>- 早上 11:00</h5><p>今天一樣去陪爺爺，但卻遇到我覺得最莫名其妙的護士，直接氣到跟他吵起來，一開始我詢問他前幾天有心臟科醫生來會診有說之後會再用藥，這部分的話是明天開始會使用嗎？原本只是想說順便詢問一下而已，沒想到他回說關於病況的部分要平日早上來詢問醫生，我們護士不負責做病況的講解，然後我說我只是聽前兩天的護士有提到這塊，所以想順便問一下時間，沒想到他還是一樣說護士不負責講解病況，他會再跟前兩天的護士告知，不能跟家屬講病況的事情，WTF，我就是問前兩天發生的事，這樣都不能講，而且還說前兩天的護士這樣講有問題，他會再告知他，幹不是吧，你什麼狀況都不跟家屬講才是有問題吧</p>
<p>後來輾轉又扯到說什麼病情解釋一律都是早上由醫生講解，要聽的話請早上來，而且我看你們過去一週早上都沒人來，幹不是啊，我們早上都要上班，我前兩週幾乎每天早上請假來欸，現在護士是可以這樣嗆家屬說早上不來的嗎？後來更扯，又說什麼我們當初很晚才做決定說要不要氣切，不是啊，前一天狀況好好的說隔天可以準備訓練呼吸，隔天一早就說肺部感染狀況不好，不能訓練呼吸了，然後醫生才花了十分鐘跟我們講解就建議要做氣切，我們能那麼快的做決定嗎？</p>
<p>就這樣跟他扯了二十分鐘左右，我答一句他就回一句，我真的不知道他到底是護士還是專門來氣家屬的</p>
<h5 id="晚上-6-00"><a href="#晚上-6-00" class="headerlink" title="- 晚上 6:00"></a>- 晚上 6:00</h5><p>在去看爺爺前帶著詩茵跟小紗寶去看看奶奶，今天跟奶奶問了一些爺爺小時候的事情，才知道爺爺一兩歲的時候爸爸就不見了後來就住進育幼院，好像之後又被叔公接出來，之後輾轉才在民國三十幾年的時候來到台灣，後來在台灣一直當空軍的士官長當到民國 77 年退休，退休後又在復興高中還是復興國中當了工友，但聽說因為爺爺人太好，所以被叫去做很多工作，後來感覺被欺負做了一兩年後受不了就離職了</p>
<p>另外還提到爺爺出生的年份，原本在身份證上爺爺是民國 16 年出生的，這一年原本應該是羊年，但不知道為什麼我從小到大聽到奶奶說的都是爺爺屬龍，我還以為是奶奶搞錯了，但沒想到今天一問才發現爺爺屬龍這件事是爺爺的媽媽轉述給奶奶的，所以說不定爺爺真的是晚一年出生的，但只是不知道為什麼戶口早報了一年？</p>
<p>P.S. 後來聽大姑姑說才知道爺爺以前剛來台灣的時候應該是 16 還 17 歲，但那時當兵年齡不足所以虛報到 22 歲，這樣政府才會提供房屋住</p>
<img src="./擎天紀念.jpg" style="width: 30%" />

<p>今天奶奶又拿出另一個爺爺民國六十一年獲得的獎章</p>
<br />

<p>接著就問奶奶說爺爺之後要怎麼辦？</p>
<p>現在大概就兩個方式</p>
<ol>
<li>住進呼吸病房，一個月 36000</li>
<li>安寧拔管，讓爺爺自然輕鬆的走</li>
</ol>
<p>奶奶一聽到一個月要出 36000 就還是大叫著說不可能不可能，哪有辦法出這麼多錢，要我們小孩子們分別幫出，沒想到後來奶奶竟然鬆口了，改為認同安寧拔管讓爺爺輕鬆地走比較沒有苦痛，真是意外奶奶會突然有這樣的轉變，但這樣也好，我想這樣爺爺就可以少受點苦</p>
<h5 id="晚上-11-00"><a href="#晚上-11-00" class="headerlink" title="- 晚上 11:00"></a>- 晚上 11:00</h5><p>回到家後突然接到電話結果是奶奶打來的，一接起來他竟然又說叫我先暫時不要拔管!? 他想到很重要的事情，要等我回去再商量看看，總之先不要拔管。到底又在搞什麼，他的決定果然隨時都是反反覆覆的</p>
<div style="text-align: right">2025/01/12 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/09 (四)</title>
    <url>/blog/2025/01/11/2025-01-09-%E5%9B%9B/</url>
    <content><![CDATA[<h5 id="早上-10-00"><a href="#早上-10-00" class="headerlink" title="- 早上 10:00"></a>- 早上 10:00</h5><p>早上拜訪廖阿伯，一進門就問了關於爺爺現在住院的事情，阿伯好像只問了爺爺的名字，過一會後就說爺爺現在的身體機能越來越下降了，原本應該是去年還前年的時候，就已經有個劫很難度過了，沒想到能撐到今年已經是很厲害了，然後建議我們可以去城隍廟拜拜跟城隍說爺爺的名字，住的醫院病房，然後說「如果是該老該壽讓他順利的走，如果不是讓他身體好起來 一份金紙拜託」，接著插香等兩三分鐘後再擲筊問城隍看一份金紙夠不夠，是聖筊的話就 ok，不是的話就繼續加金紙繼續擲筊問</p>
<h5 id="下午-2-00"><a href="#下午-2-00" class="headerlink" title="- 下午 2:00"></a>- 下午 2:00</h5><p>於是下午我就照這廖阿伯的指示來台北府城隍廟拜拜，一開始先拿了五柱香依序祭拜，並且跟神明們講了爺爺目前的狀況，參拜一輪後再問廖阿伯所說的問題「如果是該老該壽讓他順利的走，如果不是讓他身體好起來 一份金紙拜託」，結果沒想到我第一次擲筊就是聖筊，非常感謝城隍爺願意幫忙</p>
<p>在最後要走之前，我想說乾脆抽個簽問問城隍在爺爺昏睡的現在，身為孫子的我有什麼可以幫他做未完的心願等等，一開始擲了三次的筊都沒有成功，直到第四次才終於擲出聖筊，抽出來的是的八十四首</p>
<img src="第84首.jpg" style="width: 30%" />

<p>抽完籤後想說問問旁邊廟方的阿伯，請他幫忙解籤，跟他說了爺爺的狀況後，他突然的叫我去參加祭改，說祭改完會再有人幫忙解籤，突然稀里糊塗的我就被叫去旁邊登記祭改、付錢，接著馬上就進去內殿坐著，有一位女道士會將大家的名字、地址、請求的內容唸給城隍爺聽，請求的內容一張長長的黃色紙張，上面寫的感覺都是祭文，旁邊的工作人員還很好心的幫我把請求的事項寫上去，例如爺爺目前住在哪個醫院的哪個病房床位，奶奶身體的哪個部份不舒服，當每個人的請求都唸給城隍爺聽完後，女道士會跟我們短暫的聊聊天，有偷聽到前面的那位他似乎是丈夫想借貸去投資加密貨幣，馬上被女道士苦口婆心的說勸他不要這樣會被騙光之類的，輪到我時，他就說爺爺現在已經 98 歲高壽了，已經很長壽了，要我做好心理準備等等，感覺廟方這邊的人員其實也都蠻友善的，出殿外後有另一位男道士會在你頭上身體旁邊畫個幾圈，最後在符紙的背面蓋章燒掉，以及敲碎龍眼殼，代表敲碎厄運，就結束了這整個祭改的流程</p>
<p>結果到最後才聽廟方人員說今天解籤的師傅沒有來，禮拜六才會來，但酷的地方是他們竟然有<a href="https://fortune.yeniverse.co/?t=0">線上 AI 解籤</a>，只好自己先線上解籤詩了</p>
<img src="解籤1.png" />
<img src="解籤2.png" />

<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>在看爺爺的時候，護士提到說可以先參觀呼吸照護病房，看之後比較傾向選哪個，他們的呼吸病房分為兩個樓層，一個在四樓的 42 病房，另一個在一樓的 11 病房，都是需要呼吸器的病人居住，原本是早上的時間才能參觀的，但還好加護病房的護士人很好，馬上一通電話打過去，讓我們在看完爺爺之後剛好有時間可以去參觀一下環境，後來我們先到四樓的病房參觀，是一個大通鋪形式的排列，每排三床總共有三十床的樣子，完全沒有隔間，所以環境上感覺比較吵鬧一點，接著我們又到了一樓病房參觀，不同於四樓這邊安靜許多，每排都有牆壁隔開，參觀完一樓的環境後，出來剛好遇到另一床的家屬看到我們跟我們搭話，他說他媽媽之前住在秀傳醫院五年了，每個月的看護費要六萬多，但遇到有什麼事情的時候，醫院只會打電話說要不要送到台大醫院處理，但後來轉到這邊也已經五年了，他覺得這邊很好，一方面是看護費比較便宜只要三萬多，另一方面醫生每週會來一次看診，有什麼問題都可以跟醫生討論，沒想到第一次參觀就有善心的家屬提供資訊，另一方面也覺得他真是辛苦，照顧他媽媽已經十年了</p>
<div style="text-align: right">2025/01/11 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/16 (四)</title>
    <url>/blog/2025/01/19/2025-01-16-%E5%9B%9B/</url>
    <content><![CDATA[<h5 id="早上-10-00"><a href="#早上-10-00" class="headerlink" title="- 早上 10:00"></a>- 早上 10:00</h5><p>兩天前加護病房的護士就說爺爺的升壓藥已經停了，隨時做好可以去呼吸病房的準備，剛好今天是加護病房移到新大樓的日子，他們建議今天就把爺爺直接轉到呼吸病房，就不用到時新大樓舊大樓這樣移來移去，十點整我就準時在呼吸病房的外面等，等到大約十點半終於被叫進去，原來他們病房內部自己有電梯，難怪我在外面一直看都沒看到爺爺的病床推進去。</p>
<p>接著護理師做個簡單的環境介紹，然後是看護公司那邊的小老闆拿著契約書來簽約，感覺呼吸病房這裡的環境比加護病房好多了，比較安靜也可以自己關燈，環境不會太亮，爺爺似乎也睡得很沉發出像打呼的聲音</p>
<div style="text-align: right">2025/01/16 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/17 (五)</title>
    <url>/blog/2025/01/19/2025-01-17-%E4%BA%94/</url>
    <content><![CDATA[<p>爺爺從上個月 23 號住進醫院，到現在已經過了三個禮拜了，一開始為了呼吸道暢通才插管使用呼吸器，但插管時間久了會傷害到喉嚨、聲帶等，通常醫生不會建議插管超過一個月，如果插太長時間之後也會引起肺部感染</p>
<p>爺爺現在一樣無法睜開眼睛躺在呼吸病房，手腳偶爾會動一下，但醫生說那個是基本上是無意識的肌肉反射，目前三餐是靠著鼻胃管灌食牛奶、營養品等，另外每天擦澡、翻身都需要 24 小時看護照顧</p>
<p>醫生說爺爺因為腦中風的關係之後要清醒的機率很低，就算有機會清醒之後都要臥床了，爺爺目前身上都還插著氣管內管、鼻胃管等，這些維生設備插著都很痛苦，所以我覺得現在對爺爺最好的方式是安寧拔管，之後安寧小組會召開會議討論拔管的時間、以及拔管後如何用止痛藥讓爺爺比較輕鬆，我覺得爺爺年紀已經夠長壽了，繼續等下去也只能維持這樣無法睜開眼睛、插著管下床走動只能被別人餵食的狀態，這樣實在太辛苦了，不如最後就同意決定拔管讓爺爺安祥平安的去天上吧</p>
<img src="./to_奶奶.jpg" style="width: 50%" />

<p>寫給奶奶勸說他接受拔管的建議信</p>
<div style="text-align: right">2025/01/17 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/18 (六)</title>
    <url>/blog/2025/01/19/2025-01-18-%E5%85%AD/</url>
    <content><![CDATA[<h5 id="下午-4：00"><a href="#下午-4：00" class="headerlink" title="- 下午 4：00"></a>- 下午 4：00</h5><p>上週抽到的籤詩還沒有找師傅解，剛好今天是星期六想說解籤師傅應該在了，於是再度去台北府城隍廟，一到那邊先問櫃台的小姐解籤師傅是否有上班，沒想到他認得我上週來過，他說師傅現在正在祭改中，要等晚一點，於是我就先參拜了一輪跟神明們說爺爺目前的最新狀況，上週爺爺人還在加護病房但這週狀況有比較穩定所以下轉到呼吸病房，但目前住院接近一個月，爺爺還是昏迷臥床中，身上插著鼻胃管、氣管這些維生的儀器</p>
<p>拜完後，我準備去找解籤的霍師傅，沒想到是霍師傅先發現我是來問解籤的人主動來找我，霍師傅長的像一個慈眉善目的老爺爺，我馬上拿出籤詩並提說上週在抽籤時心中想的問題，霍師傅很快的就開始解籤，這首詩要分成上下半部份來看，上半部的兩句:<b>「箇中事緒更紛然，當局須知一著先」</b>，是指現在的狀況混亂，但你需要在一開始就有堅定的想法，接著下半部的兩句: <b>「長舌婦人休酷聽，力行禮義要心堅」</b>是補充前兩句的說明，在這個過程中很多人會有不同的意見想法，但你必須堅定相信自己該做的事</p>
<p>我跟霍師傅簡略的說明一下爺爺這一個月來的狀況、家人的想法還有我的想法，接著霍師傅跟我說解籤不是這樣聽他說完就結束了，還需要我去擲筊問城隍爺確認他解籤的說明是不是正確的，以及如果覺得心中還是很混亂的話可以用有邏輯的方式問城隍爺，例如：問說爺爺現在是不是已經年紀到了一生功德圓滿了、或是問說爺爺是不是可以順利度過這一關，分別問不同的問題再擲筊看結果是什麼，另外還可以擲筊問城隍爺除了這支簽以外是不是還有第二支、第三支簽要指示，如果擲出聖筊的話就代表還有下一支簽詩，最後霍師傅還說他人都在這裡，等會抽籤、擲筊有什麼問題隨時都可以找他，真是會給人心靈支持的師傅啊</p>
<p>於是我向城隍爺擲筊詢問的問題是：</p>
<ol>
<li>根據霍師傅對籤詩的解說以及我自己的理解，我覺得爺爺年紀已經夠大了，目前爺爺意識昏迷中風插著管子，餵食都要靠著鼻胃管非常辛苦，而且插管久了還會有反覆感染的機會，所以弟子打算幫爺爺進行安寧拔管，但奶奶卻不知道什麼原因一直反對，弟子是不是應該要堅持自己的信念，在下週或是近期拔管呢？</li>
</ol>
<div style="margin-top: -15px; margin-bottom: 20px"><b>結果：第一次擲就擲出聖筊</b></div>

<ol start="2">
<li>爺爺這個年紀這麼大了，是不是該是離開到天上的時候了，如果是的話再請城隍幫忙讓爺爺的最後一程走的安詳平靜，順利帶爺爺到天上生活、修行</li>
</ol>
<div style="margin-top: -15px; margin-bottom: 20px"><b>結果：一樣第一次擲就是聖筊</b></div>

<ol start="3">
<li>弟子瞭解了，那城隍爺還有什麼要提示弟子的事情，或是爺爺還有什麼未完的心願，需要抽第二支簽嗎？</li>
</ol>
<div style="margin-top: -15px; margin-bottom: 20px"><b>結果：兩個反面的笑筊</b></div>

<p>然後我去跟霍師傅說城隍爺指示的結果，他人很好的提供建議說如果奶奶還是堅持不拔管的話，可以叫他自己來問城隍爺，以及跟我說爺爺可能時間到了要做好心理準備，我說沒問題的啦事情已經過一個月了，早就做好心理準備了!</p>
<div style="text-align: right">2025/01/18 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/19 (日)</title>
    <url>/blog/2025/01/19/2025-01-19-%E6%97%A5/</url>
    <content><![CDATA[<h5 id="早上-11：30"><a href="#早上-11：30" class="headerlink" title="- 早上 11：30"></a>- 早上 11：30</h5><p>沒想到禮拜天胸腔主治的蔡醫生竟然會出現，我發現他講話很實在直接而且還會用一般人能理解的比喻解釋病況，說明了爺爺目前的狀況如下：</p>
<p>一. 爺爺是多發性腦中風，提到<a href="https://openchang.tw/halamic-stroke/">丘腦</a>還有某個腦都受損，把大腦想像成台北捷運系統，爺爺現在壞掉的就是台北車站，所以四肢的運動神經、意識方面都受到影響，就爺爺現在腦部受損的狀況來看，幾乎是不太可能清醒</p>
<p>二. 之後的走向分為兩種，分別是拔管跟撤管</p>
<ul>
<li><p>第一種拔管指的是經由呼吸訓練後，判斷爺爺符合可以自主呼吸的條件後再拔除氣管內管，但醫生說爺爺現在還有肺部感染狀況加上以爺爺現在的體力要走到訓練後順利拔管這一步很困難，因此醫生說之後最大的可能性是隨著時間越久，遲早會有細菌感染的狀況，可能是肺部或是尿道，時間大約會是一兩個月後，到時會引發<a href="https://www.commonhealth.com.tw/article/87375">敗血性休克</a>（應該是這個名詞），到那時如果不使用升壓藥的話很快就會過世，另外我也問了到時如果引起感染狀況，是不是可以幫病人打止痛藥緩和痛苦呢？但醫生說基本上肺部或是尿道的感染都是內部的發炎現象不會感到痛，所以也不需要打止痛藥</p>
</li>
<li><p>第二種是安寧撤管，也就是經家屬同意後，再經由兩位專科醫生的同意撤除氣管內管，這部分的話醫生說等到我們家屬都一致同意後，他會再找之前神經內科的林醫師一起評斷，但他也說到符合安寧撤管的條件寫的有點灰色地帶，條文上說是要末期可能一週內就會過世的病人才符合條件，就爺爺現在的狀況是不符合的，但總之等到我們家屬都同意後，他會再約林醫師評估安寧撤管</p>
</li>
</ul>
<p>最後我問了關於氣管可以插多久的問題，醫生提到氣切的部分，主要是氣切可以繞過喉嚨會引起咳嗽反射這一部份讓病人不會那麼不舒服，以及避免口腔潰爛，但他有說以爺爺目前的狀況就算做氣切，之後也是不可避免的會有感染問題</p>
<p>今天有帶爺爺之前睡前都會聽的小收音機過來給他聽，但他的收訊太弱了一直發出雜音，在病房裡根本沒辦法聽，所以後來我直接下載電台 app 給爺爺聽，今天給他聽的新聞是民進黨打算罷免國民黨立委、還有民眾黨的主席重選，但我想爺爺應該不知道民眾黨是什麼</p>
<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>今天是奶奶第三次去看爺爺了，一到爺爺的病床前，奶奶從他的塑膠袋包包裡拿出今天的特殊工具 - 塑膠手套，看來是怕被細菌感染特地準備的，接著奶奶繼續不斷叫著 ㄔㄡ ˋ ㄌㄠ ˋ ㄍㄠ ˇ 張開眼睛講話，這是我從小到大一直聽到他叫爺爺的方式，今天還是一樣到處拍來拍去、按來按去，即使爺爺手上戴著乒乓拍的拘束，他還是不斷地把爺爺的手抬起來對著手掌的穴道按來按去，邊不斷地大叫爺爺手部的力氣超大一直拉他把他拉到手都痛了，連中風生病的爺爺力氣都可以比你大… 後來危險的是他一直大力拍打著爺爺的胸前，拍到監測儀器都亮起紅燈發出嘟嘟的警示音，原來爺爺的心跳被奶奶拍到一度跳上每分鐘 150、170 下，我趕緊叫他住手才恢復過來，之後我請看護幫忙爺爺抽抽痰，當在抽痰的時候爺爺臉部的肌肉都緊縮在一起、眼睛緊閉著，我每次看到都覺得躺在這最痛苦的就是抽痰這時吧，我希望讓奶奶看到爺爺躺在這不是一直都是這麼寧靜的，在家屬的探病時間之外有無數看不到的痛苦需要忍耐著</p>
<p>探完病後回到奶奶家，我還是盡力地勸說奶奶接受爺爺拔管這件事，「你剛剛也看到了吧 爺爺腦部受損嚴重 沒辦法睜開眼睛醒過來了，我們現在應該是時候放手，讓爺爺不用再忍受痛苦，最後平安喜樂的去天堂了」，雖然奶奶希望過年後再拔管，但我跟他說不要再等那麼久了，過年後又要等一週，該是放手的時候了，奶奶才不情願地揮揮手願意讓我在年前向醫生提出拔管的要求</p>
<div style="text-align: right">2025/01/19 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/21 (二)</title>
    <url>/blog/2025/01/22/2025-01-21-%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="晚上-7-00"><a href="#晚上-7-00" class="headerlink" title="- 晚上 7:00"></a>- 晚上 7:00</h5><p>昨天晚上來看爺爺的時候就有跟護士提出安寧拔管的意願，很快今天晚上蔡醫生就來病房跟我們討論後續的狀況，原來安寧拔管並沒有這麼簡單，之前以為拔管後就可以不用再忍受痛苦，很快的就會到天上，但醫生提醒有另一種狀況是拔管完後可能可以自主呼吸，而健保規定拔管後的病人只能繼續在呼吸病房再住五天，五天之後就需要回家或轉介到護理之家，之前完全沒想過還有這種狀況，如果真的要拔管的話，就要把之後有可能要轉介的機構也想好，這樣的話目前只好先暫時維持原樣，等到研究完護理之家的資訊後，再看下一步該怎麼走</p>
<p>另外醫生也提出如果我們暫時不進行安寧拔管，也可以考慮之後是否同意某些治療的措施，例如：使用抗生素與否、要不要輸血以及氣管堵塞導致需要重新插管時要不要同意換管等，這部分我們又需要些時間想想了</p>
<p>今天跟照顧爺爺的看護聊天，他原來是大陸四川來的，家人兒女都在大陸，只有他自己在台灣，而且發現他們真的是辛苦血汗的工作，他每天上班的時間是中午 12 點到晚上 12 點，要同時照顧七個病人，月休八天，但每月薪資竟然只有四萬，真的很辛苦，公司提供的宿舍一房一廳就需要擠三個人打地鋪一起睡，而且他已經是做了十幾年的資深員工，結果薪資才比隔壁新進來的每月多一千，真心敬佩他們這種任勞任怨的精神，也同時還維持著開朗樂觀的態度</p>
<h4 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h4><ul>
<li><a href="https://ec.ltn.com.tw/article/breakingnews/2875318">《大名醫開講》張承能：當有家屬昏迷時 你該作什麼決定？</a></li>
<li><a href="https://www.twreporter.org/a/good-death-myth-respirator-extubation">1%的奇蹟，要付出什麼代價？呼吸器決策資訊網，為拔不拔管的生命難題找答案</a></li>
<li><a href="https://www.pulivh.gov.tw/UploadFiles/WebFiles/WebPagesFiles/Files/007d452b-3275-42f8-9d70-5862557468e6/%E6%B1%BA%E7%AD%96%E8%BC%94%E5%8A%A9%E5%B7%A5%E5%85%B7_%E6%88%91%E7%9A%84%E8%A6%AA%E4%BA%BA%E8%99%95%E6%96%BC%E5%91%BC%E5%90%B8%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B9%8B%E7%94%9F%E5%91%BD%E6%9C%AB%E6%9C%9F%E9%9A%8E%E6%AE%B5%EF%BC%8C%E6%98%AF%E5%90%A6%E9%81%B8%E6%93%87%E6%92%A4%E9%99%A4%E6%B0%A3%E7%AE%A1%E5%85%A7%E7%AE%A1%EF%BC%9F.pdf">我的親人處於呼吸器使用之生命末期階段，是否選擇撤除氣管內管？</a></li>
<li><a href="https://sdm.cgh.org.tw/DL/03_2.pdf">我的家人是疾病末期病人，依賴呼吸器維持生命，接下來我該怎麼辦?</a></li>
<li><a href="https://service.mohw.gov.tw/MOHW_Upload/dmc_history/UpFile/Period51/1_%E5%8F%B0%E7%81%A3%E5%91%BC%E5%90%B8%E5%99%A8%E9%95%B7%E6%9C%9F%E4%BD%BF%E7%94%A8%E6%A6%82%E6%B3%81.pdf">台灣呼吸器長期使用概況</a></li>
<li><a href="https://www.ilong-termcare.com/Article/Detail/93">護理之家、養護機構、安養機構差異在哪裡？一張圖表告訴你</a></li>
</ul>
<h5 id="護理之家、長照中心資訊"><a href="#護理之家、長照中心資訊" class="headerlink" title="護理之家、長照中心資訊"></a>護理之家、長照中心資訊</h5><ul>
<li><a href="https://health.gov.taipei/News.aspx?n=B283D71AA0A7D98A&sms=EDD21D8B4B037BC3">台北市護理之家資訊(台北市衛生局)</a></li>
<li><a href="https://www.care-old.org/taipei/%E6%9D%BE%E5%B1%B1%E5%8D%80/">台北市松山區長期照顧中心列表</a></li>
<li><a href="https://wwwv.tsgh.ndmctsgh.edu.tw/unit/20105/26629">三軍總醫院松山分院附設護理之家</a></li>
<li><a href="https://www.airltc.com/org/info/1830">鵬程護理之家</a></li>
<li><a href="http://yao4343.apponl.com/Introductions.htm">臺北市私立康壯老人長期照顧中心(養護型)</a></li>
<li><a href="https://www.care-old.org/taipei/%E8%87%BA%E5%8C%97%E5%B8%82%E7%A7%81%E7%AB%8B%E4%BB%81%E4%BB%81%E8%80%81%E4%BA%BA%E9%95%B7%E6%9C%9F%E7%85%A7%E9%A1%A7%E4%B8%AD%E5%BF%83/">臺北市私立仁仁老人長期照顧中心(養護型)</a></li>
</ul>
<h5 id="附註"><a href="#附註" class="headerlink" title="附註"></a>附註</h5><p>在找護理之家的資料時，發現有些長照中心竟然還直接<a href="https://dosw.gov.taipei/News_Content.aspx?n=191A124E706A00D5&sms=B48E01C75277EF9B&s=7C02E5309DC36CDD">違法被公告</a>，去 <a href="https://maps.app.goo.gl/QHDjCdfKUgYfgtoEA">google map 評論</a>看到也是一片抨擊，真是恐怖</p>
<div style="text-align: right">2025/01/21 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>2025/01/23 (四)</title>
    <url>/blog/2025/01/23/2025-01-23-%E5%9B%9B/</url>
    <content><![CDATA[<h5 id="To-奶奶"><a href="#To-奶奶" class="headerlink" title="To 奶奶"></a>To 奶奶</h5><p>前幾天有跟醫生提出拔管的需求了，但拔管後只能在醫院再住五天，之後就必須要回家照顧或轉到護理之家，這附近的護理之家我都問過了都沒有位置要排很久，所以目前會讓爺爺維持現在的狀態先在呼吸病房待著</p>
<p>另外爺爺之後一直臥床的話，一兩個月後八成會有肺部或是尿道的感染，正常來說醫院會使用抗生素治療，但即使暫時治好了，之後感染的狀況一樣會反覆出現，所以我打算簽署拒絕使用抗生素、輸血的同意書，這樣當下次有感染症狀時，爺爺會比較自然地離開，不用一直插管臥床忍受痛苦，所以這張同意書需要你、我跟大姑姑都簽名</p>
<h5 id="詢問護理之家"><a href="#詢問護理之家" class="headerlink" title="詢問護理之家"></a>詢問護理之家</h5><ol>
<li><p>松山護理之家<br>沒想到打電話過去他们說現在都滿床，後面排隊等待的人數已經上百人了，但還是先詢問了一下價錢<br>單人房：60000<br>雙人房：49000<br>五人房：42000<br>如果有管路，例如鼻胃管要加 1500，每日灌食牛奶加 100，以及尿布、濕紙巾之類的都要自備</p>
</li>
<li><p>康壯老人<br>剩一床，打過去說他們今天很忙叫我之後再打過去</p>
</li>
<li><p>仁仁老人<br>男床剩兩床，留完基本資料後說晚點主任再打過來，後來主任打過來說以爺爺現在的狀況他們這種不夠專業無法接收，要我去找護理之家等級的</p>
</li>
<li><p>鵬程護理之家<br>一開始是在長照網上加 line 詢問的，上面回訊息的人很好講解各種資訊，最後一樣還是需要直接打電話到鵬程問，他們一樣現在滿床，後面等的人很多，說現在對我最好的方法是等待之後拔管後，在出院前的一兩個禮拜再打電話過來排床位</p>
</li>
</ol>
<h5 id="詢問軍人公墓"><a href="#詢問軍人公墓" class="headerlink" title="詢問軍人公墓"></a>詢問軍人公墓</h5><ol>
<li>樹林公墓</li>
</ol>
<ul>
<li>新的照順序排，無法自己挑塔位的方向</li>
<li>舊的要等別人搬出，至於方位可以自己挑看有沒有</li>
</ul>
<ol start="2">
<li>南港軍人公墓</li>
</ol>
<ul>
<li>需要攜帶榮民證、死亡證明書正本</li>
<li>需要申請人的身分證、印章</li>
<li>室內有空位可以自己選方位，但需要當天去看才知道有哪些空位</li>
<li>戶外區不能選位置</li>
<li>需在死亡的 60 天內辦理</li>
</ul>
<div style="text-align: right">2025/01/23 筆</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>CORS Debug (1) - 網頁快取導致的 CORS 問題</title>
    <url>/blog/2025/04/13/cors-debug-1-%E7%B6%B2%E9%A0%81%E5%BF%AB%E5%8F%96%E5%B0%8E%E8%87%B4%E7%9A%84-cors-%E5%95%8F%E9%A1%8C/</url>
    <content><![CDATA[<h6 id="此為-CORS-Debug-系列文章-第-1-篇："><a href="#此為-CORS-Debug-系列文章-第-1-篇：" class="headerlink" title="此為 CORS Debug 系列文章 - 第 1 篇："></a>此為 <strong>CORS Debug</strong> 系列文章 - 第 1 篇：</h6><ol>
<li><a href="/blog/2025/04/13/cors-debug-1-網頁快取導致的-cors-問題/" target="_blank">CORS Debug (1) - 網頁快取導致的 CORS 問題</a></li>
<li><a href="/blog/2025/04/17/cors-debug-2-src-與-crossorigin-在-img-元素中的順序導致-cors-error/" target="_blank">CORS Debug (2) - src 與 crossOrigin 在 img 元素中的順序導致 CORS error</a></li>
</ol>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>最近做到一個在網頁上展示圖片的功能，簡單來說就是點擊右側的圖片庫，左邊的主畫面可以展示大圖，如下圖所示，這是一個非常簡單的功能，但到最後發現這跟 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Guides/CORS">CORS</a> 有密切的關係，下面我們來一步步探討看看</p>
<div style="display: flex; justify-content: center;">
  <img src="/blog/2025/04/13/cors-debug-1-網頁快取導致的-cors-問題/demo.png" />
</div>

<span id="more"></span>

<h2 id="需求-下載圖片功能"><a href="#需求-下載圖片功能" class="headerlink" title="需求 - 下載圖片功能"></a>需求 - 下載圖片功能</h2><p>除了展示圖片之外，還需要能夠個別下載圖片的功能，點擊圖片庫右上角的 <strong>下載</strong> 可以將圖片載下來，下載圖片的程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">downloadImage</span> = <span class="keyword">async</span> (<span class="params">image: Image</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(image.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br><span class="line">    <span class="keyword">const</span> urlObject = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    a.<span class="property">href</span> = urlObject;</span><br><span class="line">    a.<span class="property">download</span> = image.<span class="property">filename</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);</span><br><span class="line">    a.<span class="title function_">click</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">    <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(urlObject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">`下載失敗: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="問題-無法下載圖片"><a href="#問題-無法下載圖片" class="headerlink" title="問題 - 無法下載圖片"></a>問題 - 無法下載圖片</h2><p>當點擊下載按鈕後，登愣！圖片竟然無法下載！</p>
<div style="display: flex; justify-content: center;">
  <img src="./download-fail.png" />
</div>

<div style="display: flex; justify-content: center;">
  <img src="./download-cors-error.png" />
</div>

<p>這時打開 DevTools 中的 console 可以看到下載圖片失敗的原因是 CORS 錯誤</p>
<p>&#x3D;&gt; 為什麼會出現 CORS 錯誤呢？這其實跟圖片資源所在的後端伺服器息息相關，就我遇到的狀況來說，這個網頁顯示的圖片都儲存在 Amazon S3 上，而取得 Amazon S3 裡的資源時需要遵守他們的 <strong>CORS</strong> 規範</p>
<h4 id="1-Amazon-S3-上的-CORS-規範"><a href="#1-Amazon-S3-上的-CORS-規範" class="headerlink" title="1. Amazon S3 上的 CORS 規範"></a>1. Amazon S3 上的 CORS 規範</h4><p>當請求 Amazon S3 中的資源時，基本上分為兩種獲取方式，一個是 <strong>非跨域請求</strong>、另一個是 <strong>跨域請求</strong> 也就是所謂的 <strong>CORS</strong></p>
<h5 id="非跨域請求"><a href="#非跨域請求" class="headerlink" title="- 非跨域請求"></a>- 非跨域請求</h5><p>當 <code>img</code> 元素單純只有 <code>src</code> 的網址時，會對 Amazon S3 中的圖片發出 <strong>非跨域請求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="跨域請求-CORS"><a href="#跨域請求-CORS" class="headerlink" title="- 跨域請求 (CORS)"></a>- 跨域請求 (CORS)</h5><p>當 <code>img</code> 元素額外加上 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Attributes/crossorigin">crossorigin</a> 的屬性時，會對 Amazon S3 中的圖片發出 <strong>跨域請求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>當瀏覽器發出 <strong>跨域請求</strong> 的時候 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Headers/Origin#%E6%8F%8F%E8%BF%B0">會在 Request headers 中額外加上 Origin 的資訊</a>，讓資源所在的伺服器知道是哪個網站在請求這項資源</p>
<div style="display: flex; justify-content: center;">
  <img src="./request-origin.png" />
</div>

<p>在 <a href="https://stackoverflow.com/a/32887912/10090927">S3 - Access-Control-Allow-Origin Header</a> 的討論文中提到：</p>
<blockquote>
<p>If your request doesn’t specify an “Origin” header, S3 won’t include the CORS headers in the response. This really threw me because I kept trying to curl the files to test the CORS but curl doesn’t include Origin.</p>
</blockquote>
<p>這句話指的是當 Request headers 帶有 “Origin” 欄位時，Amazon S3 回覆的 Response headers 才會多增加 CORS header 相關的欄位，CORS header 相關的欄位大致上有三個</p>
<ul>
<li><code>Access-Control-Allow-Headers</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
<li><code>Access-Control-Allow-Origin</code></li>
</ul>
<p>其中的 <code>Access-Control-Allow-Origin</code> 需要回傳請求資源網站符合的網址，才代表 S3 認同你這個網站通過 CORS 規範，有權限取得 S3 裡面的資源</p>
<p>所以當我們在 DevTools 中查看 Response headers 中有 <code>Access-Control-Allow-Origin: *</code> 的欄位時，代表著這張圖片是以 <strong>跨域請求 (CORS)</strong> 的方式獲得的</p>
<div style="display: flex; justify-content: center;">
  <img src="./origin-star.png" />
</div>

<p>P.S. 在這篇文章中，<code>img.src</code> 圖片資源的網址都是 <code>https://rjzdhlvuuafqvgoyticm.supabase.co/</code> 開頭的，實際上我遇到無法下載圖片問題的時候後端伺服器是 Amazon S3，但這裡改用 <a href="https://supabase.com/">supabase</a> 模擬 Amazon S3 Response headers 回傳的行為，主要是考慮到這樣可以更靈活的根據前端傳遞的 url，設置不同的 Response headers 來做測試</p>
<h4 id="2-Amazon-S3-上的快取機制-cache"><a href="#2-Amazon-S3-上的快取機制-cache" class="headerlink" title="2. Amazon S3 上的快取機制 (cache)"></a>2. Amazon S3 上的快取機制 (cache)</h4><p>圖片下載失敗的原因之一除了 Amazon S3 上的 <strong>CORS</strong> 規範外，另外一個重點是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Guides/Caching">網頁的快取機制(cache)</a></p>
<p>在這個範例中，我在後端的伺服器設定了圖片的快取為 <code>Cache-Control: public max-age=30</code>，這代表當從伺服器獲取圖片後的 30s 內，如果再度對圖片進行請求都會從瀏覽器的快取中拿，而不會真正發出網路請求到伺服器</p>
<h5 id="第一次請求"><a href="#第一次請求" class="headerlink" title="- 第一次請求"></a>- 第一次請求</h5><p>第一次請求時直接從伺服器取得圖片，而且由於 Response headers 設置了 <code>Cache-Control: public max-age=30</code>，所以後續 30s 內對同一張圖片的請求都會從瀏覽器的快取中取得</p>
<div style="display: flex; justify-content: center;">
  <img src="./cache-control-30s.png" />
</div>

<h5 id="後續請求"><a href="#後續請求" class="headerlink" title="- 後續請求"></a>- 後續請求</h5><p>在 30s 內對同一張圖片的後續請求，由於快取尚未過期，所以可以看到圖片來源自 <strong>瀏覽器本身的快取(memory cache)</strong></p>
<div style="display: flex; justify-content: center;">
  <img src="./memory-cache.png" />
</div>

<h4 id="小結-為什麼下載圖片觸發了-CORS-錯誤？"><a href="#小結-為什麼下載圖片觸發了-CORS-錯誤？" class="headerlink" title="小結 - 為什麼下載圖片觸發了 CORS 錯誤？"></a>小結 - 為什麼下載圖片觸發了 CORS 錯誤？</h4><p>最初畫面上載入圖片時的寫法是這樣的，這種寫法是用 <strong>非跨域請求</strong> 的方式取得 Amazon S3 上的圖片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-fetch-獲取-CORS-的資源"><a href="#使用-fetch-獲取-CORS-的資源" class="headerlink" title="使用 fetch 獲取 CORS 的資源"></a>使用 fetch 獲取 CORS 的資源</h5><p>在 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Guides/CORS">跨來源資源共享（CORS）</a>的頁面敘述如下：</p>
<blockquote>
<p>出於安全原因，瀏覽器限制從腳本發起的跨來源 HTTP 請求。例如，fetch() 和 XMLHttpRequest 遵循同源政策。這意味著，使用這些 API 的 Web 應用程序只能請求與加載該應用程序的相同來源的資源，除非來自其他來源的回應包含正確的 CORS 標頭。</p>
</blockquote>
<p>這裡所說的 <strong>包含正確的 CORS 標頭</strong> ，以我們的範例來說指的就是用 <strong>跨域請求</strong> 的方式取得 Amazon S3 上的圖片時，Response headers 需要回傳<code>Access-Control-Allow-Origin: *</code></p>
<p>所以整個觸發 CORS 錯誤的過程是這樣的：</p>
<ol>
<li><p>一開始進入畫面時，瀏覽器就下載並快取了 <strong>非跨域請求</strong> 方式的圖片</p>
</li>
<li><p>後續下載圖片使用 <code>fetch</code> 請求，由於我們網站自身的網址與 Amazon S3 所在圖片伺服器的網址<a href="https://developer.mozilla.org/zh-TW/docs/Web/Security/Same-origin_policy">不同源</a>，代表 <code>fetch</code> 需要以 <strong>跨域請求</strong> 的方式獲取圖片</p>
</li>
<li><p>此時因為已經有步驟 1. 中以 <strong>非跨域請求</strong> 方式快取的圖片了，瀏覽器直接以快取回應，但之前快取的 <strong>非跨域請求</strong> 並沒有 <strong>包含正確的 CORS 標頭</strong> 也就是 <code>Access-Control-Allow-Origin: *</code></p>
</li>
<li><p>結果導致 CORS 錯誤</p>
</li>
</ol>
<p>此時在 Chrome DevTools 中可以看到 <code>fetch</code> 發出的 request 顯示 <a href="https://developer.chrome.com/docs/devtools/network/reference?utm_source=devtools&hl=zh-cn#provisional-headers">Provisional headers are shown…</a> 代表 <code>fetch</code> 圖片的請求並沒有真正的傳遞到伺服器，而是使用到了之前 <strong>非跨域請求</strong> 方式取得的圖片快取</p>
<div style="display: flex; justify-content: center;">
  <img src="./provisional-header.png" />
</div>

<h2 id="解決方式-如何讓圖片下載成功？"><a href="#解決方式-如何讓圖片下載成功？" class="headerlink" title="解決方式 - 如何讓圖片下載成功？"></a>解決方式 - 如何讓圖片下載成功？</h2><p>既然知道了原因是 <code>fetch</code> 下載圖片時用到 <strong>非跨域請求</strong> 方式的快取圖片，可以想到有以下幾種解決方式：</p>
<h4 id="1-fetch-時指定-cache-不使用快取圖片"><a href="#1-fetch-時指定-cache-不使用快取圖片" class="headerlink" title="1. fetch 時指定 cache 不使用快取圖片"></a>1. fetch 時指定 cache 不使用快取圖片</h4><p>在使用 <code>fetch</code> 時可以設置參數 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/cache">cache</a>，指定請求資源時是否覆用快取，以我們的例子來說，目的是在 <code>fetch</code> 的時候不要用到原本的快取，所以適合設定的值是 <code>no-store</code> 或 <code>reload</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(image.<span class="property">url</span>, &#123; <span class="attr">cache</span>: <span class="string">&#x27;no-store&#x27;</span> &#125;); <span class="comment">// or &#x27;reload&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-設定-Vary-Origin"><a href="#2-設定-Vary-Origin" class="headerlink" title="2. 設定 Vary: Origin"></a>2. 設定 Vary: Origin</h4><p>Response headers 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Vary">Vary</a> 欄位，作用是即使同一個 url 但只要 Request headers 的某個欄位與 <code>Vary</code> 中設定的字串中有不一致的地方，那麼這個 Request 就不會使用到快取而是會真正的向伺服器發出請求，有點難用文字說明，以下用例子來解釋比較清楚：</p>
<ol>
<li><p>一進到頁面時 <code>&lt;img src=&quot;...&quot; /&gt;</code> 的元素讓瀏覽器前往伺服器下載圖片，此時的 Request headers 由於是 <strong>非跨域請求</strong> 所以並沒有攜帶 <code>Origin: localhost:8081</code> 這樣的欄位，接著瀏覽器在下載完圖片後以 <strong>非跨域請求</strong> 方式將圖片快取起來</p>
</li>
<li><p>接著點擊下載按鈕呼叫 <code>fetch</code> 請求圖片時，由於網站本身的網址與圖片所在的網址是非同源的，因此下載圖片的行為是 <strong>跨域請求</strong>，會在 Request headers 加上 <code>Origin: localhost:8081</code></p>
</li>
<li><p>第 1 項快取的圖片在 Request headers 中 <strong>沒有</strong> <code>Origin: localhost:8081</code>，第 2 項快取的圖片在 Request headers 中 <strong>有</strong> <code>Origin: localhost:8081</code></p>
</li>
<li><p>當執行 <code>fetch</code> 時，由於原先快取的 Request headers 跟目前請求的 Request headers 其 <code>Origin</code> 欄位的值不一樣，而 <code>Vary: Origin</code> 的設定在此時會判斷 <code>Origin</code> 的值 <strong>改變了</strong>，就不會覆用原先的快取，而是前往伺服器 <strong>跨域請求</strong> 圖片</p>
</li>
</ol>
<ul>
<li>第 1 項的 <code>&lt;img src=&quot;...&quot; /&gt;</code> 是沒有 <code>Origin</code> 欄位的 <strong>非跨域請求</strong>，但後端伺服器設定 Response headers 帶有 <code>Vary: Origin</code></li>
</ul>
<div style="display: flex; justify-content: center; margin-top: -1.2em">
  <img src="./vary-origin-first.png" />
</div>

<ul>
<li>第 2 項 <code>fetch</code> 是帶有 <code>Origin</code> 欄位的 <strong>跨域請求</strong>，判斷 <code>Origin</code> 欄位的值改變了，所以不會覆用快取而是對伺服器發出真正的請求，順利取得 <code>Access-Control-Allow-Origin: *</code></li>
</ul>
<div style="display: flex; justify-content: center; margin-top: -1.2em">
  <img src="./vary-origin-second.png" />
</div>

<p>順帶一提在 <a href="https://fetch.spec.whatwg.org/#cors-protocol-and-http-caches">fetch 規範中</a> 剛好有一段就完美的解釋我們所遇到的問題，以及如何使用 <code>Vary: Origin</code> 解決</p>
<blockquote>
<p>In particular, consider what happens if <code>Vary</code> is not used and a server is configured to send <code>Access-Control-Allow-Origin</code> for a certain resource only in response to a CORS request. When a user agent receives a response to a non-CORS request for that resource (for example, as the result of a navigation request), the response will lack <code>Access-Control-Allow-Origin</code> and the user agent will cache that response. Then, if the user agent subsequently encounters a CORS request for the resource, it will use that cached response from the previous non-CORS request, without <code>Access-Control-Allow-Origin</code>.</p>
</blockquote>
<h4 id="3-crossOrigin-’anonymous’"><a href="#3-crossOrigin-’anonymous’" class="headerlink" title="3. crossOrigin&#x3D;’anonymous’"></a>3. crossOrigin&#x3D;’anonymous’</h4><p>前面兩種方式在第一次進入頁面時就向伺服器拿到了 <strong>非跨域請求</strong> 的圖片，而之後 <code>fetch</code> 時為了避免覆用快取導致 CORS error 又向伺服器 <strong>跨域請求</strong> 了一次圖片，這等於我們花時間向伺服器拿了兩次一模一樣的圖片，完全沒有使用到快取的好處</p>
<p>換個方向想，如果 <code>fetch</code> 時需要 <strong>跨域請求</strong> 圖片的話，那為何不一開始進入頁面的時候就直接 <strong>跨域請求</strong> 呢？這就是 <code>crossOrigin=&#39;anonymous&#39;</code> 的作用</p>
<p>將 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Attributes/crossorigin">crossOrigin</a> 設置成 <code>crossOrigin=&#39;anonymous&#39;</code> 或是 <code>crossOrigin=&#39;&#39;</code> 是一樣的，代表需要以 <strong>跨域請求</strong> 的方式獲取圖片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在這篇文章的範例中，<code>fetch</code> 下載圖片時需要送出的是 <strong>跨域請求</strong>，但卻覆用到一開始 <strong>非跨域請求</strong> 的圖片快取，所以才引起 CORS 錯誤。接著提出了三個想法解決，最終採用在 <code>img</code> 元素設置 <code>crossOrigin=&#39;anonymous&#39;</code> 屬性的方式讓一進入頁面時就用 <strong>跨域請求</strong> 的方式快取圖片，這樣的方式可以覆用每次的圖片快取又可以解決 CORS 錯誤的問題</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p><a href="https://github.com/bcjohnblue/react-image-cors">範例程式碼 repo</a><br><a href="https://bcjohnblue.github.io/react-image-cors/" target="_blank">線上 Demo</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a href="https://blog.huli.tw/2018/08/18/cors-is-hard/">原來 CORS 沒有我想像中的簡單</a></li>
</ol>
<p>huli 大大寫的文章，跟這篇文章遇到的問題非常類似，都是讀取到原先瀏覽器快取住的檔案導致 CORS error</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</title>
    <url>/blog/2025/05/04/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-6-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A2%BA%E7%9A%84%E6%B8%B2%E6%9F%93%E9%80%8F%E6%98%8E%E7%B2%92%E5%AD%90%EF%BC%9F/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-6-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-6-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 6 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 6 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前五篇的系列文章讓我們理解 Three.js 中物體的遠近關係是如何決定的，今天這篇文章藉由 <a href="https://threejs-journey.com/">Three.js journey - lesson particles</a> 這門課程中渲染粒子系統的範例，學習要怎麼正確的渲染粒子使其前後呈現的順序是正確的</p>
<span id="more"></span>

<h2 id="渲染粒子系統"><a href="#渲染粒子系統" class="headerlink" title="渲染粒子系統"></a>渲染粒子系統</h2><p>這裡先貼上粒子系統的範例程式碼 - <a href="https://github.com/bcjohnblue/threejs-particles">threejs-particles</a>，下面的這段程式碼會生成 5000 個透明的粒子顯示在畫面上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ParticleSystem</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">experience</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">experience</span> = experience;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scene</span> = experience.<span class="property">scene</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setGeometry</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setMaterial</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setPoints</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setGeometry</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">geometry</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line">    <span class="keyword">const</span> positions = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">3</span>; i++) &#123;</span><br><span class="line">      positions[i] = (<span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">geometry</span>.<span class="title function_">setAttribute</span>(</span><br><span class="line">      <span class="string">&#x27;position&#x27;</span>,</span><br><span class="line">      <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(positions, <span class="number">3</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setMaterial</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> textureLoader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line">    <span class="keyword">const</span> particleTexture = textureLoader.<span class="title function_">load</span>(<span class="string">&#x27;/textures/particles/2.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">      <span class="attr">size</span>: <span class="number">0.1</span>,</span><br><span class="line">      <span class="attr">sizeAttenuation</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="string">&#x27;#ff88cc&#x27;</span>),</span><br><span class="line">      <span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">alphaMap</span>: particleTexture</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setPoints</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">points</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(<span class="variable language_">this</span>.<span class="property">geometry</span>, <span class="variable language_">this</span>.<span class="property">material</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scene</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">points</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>setGeometry</code></li>
</ul>
<p>使用 <a href="https://threejs.org/docs/?q=BufferGeometry#api/zh/core/BufferGeometry">BufferGeometry</a> 的方式創造 5000 個點的座標</p>
<ul>
<li><code>setMaterial</code></li>
</ul>
<p>使用 <a href="https://threejs.org/docs/?q=PointsMaterial#api/zh/materials/PointsMaterial">PointsMaterial</a> 創建粒子的材質，將 <code>transparent</code> 設為 <code>true</code>，代表粒子是透明的可以看到後面的其他粒子，另外也使用了 <a href="https://threejs.org/docs/?q=PointsMaterial#api/zh/materials/PointsMaterial.alphaMap">alphaMap</a> 讓粒子呈現小圓圈的樣子</p>
<p>alphaMap 使用的貼圖<br><img src="./texture-2.png" /></p>
<ul>
<li><code>setPoints</code></li>
</ul>
<p>最後結合上面創建的 <code>geometry</code> 與 <code>material</code> 生成 5000 個 <a href="https://threejs.org/docs/?q=Points#api/zh/objects/Points">Points</a></p>
<img src="./particles.png" style="width: 100%" />

<h2 id="問題：後面的粒子被前面的粒子遮擋住"><a href="#問題：後面的粒子被前面的粒子遮擋住" class="headerlink" title="問題：後面的粒子被前面的粒子遮擋住"></a>問題：後面的粒子被前面的粒子遮擋住</h2><p>仔細觀察會發現某些粒子會被前面的粒子遮擋住，如下圖所示：</p>
<p><video src="https://bcjohn-public-static.s3.ap-southeast-2.amazonaws.com/particles-block.mp4" autoplay muted loop style="width: 100%"></video></p>
<p>會導致這個問題的原因是這 5000 個粒子的繪製順序是無法被確定的，還記得我們在上一篇系列文中的 <a href="/blog/2025/03/31/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-5-%E6%B8%B2%E6%9F%93%E7%89%A9%E9%AB%94%E7%9A%84%E9%A0%86%E5%BA%8F/#2-%E7%82%BA%E4%BB%80%E9%BA%BC%E9%80%8F%E5%85%89%E7%89%A9%E9%AB%94%E3%80%81%E9%80%8F%E6%98%8E%E7%89%A9%E9%AB%94%EF%BC%8C%E9%A0%90%E8%A8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F%E6%98%AF-z-%E8%B6%8A%E5%A4%A7%E7%9A%84%E8%B6%8A%E5%85%88%E9%80%B2%E8%A1%8C%E6%B8%B2%E6%9F%93%EF%BC%9F" target="_blank">延伸閱讀 2. 為什麼透光物體、透明物體，預設的渲染順序是 z 越大的越先進行渲染？</a> 中探討過 <strong>透明物體</strong> 必須是由遠到近進行渲染，這樣在進行深度測試的時候才能保證看得到 <strong>透明物體</strong> 後面的東西，但由於這裡繪製粒子的順序並沒有依照 <code>z</code> 的大小進行排序，因此如果位在前面的某個粒子先行渲染，接著才輪到位在後面的某個粒子接著渲染，此時後面的粒子進行深度測試時會失敗被捨棄掉，也就出現了 <strong>後面的粒子被前面的粒子遮擋住</strong> 的現象</p>
<h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>如何解決後面的粒子被前面遮擋住的問題呢？第一個方式可以考慮使用 <code>alphaTest</code></p>
<h4 id="1-設置很小的-alphaTest-值"><a href="#1-設置很小的-alphaTest-值" class="headerlink" title="1. 設置很小的 alphaTest 值"></a>1. 設置很小的 alphaTest 值</h4><p><a href="https://threejs.org/docs/?q=Points#api/zh/materials/Material.alphaTest">alphaTest</a> 的設置可以決定透明度多少以下的像素不被渲染在畫面上，由於前面粒子的黑色背景可能遮擋到後面的粒子，所以我們可以設置一個 <strong>很低的闕值(例如 0.01)</strong> 來避免黑色背景渲染在畫面上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">alphaTest</span>: <span class="number">0.01</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><video src="https://bcjohn-public-static.s3.ap-southeast-2.amazonaws.com/particles-alpha-test.mp4" autoplay muted loop style="width: 100%"></video></p>
<p>原本會出現黑色正方形背景的原因是即使這個黑色背景的透明度是 0，代表完全透明，但由於他還是被渲染到畫面上，導致當這個黑色背景後面有粒子存在時，後面的粒子無法通過深度測試被捨棄，而出現被遮擋的現象，當設置一個 <strong>很低的闕值(0.01)</strong> 時可以告訴渲染引擎說只要低於 <strong>0.01</strong> 的像素都不進行渲染，這樣也就不會影響處於後面粒子們的深度測試</p>
<p>將黑色背景消除後可以正確看到後面的粒子，但還有個不完美的地方是粉紅色的圈圈一樣有可能遮擋到後面的粒子，因為我們只是設置了一個很小的 <code>alphaTest</code> 值避免黑色背景渲染在畫面上，但前面粒子的粉紅色圈圈一樣有可能先行渲染而使得後面粒子的深度測試失敗，導致後面粒子被遮擋住的狀況</p>
<h4 id="2-關閉深度測試-depthTest"><a href="#2-關閉深度測試-depthTest" class="headerlink" title="2. 關閉深度測試 (depthTest)"></a>2. 關閉深度測試 (depthTest)</h4><p>由於我們無法保證每個粒子都是由遠而近的順序進行渲染的，所以不如就關閉 <a href="https://threejs.org/docs/?q=Points#api/zh/materials/Material.depthTest">深度測試(depthTest)</a>，這樣即使粒子處在後面的位置也不會因為深度測試失敗而被丟棄</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">depthTest</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><video src="https://bcjohn-public-static.s3.ap-southeast-2.amazonaws.com/particles-depth-test.mp4" autoplay muted loop style="width: 100%"></video></p>
<p>這個方式讓後面的粒子不會被遮住了，但關閉深度測試的方式有一個缺點是當場景中同時有 <strong>不透明物體</strong> 存在時，由於 <strong>透明的粒子</strong> 會在 <strong>不透明物體</strong> 之後才進行渲染，而粒子又關閉了深度測試，這就導致了即使粒子位在 <strong>不透明物體</strong> 的後面，最後都會顯示在 <strong>不透明物體</strong> 的前方被畫在畫面<br>上形成不正確的遮擋關係，如下圖所示：有很多本來應該在白色正方體後面的粒子都被畫在白色正方體前面了</p>
<img src="./particles-box.png" style="width: 100%" />

<h4 id="3-禁止深度值寫入緩衝區-depthWrite"><a href="#3-禁止深度值寫入緩衝區-depthWrite" class="headerlink" title="3. 禁止深度值寫入緩衝區 (depthWrite)"></a>3. 禁止深度值寫入緩衝區 (depthWrite)</h4><p>為了避免 <strong>透明粒子關閉深度測試 (depthTest)</strong> 後都畫在最前面，另一個解決方式是禁止深度值寫入 <a href="https://threejs.org/docs/?q=Points#api/zh/materials/Material.depthWrite">深度緩衝區(depthWrite)</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">depthWrite</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>讓我們來分析看看為什麼這樣可以解決物體前後遮擋的問題：</p>
<ol>
<li>首先畫面上會渲染 <strong>不透明的白色正方體</strong>，接著渲染 <strong>透明的粒子們</strong></li>
<li>由於 <strong>透明的粒子們</strong> 有開啟深度測試，因此在 <strong>不透明的白色正方體</strong> 後面的粒子們，深度測試失敗會被捨棄，最終不會呈現在畫面上，而在 <strong>不透明的白色正方體</strong> 前的粒子會正確呈現</li>
<li>而當 <strong>透明的粒子們</strong> 互相重疊的狀況時，由於先渲染的粒子並沒有將深度值寫入深度緩衝區，因此後渲染的粒子都可以通過深度測試顯示在畫面上，這就代表粒子之間不會有互相遮擋的問題出現</li>
</ol>
<p><video src="https://bcjohn-public-static.s3.ap-southeast-2.amazonaws.com/particles-depth-write.mp4" autoplay muted loop style="width: 100%"></video></p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>今天探討了在 Three.js 中渲染多個粒子時可能遇到的前後遮擋問題，並提出了三個可能的解決方式，而最佳的解決方案是 <strong>禁止粒子的深度值寫入緩衝區 (depthWrite)</strong>，藉由這三種方式的分析讓我們瞭解到為什麼實務上渲染 <strong>透明物體</strong> 時通常都會將 <code>depthWrite</code> 設置為 <code>false</code> 以解決前後遮擋的問題</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><h4 id="1-為什麼透明粒子們沒有由遠到近進行渲染？"><a href="#1-為什麼透明粒子們沒有由遠到近進行渲染？" class="headerlink" title="1. 為什麼透明粒子們沒有由遠到近進行渲染？"></a>1. 為什麼透明粒子們沒有由遠到近進行渲染？</h4><p>在第五篇系列文 <a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/#2-為什麼透光物體、透明物體，預設的渲染順序是-z-越大的越先進行渲染？" target="_blank">延伸閱讀 2.為什麼透光物體、透明物體，預設的渲染順序是 z 越大的越先進行渲染？</a> 中提到對於 <strong>透明物體</strong> 來說 Three.js 底層的原始碼會根據每個物體距離相機遠近的 <code>z</code> 值排序，並且由遠到近進行渲染，而這篇文章中的粒子們也是 <strong>透明物體</strong> 但為何沒有由遠到近渲染而會出現互相遮擋的狀況呢？</p>
<p>原因是 Three.js 底層處理 <code>z</code> 值排序的邏輯是根據 <strong>物體(Object)</strong> 為單位進行排序的，<strong>物體(Object)</strong> 可以用以下幾種方式創建：</p>
<ul>
<li><code>Mesh</code> 視作一個 <strong>物體(Object)</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>();</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Points</code> 視作一個 <strong>物體(Object)</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>();</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<p>在這篇文章中的 5000 個粒子是用一個單獨的 <code>THREE.Points</code> 同時渲染出來的，因此這 5000 個粒子在 Three.js 中其實只是一個 <strong>物體(Object)</strong>，當然就無法有每個粒子個別的 <code>z</code> 值由遠到近進行排序後再渲染</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://threejs-journey.com/">Three.js journey - lesson particles</a><br><a href="https://juejin.cn/post/7113540626347458591?searchId=20250127232905E3C3D7D58C4B5F0F699A">Three.js 之 12 Particles 粒子效果</a><br><a href="https://discourse.threejs.org/t/a-problem-with-transparency-for-point-geomerty/19863">A problem with transparency for point geomerty</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>CORS Debug (2) - src 與 crossOrigin 在 img 元素中的順序導致 CORS error</title>
    <url>/blog/2025/04/17/cors-debug-2-src-%E8%88%87-crossorigin-%E5%9C%A8-img-%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E9%A0%86%E5%BA%8F%E5%B0%8E%E8%87%B4-cors-error/</url>
    <content><![CDATA[<h6 id="此為-CORS-Debug-系列文章-第-2-篇："><a href="#此為-CORS-Debug-系列文章-第-2-篇：" class="headerlink" title="此為 CORS Debug 系列文章 - 第 2 篇："></a>此為 <strong>CORS Debug</strong> 系列文章 - 第 2 篇：</h6><ol>
<li><a href="/blog/2025/04/13/cors-debug-1-網頁快取導致的-cors-問題/" target="_blank">CORS Debug (1) - 網頁快取導致的 CORS 問題</a></li>
<li><a href="/blog/2025/04/17/cors-debug-2-src-與-crossorigin-在-img-元素中的順序導致-cors-error/" target="_blank">CORS Debug (2) - src 與 crossOrigin 在 img 元素中的順序導致 CORS error</a></li>
</ol>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>在上一篇文章 - <a href="/blog/2025/04/13/cors-debug-1-網頁快取導致的-cors-問題/" target="_blank">網頁快取導致的 CORS 問題</a> 中，最終採用了 <code>crossOrigin=&#39;anonymous&#39;</code> 這樣的方式解決網頁快取導致的 CORS 錯誤，原本以為這樣已經萬無一失，但沒想到更悲劇的事情發生了 &#x3D;&gt; 在 Safari 瀏覽器有時候會發現網頁上的圖片都不見了</p>
<div style="display: flex; justify-content: center;">
  <img src="/blog/2025/04/17/cors-debug-2-src-與-crossorigin-在-img-元素中的順序導致-cors-error/safari-image-disappear.png" />
</div>

<span id="more"></span>

<h2 id="什麼情況下圖片會消失不見"><a href="#什麼情況下圖片會消失不見" class="headerlink" title="什麼情況下圖片會消失不見"></a>什麼情況下圖片會消失不見</h2><p>經過一些測試後，發現圖片不見的關鍵因素有以下幾點：</p>
<ol>
<li><p>只有 Safari 瀏覽器會出現這個問題，Chrome 瀏覽器正常</p>
</li>
<li><p>第一次從伺服器取得圖片時一定都正常，但重整頁面下一次拿快取圖片的時候<strong>有機率</strong>圖片會消失不見</p>
</li>
<li><p>當圖片消失不見後，即使不斷重整頁面圖片一樣回不來</p>
</li>
</ol>
<p>此時點開 Safari 的 DevTools 來看，又見到了熟悉的 CORS 錯誤</p>
<div style="display: flex; justify-content: center;">
  <img src="./safari-cors-error.png" />
</div>

<h2 id="CORS-錯誤出現-查看網路請求"><a href="#CORS-錯誤出現-查看網路請求" class="headerlink" title="CORS 錯誤出現 - 查看網路請求"></a>CORS 錯誤出現 - 查看網路請求</h2><p>第一步先看看 CORS 錯誤發生時的網路請求，打開 Safari DevTools 的網路部分會發現奇怪的事，每張圖片都發出了兩次請求，其中一個是黑色沒有錯誤的請求、另一個是紅色的 CORS 錯誤請求</p>
<ul>
<li>沒有錯誤的請求</li>
</ul>
<p>可以看到來源是<strong>磁碟快取</strong>，但奇怪的地方是明明就已經在 <code>&lt;img /&gt;</code> 加上 <code>crossOrigin=&#39;anonymous&#39;</code> 了，但 Response headers 為什麼卻沒有 <code>Access-Control-Allow-Origin: *</code> &#x3D;&gt; 這代表之前快取到的是 <strong>非跨域請求</strong> ?</p>
<div style="display: flex; justify-content: center;">
  <img src="./cors-error-request-good.png" />
</div>

<ul>
<li>出現 CORS 錯誤的請求</li>
</ul>
<p>可以看到 Request headers 帶有 <code>Origin</code> 欄位，代表這送出的是 <strong>跨域請求</strong>，而現在出現 CORS 錯誤了，對照上面的結果，看來可以確定之前快取到的是 <strong>非跨域請求</strong></p>
<div style="display: flex; justify-content: center;">
  <img src="./cors-error-request-bad.png" />
</div>

<h2 id="第一次載入圖片-查看網路請求"><a href="#第一次載入圖片-查看網路請求" class="headerlink" title="第一次載入圖片 - 查看網路請求"></a>第一次載入圖片 - 查看網路請求</h2><p>接著我們來看看第一次載入圖片時，是否有可能快取到 <strong>非跨域請求</strong> 呢？</p>
<p>打開 DevTools 看會發現第一次載入圖片時，每張圖片一樣也都發出了兩個請求，其中一個是 <strong>跨域請求</strong> 而另一個是 <strong>非跨域請求</strong></p>
<ul>
<li>跨域請求</li>
</ul>
<p>可以看到第一個請求是 <strong>跨域請求</strong>，Request headers 帶有 <code>Origin</code> 欄位而 Response headers 也帶有 <code>Access-Control-Allow-Origin: *</code>，由於我們在 <code>img</code> 元素上帶了 <code>crossOrigin=&#39;anonymous&#39;</code>，所以發出 <strong>跨域請求</strong> 是合理的</p>
<div style="display: flex; justify-content: center;">
  <img src="./first-request-cors.png" />
</div>

<ul>
<li>非跨域請求</li>
</ul>
<p>而莫名出現的第二個請求是 <strong>非跨域請求</strong>，Request headers 沒有 <code>Origin</code> 欄位，所以 Response headers 也就沒有回傳 <code>Access-Control-Allow-Origin: *</code>，這是不合理的</p>
<div style="display: flex; justify-content: center;">
  <img src="./first-request-no-cors.png" />
</div>

<h2 id="推測-CORS-錯誤出現的原因"><a href="#推測-CORS-錯誤出現的原因" class="headerlink" title="推測 CORS 錯誤出現的原因"></a>推測 CORS 錯誤出現的原因</h2><p>根據以上的觀察，我們知道第一次進入頁面從伺服器獲取圖片時，Safari 不知道為什麼發出了兩個請求，一個是 <strong>跨域請求</strong> 而另一個是 <strong>非跨域請求</strong>，圖片回傳後 Safari 會將圖片快取，但這時候似乎會出現兩個可能性：一個是快取到 <strong>跨域請求</strong> 而另一個是快取到 <strong>非跨域請求</strong></p>
<ul>
<li>快取到 <strong>跨域請求</strong></li>
</ul>
<p>這就沒什麼問題了，之後對於同一張圖片的請求都會覆用 <strong>跨域請求</strong> 的快取</p>
<ul>
<li>快取到 <strong>非跨域請求</strong></li>
</ul>
<p>這就是問題的所在，由於一開始快取到 <strong>非跨域請求</strong>，之後對於同一張圖片的請求也都會讀取到 <strong>非跨域請求</strong> 的快取，但因為 <code>img</code> 元素加上 <code>crossOrigin=&#39;anonymous&#39;</code> 代表送出的是 <strong>跨域請求</strong>，而此時 Safari 卻使用到之前快取到的 <strong>非跨域請求</strong>，就導致了 CORS 錯誤再次出現</p>
<p>所以關鍵點就是：為什麼 Safari 瀏覽器對於同一張圖片會送出兩次請求，而且一次是 <strong>跨域請求</strong> 另一次是 <strong>非跨域請求</strong> ？</p>
<h2 id="Safari-crossOrigin-anonymous-擺放的次序是重要的"><a href="#Safari-crossOrigin-anonymous-擺放的次序是重要的" class="headerlink" title="Safari crossOrigin=&#39;anonymous&#39; 擺放的次序是重要的"></a>Safari <code>crossOrigin=&#39;anonymous&#39;</code> 擺放的次序是重要的</h2><p>在經過許久的鬼打牆後，我偶然發現了一篇救命稻草 - <a href="https://github.com/sveltejs/svelte/issues/7454">crossorigin and src attribute order matter</a>，這篇文章提到 <code>crossOrigin=&#39;anonymous&#39;</code> 擺放的次序在 Safari 瀏覽器中是很重要的</p>
<ul>
<li><code>src</code> 擺在 <code>crossOrigin=&#39;anonymous&#39;</code> 前面</li>
</ul>
<p>這種方式就會導致我們上面遇到的那些問題，同一張圖片的請求發出兩次，一次是 <strong>跨域請求</strong> 另一次是 <strong>非跨域請求</strong>，而我們無法控制 Safari 瀏覽器會快取哪個請求，當運氣不好快取到的是 <strong>非跨域請求</strong> 時那就慘了，在快取圖片有效的期間都會出現 CORS 錯誤，因此不管使用者怎麼刷新頁面圖片都是消失不見的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>crossOrigin=&#39;anonymous&#39;</code> 擺在 <code>src</code> 前面</li>
</ul>
<p>實測這種方式 Safari 會運作正常，同一張圖片只會發出一次 <strong>跨域請求</strong>，並正確被快取</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="各大前端框架的-issues"><a href="#各大前端框架的-issues" class="headerlink" title="各大前端框架的 issues"></a>各大前端框架的 issues</h2><p>除了上面那篇是 <code>svelte</code> 發的 issue 外，我發現 <code>React</code>, <code>vue</code> 的使用者從大約在 2018 年到 今日(2025&#x2F;04) 都一樣面對著這奇怪的問題</p>
<ul>
<li>svelte - <a href="https://github.com/sveltejs/svelte/issues/7454">crossorigin and src attribute order matter</a></li>
<li>react - <a href="https://github.com/facebook/react/issues/14035">crossOrigin attribute needs to be applied before <code>&lt;img src&gt;</code> attribute</a></li>
<li>vue - <a href="https://github.com/vuejs/core/issues/4680">Safari loads image twice if crossorigin attribute goes after src</a></li>
</ul>
<p>P.S. 在後面 <a href="/blog/2025/04/17/cors-debug-2-src-%E8%88%87-crossorigin-%E5%9C%A8-img-%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E9%A0%86%E5%BA%8F%E5%B0%8E%E8%87%B4-cors-error/#React-JSX-%E7%B7%A8%E8%AD%AF%E7%B5%90%E6%9E%9C">研究 React 原始碼的過程中</a>，我發現 React 其實已經修復此 Safari 特定的 CORS 問題了</p>
<h2 id="排除前端框架的影響"><a href="#排除前端框架的影響" class="headerlink" title="排除前端框架的影響"></a>排除前端框架的影響</h2><p>雖然看過上面的 issues，把 <code>crossOrigin=&#39;anonymous&#39;</code> 擺在 <code>src</code> 前面避免掉 Safari 瀏覽器這個特有的 CORS 錯誤就沒問題了，但我很好奇這有沒有可能是使用 React, Vue 這些前端框架而導致的結果，如果改為使用純 HTML, JavaScript 會是一樣的嗎？所以我只用了 HTML, JavaScript 寫了幾個範例試試，下面來看看哪些寫法會引起 CORS 錯誤，首先是 Chrome 的部分</p>
<h4 id="Chrome-瀏覽器"><a href="#Chrome-瀏覽器" class="headerlink" title="Chrome 瀏覽器"></a>Chrome 瀏覽器</h4><p>對於 <code>crossOrigin=&#39;anonymous&#39;</code> 的順序完全不在乎，各種寫法都正常送出 <strong>跨域請求</strong>，並且 <strong>跨域請求</strong> 回來的結果也都正常被快取，以下只列出其中一個正常的範例寫法</p>
<p><a href="https://bcjohnblue.github.io/browser-cors-error/chrome-good-1" target="_blank">範例 - chrome-good-1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;src&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Safari-瀏覽器"><a href="#Safari-瀏覽器" class="headerlink" title="Safari 瀏覽器"></a>Safari 瀏覽器</h4><p>Safari 瀏覽器就真的是莫名其妙了，以下我們來看看：</p>
<h4 id="1-正常寫法"><a href="#1-正常寫法" class="headerlink" title="1. 正常寫法"></a>1. 正常寫法</h4><p>這是 Safari 唯一一個正常 CORS 的範例，將 <code>crossorigin=&quot;anonymous&quot;</code> 寫在 <code>&lt;img /&gt;</code> 元素上可以正常送出 <strong>跨域請求</strong></p>
<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-good-1" target="_blank">範例 - safari-good-1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>稍微提及一下，這裡的寫法跟我們一開始使用前端框架(React, Vue)的寫法是不一樣的，在前端框架裡我們寫的是類似 <a href="https://www.explainthis.io/zh-hant/swe/what-is-jsx">JSX</a> 的語法，而這些 JSX 最終編譯成 HTML 後，不一定會長得跟這裡的寫法一樣，至於 React, Vue 將 JSX 編譯後的 HTML 會長什麼樣子，我們在後面會提到</p>
<h4 id="2-不好的寫法"><a href="#2-不好的寫法" class="headerlink" title="2. 不好的寫法"></a>2. 不好的寫法</h4><p>以下兩種寫法，同一張圖片都會送出兩次請求 - <strong>跨域請求</strong> 與 <strong>非跨域請求</strong>，但請求完後的圖片<strong>不會</strong>被瀏覽器快取</p>
<p>為什麼我認為是不好的寫法？發出兩次請求很怪，更怪的是竟然不會被快取起來，這種寫法主要是性能不太好，因為每張圖片都會去伺服器要求資源，而且之後也都無法覆用快取，但好處是因為每次請求後都不會儲存快取，所以不會導致 CORS 問題進而讓圖片消失不見 </p>
<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-bad-1" target="_blank">範例 - safari-bad-1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span> =</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-bad-2" target="_blank">範例 - safari-bad-2</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="title function_">setAttribute</span>(</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;src&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">    img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-非常糟的寫法"><a href="#3-非常糟的寫法" class="headerlink" title="3. 非常糟的寫法"></a>3. 非常糟的寫法</h4><p>以下兩種寫法，同一張圖片都會送出兩次請求 - <strong>跨域請求</strong> 與 <strong>非跨域請求</strong>，而請求完後的圖片<strong>會</strong>被瀏覽器快取</p>
<p>為什麼我認為這是非常糟的寫法呢？原因是這個寫法會被瀏覽器快取啊，而且還無法確定被快取的是 <strong>跨域請求</strong> 或是 <strong>非跨域請求</strong>，當快取到的是 <strong>非跨域請求</strong> 時就會遇到我們開頭的那個圖片消失不見的問題</p>
<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-very-bad-1" target="_blank">範例 - safari-very-bad-1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">src</span> =</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-very-bad-2" target="_blank">範例 - safari-very-bad-2</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;src&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-非常好的寫法"><a href="#4-非常好的寫法" class="headerlink" title="4. 非常好的寫法"></a>4. 非常好的寫法</h4><p>只是想強調這個寫法跟上面 <a href="/blog/2025/04/17/cors-debug-%E7%B3%BB%E5%88%97%E6%96%87-2-crossorigin-anonymous-%E7%9A%84%E9%A0%86%E5%BA%8F%E5%B0%8E%E8%87%B4-cors-error/#3-%E9%9D%9E%E5%B8%B8%E7%B3%9F%E7%9A%84%E5%AF%AB%E6%B3%95">3. 非常糟的寫法</a> 很類似，差別只在把 <code>crossOrigin=&#39;anonymous&#39;</code> 的順序提前到 <code>src</code> 之前，但結果會跟 <a href="/blog/2025/04/17/cors-debug-%E7%B3%BB%E5%88%97%E6%96%87-2-crossorigin-anonymous-%E7%9A%84%E9%A0%86%E5%BA%8F%E5%B0%8E%E8%87%B4-cors-error/#1-%E6%AD%A3%E5%B8%B8%E5%AF%AB%E6%B3%95">1. 正常寫法</a> 一樣，每張圖片只會送出一個 <strong>跨域請求</strong>，並且請求完後的圖片也<strong>會</strong>被快取</p>
<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-very-good-1" target="_blank">範例 - safari-very-good-1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">src</span> =</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://bcjohnblue.github.io/browser-cors-error/safari-very-good-2" target="_blank">範例 - safari-very-good-2</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;src&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="前端框架對應到的是哪種寫法？"><a href="#前端框架對應到的是哪種寫法？" class="headerlink" title="前端框架對應到的是哪種寫法？"></a>前端框架對應到的是哪種寫法？</h2><p>上面分析完純 HTML, Javascript 的幾種寫法最終如何影響請求以及快取的方式，接著讓我們回頭來看，現今大家常用的前端框架 JSX 的語法最終編譯出來後對應到的是哪種寫法</p>
<h4 id="React-or-Vue-中類-JSX-的寫法"><a href="#React-or-Vue-中類-JSX-的寫法" class="headerlink" title="React or Vue 中類 JSX 的寫法"></a>React or Vue 中類 JSX 的寫法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="React-JSX-編譯結果"><a href="#React-JSX-編譯結果" class="headerlink" title="- React JSX 編譯結果"></a>- React JSX 編譯結果</h4><p>以上 React JSX 的寫法會藉由 babel 編譯成 <a href="https://react.dev/reference/react/createElement">React.createElement</a> 的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span>,</span><br><span class="line">  <span class="attr">crossOrigin</span>: <span class="string">&#x27;anonymous&#x27;</span>,</span><br><span class="line">  <span class="attr">alt</span>: <span class="string">&#x27;building&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而根據 <a href="https://juejin.cn/post/7431122270641094675">React 源码解析 (四) —— Fiber 树初次构造</a> 這篇文章的分析，元素在賦予 <code>props</code> 屬性時會執行到 <a href="https://github.com/facebook/react/blob/bc6184dd993e6ea0efdee7553293676db774c3ca/packages/react-dom-bindings/src/client/ReactFiberConfigDOM.js#L584">finalizeInitialChildren</a> 函式，而其中的 <a href="https://github.com/facebook/react/blob/bc6184dd993e6ea0efdee7553293676db774c3ca/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L1045">setInitialProperties</a> 就處理了 <code>img</code> 元素賦予 <code>props</code> 的邏輯：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">  <span class="comment">// img tags previously were implemented as void elements with non delegated events however Safari (and possibly Firefox)</span></span><br><span class="line">  <span class="comment">// begin fetching the image as soon as the `src` or `srcSet` property is set and if we set these before other properties</span></span><br><span class="line">  <span class="comment">// that can modify the request (such as crossorigin) or the resource fetch (such as sizes) then the browser will load</span></span><br><span class="line">  <span class="comment">// the wrong thing or load more than one thing. This implementation ensures src and srcSet are set on the instance last</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;img&#x27;</span>: &#123;</span><br><span class="line">    <span class="title function_">listenToNonDelegatedEvent</span>(<span class="string">&#x27;error&#x27;</span>, domElement);</span><br><span class="line">    <span class="title function_">listenToNonDelegatedEvent</span>(<span class="string">&#x27;load&#x27;</span>, domElement);</span><br><span class="line">    <span class="comment">// Mostly a port of Void Element logic with special casing to ensure srcset and src are set last</span></span><br><span class="line">    <span class="keyword">let</span> hasSrc = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> hasSrcSet = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propKey <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!props.<span class="title function_">hasOwnProperty</span>(propKey)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> propValue = props[propKey];</span><br><span class="line">      <span class="keyword">if</span> (propValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (propKey) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;src&#x27;</span>:</span><br><span class="line">          hasSrc = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;srcSet&#x27;</span>:</span><br><span class="line">          hasSrcSet = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;children&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;dangerouslySetInnerHTML&#x27;</span>: &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Can we make this a DEV warning to avoid this deny list?</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;tag&#125;</span> is a void element tag and must neither have \`children\` nor `</span> +</span><br><span class="line">              <span class="string">&#x27;use `dangerouslySetInnerHTML`.&#x27;</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// defaultChecked and defaultValue are ignored by setProp</span></span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="title function_">setProp</span>(domElement, tag, propKey, propValue, props, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasSrcSet) &#123;</span><br><span class="line">      <span class="title function_">setProp</span>(domElement, tag, <span class="string">&#x27;srcSet&#x27;</span>, props.<span class="property">srcSet</span>, props, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasSrc) &#123;</span><br><span class="line">      <span class="title function_">setProp</span>(domElement, tag, <span class="string">&#x27;src&#x27;</span>, props.<span class="property">src</span>, props, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait 等等！這裡看起來不太正常，為什麼在 <code>case &#39;img&#39;</code> 上面的註解提到了 Safari crossorigin 的順序問題，我一直以為根據這篇 <a href="https://github.com/facebook/react/issues/14035">crossOrigin attribute needs to be applied before <img src> attribute</a> 最後的留言在 2021 年 9 月，這個順序的 bug 在 React 中應該還是存在：</p>
<div style="display: flex; justify-content: center;">
  <img src="./react-issue.png" />
</div>

<p>但從 React 原始碼中才發現原來這個 Safari 特定的 bug 已經被修復了啊！後來利用 git blame 找到了修改的 PR - <a href="https://github.com/facebook/react/pull/30340">[Fiber] Ensure srcset and src are assigned last on img instances</a> 是在 2024 年 7 月，從 React releases 可以發現對應到的是 <a href="https://github.com/facebook/react/releases/tag/v19.0.0">19.0.0 版本</a></p>
<p>這時趕快把我在上一篇文章用 React 所寫的範例，版本用的是 React 18.3.1，切換成 19.0.0 後，哇！發現 React 編譯後真的把 <code>crossOrigin</code> 移到 <code>src</code> 前面了！</p>
<h4 id="Vue-JSX-編譯結果"><a href="#Vue-JSX-編譯結果" class="headerlink" title="- Vue JSX 編譯結果"></a>- Vue JSX 編譯結果</h4><p>Vue 的類 JSX 語法叫做 <a href="https://cn.vuejs.org/guide/essentials/template-syntax.html">模板语法</a>，之後會藉由 <a href="https://cn.vuejs.org/guide/extras/render-function">h</a> 函式轉化爲 <a href="https://cn.vuejs.org/guide/extras/rendering-mechanism#virtual-dom">vnode</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span>,</span><br><span class="line">  <span class="attr">crossorigin</span>: <span class="string">&#x27;anonymous&#x27;</span>,</span><br><span class="line">  <span class="attr">alt</span>: <span class="string">&#x27;building&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>根據 <a href="https://juejin.cn/post/7312353149813342249">Vue3 源码解析之 render（一）</a>，<code>vnode</code> 會傳入 <a href="https://github.com/vuejs/core/blob/4f792535e25af6941d1eb267fe16e4121623a006/packages/runtime-core/src/renderer.ts#L633">mountElement</a> 函式，其中的 <a href="https://github.com/vuejs/core/blob/4f792535e25af6941d1eb267fe16e4121623a006/packages/runtime-core/src/renderer.ts#L680">hostPatchProp</a> 負責處理傳入的 <code>props</code> 屬性，而 <code>hostPatchProp</code> 的函式實際上使用的是 <code>packages/runtime-dom/src/patchProp.ts</code> 檔案中的 <a href="https://github.com/vuejs/core/blob/4f792535e25af6941d1eb267fe16e4121623a006/packages/runtime-dom/src/patchProp.ts#L25">patchProp</a> 函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patchProp</span>: <span class="title class_">DOMRendererOptions</span>[<span class="string">&#x27;patchProp&#x27;</span>] = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el,</span></span></span><br><span class="line"><span class="params"><span class="function">  key,</span></span></span><br><span class="line"><span class="params"><span class="function">  prevValue,</span></span></span><br><span class="line"><span class="params"><span class="function">  nextValue,</span></span></span><br><span class="line"><span class="params"><span class="function">  namespace,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isSVG = namespace === <span class="string">&#x27;svg&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">patchClass</span>(el, nextValue, isSVG)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;style&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">patchStyle</span>(el, prevValue, nextValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isOn</span>(key)) &#123;</span><br><span class="line">    <span class="comment">// ignore v-model listeners</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isModelListener</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">patchEvent</span>(el, key, prevValue, nextValue, parentComponent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    key[<span class="number">0</span>] === <span class="string">&#x27;.&#x27;</span></span><br><span class="line">      ? ((key = key.<span class="title function_">slice</span>(<span class="number">1</span>)), <span class="literal">true</span>)</span><br><span class="line">      : key[<span class="number">0</span>] === <span class="string">&#x27;^&#x27;</span></span><br><span class="line">        ? ((key = key.<span class="title function_">slice</span>(<span class="number">1</span>)), <span class="literal">false</span>)</span><br><span class="line">        : <span class="title function_">shouldSetAsProp</span>(el, key, nextValue, isSVG)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">patchDOMProp</span>(el, key, nextValue, parentComponent)</span><br><span class="line">    <span class="comment">// #6007 also set form state as attributes so they work with</span></span><br><span class="line">    <span class="comment">// &lt;input type=&quot;reset&quot;&gt; or libs / extensions that expect attributes</span></span><br><span class="line">    <span class="comment">// #11163 custom elements may use value as an prop and set it as object</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !el.<span class="property">tagName</span>.<span class="title function_">includes</span>(<span class="string">&#x27;-&#x27;</span>) &amp;&amp;</span><br><span class="line">      (key === <span class="string">&#x27;value&#x27;</span> || key === <span class="string">&#x27;checked&#x27;</span> || key === <span class="string">&#x27;selected&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="title function_">patchAttr</span>(el, key, nextValue, isSVG, parentComponent, key !== <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// #11081 force set props for possible async custom element</span></span><br><span class="line">    (el <span class="keyword">as</span> <span class="title class_">VueElement</span>).<span class="property">_isVueCE</span> &amp;&amp;</span><br><span class="line">    (<span class="regexp">/[A-Z]/</span>.<span class="title function_">test</span>(key) || !<span class="title function_">isString</span>(nextValue))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">patchDOMProp</span>(el, <span class="title function_">camelize</span>(key), nextValue, parentComponent, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// special case for &lt;input v-model type=&quot;checkbox&quot;&gt; with</span></span><br><span class="line">    <span class="comment">// :true-value &amp; :false-value</span></span><br><span class="line">    <span class="comment">// store value as dom properties since non-string values will be</span></span><br><span class="line">    <span class="comment">// stringified.</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;true-value&#x27;</span>) &#123;</span><br><span class="line">      ;(el <span class="keyword">as</span> any).<span class="property">_trueValue</span> = nextValue</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;false-value&#x27;</span>) &#123;</span><br><span class="line">      ;(el <span class="keyword">as</span> any).<span class="property">_falseValue</span> = nextValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">patchAttr</span>(el, key, nextValue, isSVG, parentComponent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從 <code>patchProp</code> 函式中的註解發現原來的底層程式碼對 <code>props</code> 做了各種處理，但都與我們想找的 <code>img</code> 元素無關，看起來 <code>img</code> 元素最終會走到第 52 行的 <code>patchAttr</code>，而 <code>patchAttr</code> 是從 <code>packages/runtime-dom/src/modules/attrs.ts</code> 檔案裡來的</p>
<p><a href="https://github.com/vuejs/core/blob/4f792535e25af6941d1eb267fe16e4121623a006/packages/runtime-dom/src/modules/attrs.ts#L16">patchAttr</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">patchAttr</span>(<span class="params"></span></span><br><span class="line"><span class="params">  el: Element,</span></span><br><span class="line"><span class="params">  key: string,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  isSVG: boolean,</span></span><br><span class="line"><span class="params">  instance?: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isBoolean: boolean = isSpecialBooleanAttr(key)</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isSVG &amp;&amp; key.<span class="title function_">startsWith</span>(<span class="string">&#x27;xlink:&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      el.<span class="title function_">removeAttributeNS</span>(xlinkNS, key.<span class="title function_">slice</span>(<span class="number">6</span>, key.<span class="property">length</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.<span class="title function_">setAttributeNS</span>(xlinkNS, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__COMPAT__ &amp;&amp; <span class="title function_">compatCoerceAttr</span>(el, key, value, instance)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note we are only checking boolean attributes that don&#x27;t have a</span></span><br><span class="line">    <span class="comment">// corresponding dom prop of the same name here.</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || (isBoolean &amp;&amp; !<span class="title function_">includeBooleanAttr</span>(value))) &#123;</span><br><span class="line">      el.<span class="title function_">removeAttribute</span>(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// attribute value is a string https://html.spec.whatwg.org/multipage/dom.html#attributes</span></span><br><span class="line">      el.<span class="title function_">setAttribute</span>(</span><br><span class="line">        key,</span><br><span class="line">        isBoolean ? <span class="string">&#x27;&#x27;</span> : <span class="title function_">isSymbol</span>(value) ? <span class="title class_">String</span>(value) : value</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個 <code>patchAttr</code> 函式看起來是最後賦予屬性的地方了，所以在 vue 中 <code>img</code> 的模板語法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;building&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>最終在 <code>patchAttr</code> 函式中會將 <code>props</code> 屬性用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute">setAttribute</a> 的方式設置在 <code>img</code> 元素上，如同這樣的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.<span class="title function_">setAttribute</span>(</span><br><span class="line">  <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span><br><span class="line">);</span><br><span class="line">img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="前端框架寫法總結"><a href="#前端框架寫法總結" class="headerlink" title="前端框架寫法總結"></a>前端框架寫法總結</h4><p>在研究 React 原始碼的過程中意外發現原來 19.0.0 版本就特別為 <code>img</code> 元素 <code>crossorigin</code> 的順序做了特殊處理，所以目前的 React 即使你把 <code>crossorigin</code> 放在 <code>src</code> 前面也不會遇到我們今天這篇文章 Safari 圖片消失不見的問題</p>
<p>但 Vue 中並沒有對 <code>img</code> 元素進行特殊處理，最終是以 <code>setAttribute</code> 的方式將 <code>props</code> 依序設置在 <code>img</code> 元素上，而這種方式就如同 <a href="/blog/2025/04/17/cors-debug-2-src-與-crossorigin-在-img-元素中的順序導致-cors-error/#3-非常糟的寫法" target="_blank">3. 非常糟的寫法</a>，最終出現 Safari 圖片偶然消失不見的問題</p>
<h2 id="後續"><a href="#後續" class="headerlink" title="後續"></a>後續</h2><p>我在 <a href="https://bugs.webkit.org/">webkit bug report</a> 的網頁上似乎找不到之前有回報類似的問題，根據各大前端框架 issues 回報問題的時間點來看，最早從 2018 年問題就存在了，但到今日 Safari 都沒有進行修復，雖然感覺回報 bug 也很難等到修復的那一天，但反正都花時間研究這麼多了，乾脆送個 <a href="https://bugs.webkit.org/show_bug.cgi?id=291793">bug 單回報</a> 看之後有沒有進一步的消息了</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>在一開始看到 <a href="https://github.com/sveltejs/svelte/issues/7454">crossorigin and src attribute order matter</a> 這篇 issue 時，其實我是非常驚訝的，第一次知道 HTML attribute 的順序原來是有影響的，好奇大家是不是也都曾經知道或遇過這件事呢？</p>
<p>而且以我們這篇文章遇到的問題來說，我覺得是非常嚴重的，如果不知道順序會有影響，而將 <code>src</code> 屬性放在 <code>crossorigin</code> 前，由於 Safari 有機率快取到 <strong>非跨域請求</strong> 所以導致圖片消失不見，重點是我在測試的過程中覺得這個機率也不低，感覺至少有 10% 的機率會看不到圖片</p>
<p>另外一方面當圖片不見發生時，即使使用者不斷重整畫面，但只要快取沒有過期圖片就會一直出現 CORS 錯誤拿不到，而且通常圖片快取的時間都會設的比較長一個禮拜、一個月或甚至是一年，在這麼長的時間裡圖片永遠看不到會讓人覺得這是一個壞掉的網站</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><h4 id="1-如何清除快取？"><a href="#1-如何清除快取？" class="headerlink" title="1. 如何清除快取？"></a>1. 如何清除快取？</h4><p>由於這篇文章有很多部分的操作都需要保證清完瀏覽器的快取，所以這邊稍微簡介一下我在 Chrome 跟 Safari 清除快取的方式</p>
<ul>
<li>Chrome</li>
</ul>
<p>按下 F12 打開 DevTools &#x3D;&gt; 在網頁重整鍵上方按下滑鼠右鍵 &#x3D;&gt; 選擇 <strong>清除快取並強制重新載入</strong></p>
<div style="display: flex; justify-content: center; margin-top: -1.2em">
  <img src="./chrome-clear-cache.png" />
</div>

<ul>
<li>Safari</li>
</ul>
<p>將 <strong>網頁開發者功能</strong> 開啟 &#x3D;&gt; 點擊開發 Tab &#x3D;&gt; 點擊 <strong>清除快取資料</strong></p>
<div style="display: flex; justify-content: center;">
  <img src="./safari-clear-cache.png" />
</div>

<h4 id="2-Chrome-瀏覽器為什麼不會出現-CORS-錯誤？"><a href="#2-Chrome-瀏覽器為什麼不會出現-CORS-錯誤？" class="headerlink" title="2. Chrome 瀏覽器為什麼不會出現 CORS 錯誤？"></a>2. Chrome 瀏覽器為什麼不會出現 CORS 錯誤？</h4><p>同樣的一個寫法在 Safari 會導致 CORS 錯誤但為什麼 Chrome 是正常的呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;src&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://rjzdhlvuuafqvgoyticm.supabase.co/functions/v1/getCORSImage?image=building.jpg&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">      img.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我有找到 chromium 曾經發出的一個 PR - <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2102992">Image Loading: <code>crossorigin</code> mutations should queue a microtask</a>，裡面提供了一個 doc 檔案 - <a href="https://docs.google.com/document/d/1Xp34FIbbZnJILl0PNd1sfs_3z1HSriUVyRUgnAesGZk/edit?tab=t.0#heading=h.1amk7w8s8dxx">Image Loading: Relevant Mutations</a> 似乎對這部分有解釋，以下為原文摘要：</p>
<h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>As per the HTML Standard, an image element has a set of relevant mutations. When a relevant mutation occurs, the standard’s #updating-the-image-data algorithm is fired. This algorithm, at a high-level, does:</p>
<ol>
<li>Some basic processing of an image’s properties: ImageLoader::UpdateFromElement</li>
<li>Queues a microtask to continue the rest of the image fetching process: ImageLoader::EnqueueImageLoadingMicroTask</li>
<li>Continues the image loading process, where the resolved URL is parsed, the request is configured and made: ImageLoader::DoUpdateFromElement.</li>
</ol>
<div style="display: flex; justify-content: center;">
  <img src="./doc-1.png" />
</div>

<h5 id="解釋-Context"><a href="#解釋-Context" class="headerlink" title="解釋 - Context"></a>解釋 - Context</h5><p><code>img</code> 元素在 spec 裡有定義一個叫做 <a href="https://html.spec.whatwg.org/multipage/images.html#relevant-mutations">relevant mutations</a> 的東西，當觸發 <strong>relevant mutations</strong> 時，就會執行一個叫做 <strong>#updating-the-image-data</strong> 的算法</p>
<p>那什麼時候會觸發 <strong>relevant mutations</strong> 呢？ Spec 裡有寫到當 <code>src</code> 被設置、改變、移除時或是 <code>crossorigin</code> 屬性改變的時候都會引起 <strong>relevant mutations</strong></p>
<p>當 <code>relevant mutations</code> 被觸發後，接著就會執行 <strong>#updating-the-image-data</strong> 的算法，而這個算法對應到 Spec 裡的規範 - <a href="https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data">4.8.4.3.5 Updating the image data</a>，點進去看會發現總共有 Step 1 一直到 Step 27 這麼多步驟</p>
<p>這麼多的步驟實在令人眼花撩亂，我稍微看完後認為最重要的是 Step 8 及 Step 9</p>
<blockquote>
<ol start="8">
<li>Queue a microtask to perform the rest of this algorithm, allowing the task that invoked this algorithm to continue.</li>
</ol>
</blockquote>
<p>Step 8 表明了，從 Step 9 開始一直到最後的 Step 27 都會由一個算法執行，而這個算法對應到的是 <code>DoUpdateFromElement()</code>，但 <code>DoUpdateFromElement()</code> 並不是馬上執行的喔，而是放在 <a href="https://zh.javascript.info/microtask-queue">microtask 的 queue</a> 裡等待之後再執行</p>
<blockquote>
<ol start="9">
<li>If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.</li>
</ol>
</blockquote>
<p>接著 Step 9 說如果同一張圖片又執行了一次這個 <strong>#updating-the-image-data</strong> 的算法，那步驟 9 之後要處理的邏輯就都捨棄 return 掉囉</p>
<p>我想了一下覺得 <strong>Context</strong> 這個段落要表達的意思應該是這樣的，假設現在有一段程式寫成這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>當執行到第二行 <code>img.src = &quot;...&quot;</code> 時，因為 <code>src</code> 被指定了某個 url，會觸發 <strong>relevant mutations</strong> 並接著執行 <strong>#updating-the-image-data</strong> 算法，而執行到 Step 8 時會將 Step 9 到最後 Step 27 該執行的邏輯，都先放在一個 <strong>microtask queue</strong> 裡等待之後執行</p>
<p>接著執行到第三行 <code>img.crossOrigin = &#39;anonymous&#39;</code>，因為 <code>crossOrigin</code> 的值改變了，觸發 <strong>relevant mutations</strong>，又執行了 <strong>#updating-the-image-data</strong> 算法，當執行到 Step 8 時又創建了一個 <strong>microtask</strong> 並放在 <strong>queue</strong> 裡等待之後執行</p>
<p><strong>queue</strong> 的執行是先進先出的，所以第二行 <code>img.src = &quot;...&quot;</code> 的這個 <strong>microtask</strong> 會先被執行，此時執行到的是 Step 9，發現對同一個 <code>img</code> 元素來說<strong>後面</strong>有另外一個由 <code>img.crossOrigin = &#39;anonymous&#39;</code> 所創建的 <strong>microtask</strong>，因此 <code>img.src = &quot;...&quot;</code> 的 <strong>microtask</strong> 就只會執行到 Step 9 就 return 掉了</p>
<p>下一個執行到的是由 <code>img.crossOrigin = &#39;anonymous&#39;</code> 所創建的 <strong>microtask</strong>，此時執行到的是 Step 9，發現後面已經沒有同一個算法所創建的 <strong>microtask</strong> 了，所以接著就是一路執行到最後的 Step 27</p>
<p>可以發現這個 <strong>microtask queue</strong> 的過程中，前面被加入 <strong>queue</strong> 的 <strong>microtask</strong> 都會在 Step 9 被 return 掉，只有最後加入的 <strong>microtask</strong> 會繼續往下走到 Step 26 - Fetch the image 實際發出請求，而此時也因為知道 <code>img</code> 元素上有屬性 <code>crossOrigin</code> 了，所以可以正確的發出 <strong>跨域請求</strong>，這對應到 Spec 規範中特別 highlight 的一段話</p>
<div style="display: flex; justify-content: center;">
  <img src="./sepc-avoid-multiple-request.png" />
</div>

<br />

<p>藉由這種 <strong>microtask queue</strong> 的方式，可以將 <code>img</code> 元素的屬性都收集起來，並且最後只發出一個網路請求</p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><ol>
<li><p>範例 Repo 放在此 - <a href="https://github.com/bcjohnblue/browser-cors-error">browser-cors-error</a>，有興趣的人可以自己試看看</p>
</li>
<li><p>本篇文章測試的瀏覽器為：</p>
</li>
</ol>
<ul>
<li>Chrome 135</li>
<li>Safari 18.3</li>
</ul>
<ol start="3">
<li>本篇文章分析前端框架原始碼的版本為：</li>
</ol>
<ul>
<li><p>React 19.1.0</p>
</li>
<li><p>Vue 3.5.13</p>
</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://juejin.cn/post/6965462394286014471">React 源码解析-虚拟 DOM</a><br><a href="https://juejin.cn/post/7177517711486877756">React 源码分析 1-jsx 转换及 React.createElement</a><br><a href="https://juejin.cn/post/7308289054029250599">Vue3 源码解析之 runtime</a></p>
<!-- [揭开 JSX 面纱 ： jsx 代码是如何一步步解析变成最后的 html 元素的](https://blog.csdn.net/Dou_Hua6/article/details/142518814) -->
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (5) - 渲染物體的順序</title>
    <url>/blog/2025/03/31/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-5-%E6%B8%B2%E6%9F%93%E7%89%A9%E9%AB%94%E7%9A%84%E9%A0%86%E5%BA%8F/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-5-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-5-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 5 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 5 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面幾篇系列文中介紹深度測試運作的原理，而決定畫面上的兩個物體誰遠誰近，除了跟物體之間深度值差異有關，另外也相同重要的是物體間渲染的順序，今天這篇文章就讓我們討論在 Three.js 中是如何根據不同種類的物體決定渲染順序</p>
<span id="more"></span>

<h2 id="渲染物體的順序"><a href="#渲染物體的順序" class="headerlink" title="渲染物體的順序"></a>渲染物體的順序</h2><p>在 <a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/#Case-1-切換深度測試的開關" target="_blank">切換深度測試的開關</a> 中我們將紅色平面的 <code>depthTest</code> 設為 <code>false</code>，最終藍色平面中的 <strong>像素(fragment)</strong> 都通過深度測試，覆蓋紅色平面繪製到螢幕上</p>
<img src="./depth-test-red-disabled.png" style="width: 100%" />

<p>接著我們嘗試將紅色平面變成透明物體，在 Three.js 中指的是將 <a href="https://threejs.org/docs/#api/zh/materials/Material.transparent">Material.transparent</a> 設為 <code>true</code>，這時神奇的事情發生了原本中間會出現的藍色平面現在不見了，只剩紅色平面顯示在畫面上</p>
<img src="./red-transparent.png" style="width: 100%" />

<p>造成這個現象的關鍵點其實是因為當物體設爲透明後，渲染物體的順序就會改變，在 Three.js 底層的程式碼中，會將場景中的物體都先分類，其中一類是 <strong>不透明的物體</strong>，而一類是 <strong>透明的物體</strong>，而在將物體繪製到畫面時，一率都先繪製 <strong>不透明的物體</strong>，接著才繪製 <strong>透明的物體</strong>，所以當把<strong>紅色平面設成透明物體後</strong>，繪製物體的順序從原本的 <strong>紅色平面</strong> &#x3D;&gt; <strong>藍色平面</strong> 變為 <strong>藍色平面</strong> &#x3D;&gt; <strong>紅色平面</strong>，而紅色平面因為設定了 <code>depthTest = true</code>，代表在繪製 <strong>紅色平面</strong> 時一律都會將其繪製到畫面上，也因此我們所看到的畫面上只有 <strong>紅色平面</strong></p>
<h2 id="為什麽需要先繪製不透明物體？"><a href="#為什麽需要先繪製不透明物體？" class="headerlink" title="為什麽需要先繪製不透明物體？"></a>為什麽需要先繪製不透明物體？</h2><p>上面我們知道 Three.js 會先行繪製不透明物體，接著才繪製透明物體，下面我們來講解為什麼需要按照這樣的次序進行渲染，首先我們先反過來看如果先繪製透明物體，會導致什麼問題</p>
<h4 id="先繪製透明物體-錯誤"><a href="#先繪製透明物體-錯誤" class="headerlink" title="先繪製透明物體 (錯誤)"></a>先繪製透明物體 (錯誤)</h4><p><strong>假設場景中的透明物體在前、不透明物體在後</strong>，第一個繪製的是透明物體並顯示在畫面上，接著第二個繪製不透明物體時，由於不透明物體在透明物體的後面，因此不透明物體的深度測試無法通過，而前面我們提過當深度測試失敗的時候，會完全丟棄這個 <strong>像素(fragment)</strong>，也就是說不透明物體最終不會渲染在畫面上</p>
<p>下面我們實際來看當先繪製透明物體時，場景會變成怎麼樣，在前面的紅色平面是透明物體（<code>opacity = 0.3</code>），在後面的藍色平面是不透明物體，後面繪製的藍色平面因為無法通過深度測試而整個被丟棄掉，使得最後畫面上只剩下透明的紅色平面</p>
<p>這樣的畫面很明顯是錯誤的，因為照理來說視線應該要能夠看到透明物體後面的東西，但在這個狀況下，即使透明紅色平面後面有藍色平面，但因為藍色平面的 <strong>像素(fragment)</strong> 都被丟棄掉了，畫面上只看得到前面的透明紅色平面</p>
<img src="./opaque-first.png" style="width: 100%" />

<h4 id="先繪製不透明物體-正確"><a href="#先繪製不透明物體-正確" class="headerlink" title="先繪製不透明物體 (正確)"></a>先繪製不透明物體 (正確)</h4><p><strong>一樣假設透明物體在前、不透明物體在後</strong>，第一個繪製的是不透明物體並顯示在畫面上，接著第二個繪製透明物體時，由於透明物體在不透明物體的前面，因此透明物體的深度測試通過，而透明物體與不透明物體重疊的區域會以 <a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/">混合(Blending)</a> 方式決定最終畫面上的顏色</p>
<p>下面我們實際來看當先繪製不透明物體時，場景會變成怎麼樣，在前面的紅色平面是透明物體（<code>opacity = 0.3</code>），在後面的藍色平面是不透明物體，後面繪製的紅色平面會與之前畫面上存在的藍色平面進行 <strong>混合(Blending)</strong>，因此可以看到中間是紅、藍混合後類似紫色的顏色，這代表視線可以穿過透明的紅色平面看到後面的藍色平面，達到正確的效果</p>
<img src="./transparent-first.png" style="width: 100%" />

<h2 id="物體的渲染順序-Three-js-原始碼"><a href="#物體的渲染順序-Three-js-原始碼" class="headerlink" title="物體的渲染順序 - Three.js 原始碼"></a>物體的渲染順序 - Three.js 原始碼</h2><p>接著讓我們來研究看看 Three.js 原始碼中是如何處理不透明物體與透明物體的渲染順序</p>
<h4 id="渲染場景"><a href="#渲染場景" class="headerlink" title="渲染場景"></a>渲染場景</h4><p><a href="https://github.com/mrdoob/three.js/blob/e3ee9682fb2c776cd77fd8b89f73c321945fa52c/src/renderers/WebGLRenderer.js#L1824">WebGLRenderer.js 檔案裡的 renderScene 函式</a> 負責渲染場景中的所有物體，在這函式之中可以得知物體渲染的順序為：</p>
<p><strong>不透明物體(opaqueObjects)</strong> &#x3D;&gt; <strong>透光物體(transmissiveObjects)</strong> &#x3D;&gt; <strong>透明物體(transparentObjects)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderScene</span>(<span class="params">currentRenderList, scene, camera, viewport</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opaqueObjects = currentRenderList.<span class="property">opaque</span>;</span><br><span class="line">  <span class="keyword">const</span> transmissiveObjects = currentRenderList.<span class="property">transmissive</span>;</span><br><span class="line">  <span class="keyword">const</span> transparentObjects = currentRenderList.<span class="property">transparent</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opaqueObjects.<span class="property">length</span> &gt; <span class="number">0</span>) <span class="title function_">renderObjects</span>(opaqueObjects, scene, camera);</span><br><span class="line">  <span class="keyword">if</span> (transmissiveObjects.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">renderObjects</span>(transmissiveObjects, scene, camera);</span><br><span class="line">  <span class="keyword">if</span> (transparentObjects.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">renderObjects</span>(transparentObjects, scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>renderScene</code> 函式中場景的所有物體在 <code>currentRenderList</code> 中就已經被分為三個種類依序繪製，接著可以順著查到 <code>currentRenderList</code> 這個變數被定義在 <a href="https://github.com/mrdoob/three.js/blob/e3ee9682fb2c776cd77fd8b89f73c321945fa52c/src/renderers/WebGLRenderer.js">WebGLRenderer.js</a> 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renderLists = <span class="keyword">new</span> <span class="title class_">WebGLRenderLists</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">currentRenderList = renderLists.<span class="title function_">get</span>(scene, renderListStack.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<p><code>currentRenderList</code> 是 <code>renderLists.get</code> 函式中所拿出的一個變數，而 <code>renderLists</code> 是 <a href="https://github.com/mrdoob/three.js/blob/c92a3ff1be840824a98470c3307658b98b197155/src/renderers/webgl/WebGLRenderLists.js#L191">WebGLRenderLists</a> 創造的實例，至於 <code>renderLists.get</code> 回傳的會是 <a href="https://github.com/mrdoob/three.js/blob/c92a3ff1be840824a98470c3307658b98b197155/src/renderers/webgl/WebGLRenderLists.js#L50">WebGLRenderList</a> 類別，接著可以在 <code>WebGLRenderList</code> 函式中找到場景中的所有物體是怎麼被分為 <strong>三類(不透明、透光、透明)</strong> 進行處理的</p>
<h4 id="加入物體"><a href="#加入物體" class="headerlink" title="加入物體"></a>加入物體</h4><p>當把物體加進場景中時，根據 <a href="https://threejs.org/docs/#api/zh/materials/MeshPhysicalMaterial.transmission">MeshPhysicalMaterial.transmission</a> 跟 <a href="https://threejs.org/docs/#api/zh/materials/Material.transparent">Material.transparent</a> 的設置決定將物體分在哪一類的矩陣中，如果 <code>MeshPhysicalMaterial.transmission</code> 有設置代表是 <strong>透光物體</strong> 加入到 <code>transmissive</code> 矩陣中，或者 <code>Material.transparent</code> 有設置代表是 <strong>透明物體</strong> 加入到 <code>transparent</code> 矩陣中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WebGLRenderList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opaque = [];</span><br><span class="line">  <span class="keyword">const</span> transmissive = [];</span><br><span class="line">  <span class="keyword">const</span> transparent = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">object, geometry, material, groupOrder, z, group</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> renderItem = <span class="title function_">getNextRenderItem</span>(</span><br><span class="line">      object,</span><br><span class="line">      geometry,</span><br><span class="line">      material,</span><br><span class="line">      groupOrder,</span><br><span class="line">      z,</span><br><span class="line">      group</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (material.<span class="property">transmission</span> &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">      transmissive.<span class="title function_">push</span>(renderItem);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.<span class="property">transparent</span> === <span class="literal">true</span>) &#123;</span><br><span class="line">      transparent.<span class="title function_">push</span>(renderItem);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      opaque.<span class="title function_">push</span>(renderItem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序物體"><a href="#排序物體" class="headerlink" title="排序物體"></a>排序物體</h4><p>加入物體的步驟已經將場景中的所有物體分為三種不同的種類，接著還需要決定每個種類裡的物體渲染的優先順序，所以接著需要對 <code>opaque</code>, <code>transmissive</code>, <code>transparent</code> 這三個矩陣進行排序，在 <code>sort</code> 函式中傳入的 <code>customOpaqueSort</code> 與 <code>customTransparentSort</code> 分別是使用者可以從 <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setOpaqueSort">WebGLRenderer.setOpaqueSort</a> 與 <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setTransparentSort">WebGLRenderer.setTransparentSort</a> 帶進來自定義物體排序的函式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WebGLRenderList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">customOpaqueSort, customTransparentSort</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opaque.<span class="property">length</span> &gt; <span class="number">1</span>) opaque.<span class="title function_">sort</span>(customOpaqueSort || painterSortStable);</span><br><span class="line">    <span class="keyword">if</span> (transmissive.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">      transmissive.<span class="title function_">sort</span>(customTransparentSort || reversePainterSortStable);</span><br><span class="line">    <span class="keyword">if</span> (transparent.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">      transparent.<span class="title function_">sort</span>(customTransparentSort || reversePainterSortStable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果沒有帶入自定義排序的函式，就會套用 <strong>Three.js</strong> 預設的排序方式，對於 <strong>不透明物體</strong> 使用的是 <code>painterSortStable</code>，而 <strong>透光物體</strong> 與 <strong>透明物體</strong> 使用的是 <code>reversePainterSortStable</code></p>
<h6 id="painterSortStable"><a href="#painterSortStable" class="headerlink" title="painterSortStable"></a><a href="https://github.com/mrdoob/three.js/blob/c92a3ff1be840824a98470c3307658b98b197155/src/renderers/webgl/WebGLRenderLists.js#L1">painterSortStable</a></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">painterSortStable</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">groupOrder</span> !== b.<span class="property">groupOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">groupOrder</span> - b.<span class="property">groupOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">renderOrder</span> !== b.<span class="property">renderOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">renderOrder</span> - b.<span class="property">renderOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">material</span>.<span class="property">id</span> !== b.<span class="property">material</span>.<span class="property">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">material</span>.<span class="property">id</span> - b.<span class="property">material</span>.<span class="property">id</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">z</span> !== b.<span class="property">z</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">z</span> - b.<span class="property">z</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="reversePainterSortStable"><a href="#reversePainterSortStable" class="headerlink" title="reversePainterSortStable"></a><a href="https://github.com/mrdoob/three.js/blob/c92a3ff1be840824a98470c3307658b98b197155/src/renderers/webgl/WebGLRenderLists.js#L27">reversePainterSortStable</a></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reversePainterSortStable</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">groupOrder</span> !== b.<span class="property">groupOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">groupOrder</span> - b.<span class="property">groupOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">renderOrder</span> !== b.<span class="property">renderOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">renderOrder</span> - b.<span class="property">renderOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">z</span> !== b.<span class="property">z</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> b.<span class="property">z</span> - a.<span class="property">z</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>painterSortStable</code> 跟 <code>reversePainterSortStable</code> 排序函式中用到了 <code>groupOrder</code>, <code>renderOrder</code>, <code>material.id</code>, <code>z</code>, <code>id</code> 這幾個變數來決定物體渲染的順序，下面我們先來了解這些變數代表的意思</p>
<h6 id="groupOrder"><a href="#groupOrder" class="headerlink" title="- groupOrder"></a>- groupOrder</h6><p>來源於 <a href="https://github.com/mrdoob/three.js/blob/d0d0e1d8600e5b9818e456405a44e2c45e115a27/src/renderers/WebGLRenderer.js#L1710">projectObject 函式</a>，<code>projectObject</code> 的主要目的是將 <code>geometry</code>, <code>material</code> 等參數加入到 <code>currentRenderList</code> 中，這個函式的最後會遞歸遍歷 <code>object.children</code> 底下的所有物體</p>
<p>所以當某個 <strong>子物體(object)</strong> 的上一層是 <a href="https://threejs.org/docs/?q=group#api/zh/objects/Group">Group</a> 時，那麼這個子物體的 <code>groupOrder</code> 指的就是上一層 <code>Group</code> 的 <a href="https://threejs.org/docs/index.html?q=group#api/zh/core/Object3D.renderOrder">renderOrder</a>，而這個 <code>groupOrder</code> 變數是最優先在排序函式中進行判斷的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">projectObject</span>(<span class="params">object, camera, groupOrder, sortObjects</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (object.<span class="property">visible</span> === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> visible = object.<span class="property">layers</span>.<span class="title function_">test</span>(camera.<span class="property">layers</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (visible) &#123;</span><br><span class="line">    <span class="comment">// 這裡將 Group 的 renderOrder 設為 groupOrder</span></span><br><span class="line">    <span class="keyword">if</span> (object.<span class="property">isGroup</span>) &#123;</span><br><span class="line">      groupOrder = object.<span class="property">renderOrder</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> geometry = objects.<span class="title function_">update</span>(object);</span><br><span class="line">  <span class="keyword">const</span> material = object.<span class="property">material</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 將 geometry, material 等參數加入到 currentRenderList 中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(material)) &#123;</span><br><span class="line">    <span class="keyword">const</span> groups = geometry.<span class="property">groups</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = groups.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> group = groups[i];</span><br><span class="line">      <span class="keyword">const</span> groupMaterial = material[group.<span class="property">materialIndex</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (groupMaterial &amp;&amp; groupMaterial.<span class="property">visible</span>) &#123;</span><br><span class="line">        currentRenderList.<span class="title function_">push</span>(</span><br><span class="line">          object,</span><br><span class="line">          geometry,</span><br><span class="line">          groupMaterial,</span><br><span class="line">          groupOrder,</span><br><span class="line">          _vector4.<span class="property">z</span>,</span><br><span class="line">          group</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.<span class="property">visible</span>) &#123;</span><br><span class="line">    currentRenderList.<span class="title function_">push</span>(</span><br><span class="line">      object,</span><br><span class="line">      geometry,</span><br><span class="line">      material,</span><br><span class="line">      groupOrder,</span><br><span class="line">      _vector4.<span class="property">z</span>,</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍歷 object.children 底下的所有物體</span></span><br><span class="line">  <span class="keyword">const</span> children = object.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// groupOrder 來自於上一層 Group 的 object.renderOrder</span></span><br><span class="line">    <span class="title function_">projectObject</span>(children[i], camera, groupOrder, sortObjects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="renderOrder"><a href="#renderOrder" class="headerlink" title="- renderOrder"></a>- renderOrder</h6><p>指的就是物體的 <a href="https://threejs.org/docs/index.html?q=group#api/zh/core/Object3D.renderOrder">Object3D.renderOrder</a>，定義這個物體在場景中的渲染順序，在 <code>painterSortStable</code> 跟 <code>reversePainterSortStable</code> 中 <code>renderOrder</code> 對排序的影響是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> a.<span class="property">renderOrder</span> - b.<span class="property">renderOrder</span>;</span><br></pre></td></tr></table></figure>

<p>也就是說 <code>renderOrder</code> 的值越小，物體就會越先進行渲染</p>
<h6 id="material-id"><a href="#material-id" class="headerlink" title="- material.id"></a>- material.id</h6><p><a href="https://threejs.org/docs/index.html?q=material#api/zh/materials/Material.id">Material.id</a> 代表這個材質的唯一 id 值，在 <a href="https://github.com/mrdoob/three.js/blob/4e3db421aef677a668932b221b7dc2fc90ef1dd8/src/materials/Material.js#L41">Material.js</a> 檔案中 <code>id</code> 數值的計算是遞增的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _materialId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventDispatcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123; <span class="attr">value</span>: _materialId++ &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這代表越後面創建的 <code>Material</code>，其 <code>material.id</code> 的值就會越大</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>();</span><br><span class="line"><span class="keyword">const</span> material2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;material1 id&#x27;</span>, material1.<span class="property">id</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;material2 id&#x27;</span>, material2.<span class="property">id</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>回過頭來看 <code>painterSortStable</code> 中使用 <code>material.id</code> 排序的方式，代表當兩個物體用到不同的 <code>Material</code> 時，越後面創建的 <code>Material</code> 就會排在越後面進行渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> a.<span class="property">material</span>.<span class="property">id</span> - b.<span class="property">material</span>.<span class="property">id</span>;</span><br></pre></td></tr></table></figure>

<h6 id="z"><a href="#z" class="headerlink" title="- z"></a>- z</h6><p>代表的是深度值的 <code>z</code></p>
<ul>
<li><code>painterSortStable</code></li>
</ul>
<p><code>painterSortStable</code> 函式計算 <code>z</code> 的排序用的是 <code>return a.z - b.z</code>，這代表比較<strong>近</strong>的物體會先進行渲染</p>
<ul>
<li><code>reversePainterSortStable</code></li>
</ul>
<p><code>reversePainterSortStable</code> 函式計算 <code>z</code> 的排序用的是 <code>return b.z - a.z</code>，這代表比較<strong>遠</strong>的物體會先進行渲染</p>
<h6 id="id"><a href="#id" class="headerlink" title="- id"></a>- id</h6><p>指的是 <a href="https://threejs.org/docs/#api/zh/core/Object3D.id">Object3D.id</a>，跟 <code>material.id</code> 一樣是一個隨時間增加的變數</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Object3D</span>();</span><br><span class="line"><span class="keyword">const</span> object2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Object3D</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;object1 id&#x27;</span>, object1.<span class="property">id</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;object2 id&#x27;</span>, object2.<span class="property">id</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="排序函式解釋"><a href="#排序函式解釋" class="headerlink" title="排序函式解釋"></a>排序函式解釋</h4><p>介紹完以上這幾種套用在排序函式裡的變數，下面來解釋這兩個排序函式為什麼是這樣寫的</p>
<h5 id="painterSortStable-1"><a href="#painterSortStable-1" class="headerlink" title="- painterSortStable"></a>- painterSortStable</h5><p>預設套用在 <strong>不透明物體的</strong> <code>painterSortStable</code> 函式，決定物體渲染次序的優先級分別是：</p>
<ol>
<li><p><code>groupOrder</code>: 每個物體 <a href="https://threejs.org/docs/#api/zh/core/Object3D.parent">父層(Object3D.parent)</a> 的 <code>renderOrder</code>，最優先會根據父層元素的 <code>renderOrder</code> 來決定渲染順序</p>
</li>
<li><p><code>renderOrder</code>: 接著是由物體本身的 <code>renderOrder</code> 決定渲染順序，越低的 <code>renderOrder</code> 代表越先進行渲染</p>
</li>
<li><p><code>material.id</code>: 第三個順序是以物體 <code>material</code> 創建的順序決定，如果物體用到的 <code>material</code> 先被創建，那麼就會越先進行渲染，這裡我覺得蠻奇怪的，繪製順序應該跟 <code>material</code> 創建的順序沒什麼關聯才對，我覺得排第三個的順序應該要是深度值 <code>z</code>，物體的渲染順序應該跟物體離相機的距離 <code>z</code> 比較有關係，而不是<code>material</code> 創建的順序</p>
</li>
<li><p><code>z</code>: 第四個順序用 <strong>深度值 <code>z</code> - 物體離相機的距離</strong> 決定渲染的順序，深度值 <code>z</code> 越小也就是離相機越近的話，會越先進行渲染，為什麼 <code>z</code> 越小的越先進行渲染，請看後面的 <a href="./#1-%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E9%AB%94%EF%BC%8C%E9%A0%90%E8%A8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F%E6%98%AF-z-%E8%B6%8A%E5%B0%8F%E7%9A%84%E8%B6%8A%E5%85%88%E9%80%B2%E8%A1%8C%E6%B8%B2%E6%9F%93%EF%BC%9F">延伸閱讀 1. 為什麼不透明物體，預設的渲染順序是 z 越小的越先進行渲染？</a></p>
</li>
<li><p><code>id</code>: 最後的 <code>id</code> 代表的是物體本身創建的順序，越先創建的物體就會越先進行渲染</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">painterSortStable</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">groupOrder</span> !== b.<span class="property">groupOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">groupOrder</span> - b.<span class="property">groupOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">renderOrder</span> !== b.<span class="property">renderOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">renderOrder</span> - b.<span class="property">renderOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">material</span>.<span class="property">id</span> !== b.<span class="property">material</span>.<span class="property">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">material</span>.<span class="property">id</span> - b.<span class="property">material</span>.<span class="property">id</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">z</span> !== b.<span class="property">z</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">z</span> - b.<span class="property">z</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="reversePainterSortStable-1"><a href="#reversePainterSortStable-1" class="headerlink" title="- reversePainterSortStable"></a>- reversePainterSortStable</h5><p>預設套用在 <strong>透光物體</strong> 與 <strong>透明物體</strong> 的 <code>reversePainterSortStable</code> 函式，決定物體渲染次序的優先級分別是：</p>
<ol>
<li><p><code>groupOrder</code>: 跟上面一樣 <code>groupOrder</code> 越小越先進行渲染</p>
</li>
<li><p><code>renderOrder</code>: 跟上面一樣 <code>renderOrder</code> 越小越先進行渲染</p>
</li>
<li><p><code>z</code>: 深度值 <code>z</code> 是唯一與 <code>painterSortStable</code> 有所差別的地方，越大的 <code>z</code> 會越先進行渲染跟 <code>painterSortStable</code> 相反，這也是為什麼這個函式叫做 <code>reversePainterSortStable</code> 的原因，至於為什麼 <code>reversePainterSortStable</code> 中越大的 <code>z</code> 越先進行渲染呢？ 請看 <a href="./#2-%E7%82%BA%E4%BB%80%E9%BA%BC%E9%80%8F%E5%85%89%E7%89%A9%E9%AB%94%E3%80%81%E9%80%8F%E6%98%8E%E7%89%A9%E9%AB%94%EF%BC%8C%E9%A0%90%E8%A8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F%E6%98%AF-z-%E8%B6%8A%E5%A4%A7%E7%9A%84%E8%B6%8A%E5%85%88%E9%80%B2%E8%A1%8C%E6%B8%B2%E6%9F%93%EF%BC%9F">延伸閱讀 2. 為什麼透光物體、透明物體，預設的渲染順序是 z 越大的越先進行渲染？</a></p>
</li>
<li><p><code>id</code>: 跟上面一樣 <code>id</code> 越小越先進行渲染</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reversePainterSortStable</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">groupOrder</span> !== b.<span class="property">groupOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">groupOrder</span> - b.<span class="property">groupOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">renderOrder</span> !== b.<span class="property">renderOrder</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">renderOrder</span> - b.<span class="property">renderOrder</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="property">z</span> !== b.<span class="property">z</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> b.<span class="property">z</span> - a.<span class="property">z</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>今天的文章中探討了 <strong>Three.js</strong> 中物體渲染的順序，分別是 <strong>不透明物體(opaqueObjects)</strong> &#x3D;&gt; <strong>透光物體(transmissiveObjects)</strong> &#x3D;&gt; <strong>透明物體(transparentObjects)</strong>，接著也研究了這三類物體各自裡面又是怎麼利用 <a href="#%E6%8E%92%E5%BA%8F%E5%87%BD%E5%BC%8F%E8%A7%A3%E9%87%8B">排序函式</a> 決定物體先後的渲染順序，對於 <strong>不透明物體</strong> 來說預設採用的是 <code>painterSortStable</code> 函式， <code>z</code> 越小的話會越先進行渲染，但 <strong>透光物體及透明物體</strong> 預設的是採用 <code>reversePainterSortStable</code> 函式，<code>z</code> 越大的話會越先進行渲染</p>
<p>藉由前面幾篇系列文章可以了解深度測試的運作原理，加上今天學習三種不同種類物體的渲染順序，我們就可以清楚的理解在 <strong>Three.js</strong> 裡物體之間的遠近關係，以及當不同物體有前後重疊的關係時，最終畫面上呈現的應該會是哪個物體</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><h4 id="1-為什麼不透明物體，預設的渲染順序是-z-越小的越先進行渲染？"><a href="#1-為什麼不透明物體，預設的渲染順序是-z-越小的越先進行渲染？" class="headerlink" title="1. 為什麼不透明物體，預設的渲染順序是 z 越小的越先進行渲染？"></a>1. 為什麼不透明物體，預設的渲染順序是 <code>z</code> 越小的越先進行渲染？</h4><p>假設畫面上有兩個物體，<strong>紅色平面在前面(深度值較小)</strong> 及 <strong>藍色平面在後面(深度值較大)</strong>，如下圖所示：</p>
<img src="./two-plane.gif" style="width: 100%" />

<p>渲染 <strong>不透明物體</strong> 的順序有兩種方式，一種是先渲染 <strong>紅色平面</strong>，另一種先渲染 <strong>藍色平面</strong>：</p>
<h5 id="1-先渲染-紅色平面-z-小的先渲染"><a href="#1-先渲染-紅色平面-z-小的先渲染" class="headerlink" title="1. 先渲染 紅色平面 - z 小的先渲染"></a>1. 先渲染 <strong>紅色平面</strong> - z 小的先渲染</h5><p>先渲染 <strong>紅色平面</strong> 時，會先把整個 <strong>紅色平面</strong> 都畫上去，接著渲染 <strong>藍色平面</strong> 時，<strong>紅色平面</strong> 與 <strong>藍色平面</strong> 重疊的部分由於 <strong>藍色平面</strong> 的深度值較大會被捨棄，而 <strong>藍色平面</strong> 上沒有重疊的部分則是通過深度測試畫上去</p>
<h5 id="2-先渲染-藍色平面-z-大的先渲染"><a href="#2-先渲染-藍色平面-z-大的先渲染" class="headerlink" title="2. 先渲染 藍色平面 - z 大的先渲染"></a>2. 先渲染 <strong>藍色平面</strong> - z 大的先渲染</h5><p>先渲染 <strong>藍色平面</strong> 時，會把整個 <strong>藍色平面</strong> 都畫上去，接著渲染 <strong>紅色平面</strong> 時，因為整個 <strong>紅色平面</strong> 的深度值都較小所以整塊 <strong>紅色平面</strong> 都會通過深度測試而畫上螢幕</p>
<p>可以看到不論是先渲染 <strong>紅色平面</strong> 或是 先渲染 <strong>藍色平面</strong>，最後 <strong>紅色平面</strong> 都是在 <strong>藍色平面</strong> 前面的，那為什麼在 <strong>Three.js</strong> 裡渲染不透明物體時，預設使用的 <code>painterSortStable</code> 函式是採用 <code>z</code> 越小的越先進行渲染呢？這主要應該是性能的考量，以上面 <strong>狀況 1. 先渲染紅色平面</strong> 來看，曾經有被繪製到畫面上的有第一步的 <strong>紅色平面</strong> 以及第二步 <strong>不與紅色平面重疊的藍色平面部分</strong>，但如果是 <strong>狀況 2. 先渲染藍色平面</strong> 的話，第一步會繪製整個 <strong>藍色平面</strong>，第二步也會繪製整個 <strong>紅色平面</strong>，跟 <strong>狀況 1.</strong> 相比就多繪製了 <strong>紅色平面與藍色平面重疊的部分</strong></p>
<p>所以即使 <strong>不透明物體</strong> 先渲染 <code>z</code> 大或 <code>z</code> 小的物體最後在畫面上看起來都一樣，但以繪製畫面的步驟上來看，先渲染 <code>z</code> 小的物體可以避免多餘的渲染增加性能</p>
<h4 id="2-為什麼透光物體、透明物體，預設的渲染順序是-z-越大的越先進行渲染？"><a href="#2-為什麼透光物體、透明物體，預設的渲染順序是-z-越大的越先進行渲染？" class="headerlink" title="2. 為什麼透光物體、透明物體，預設的渲染順序是 z 越大的越先進行渲染？"></a>2. 為什麼透光物體、透明物體，預設的渲染順序是 <code>z</code> 越大的越先進行渲染？</h4><p>一樣假設畫面上有兩個物體，<strong>透明的紅色平面在前面(深度值較小)</strong> 及 <strong>透明的藍色平面在後面(深度值較大)</strong>，渲染 <strong>透明物體</strong> 一樣有兩種方式，<code>z</code> 小的先渲染或是 <code>z</code> 大的先渲染</p>
<h5 id="1-先渲染-透明紅色平面-z-小的先渲染"><a href="#1-先渲染-透明紅色平面-z-小的先渲染" class="headerlink" title="1. 先渲染 透明紅色平面 - z 小的先渲染"></a>1. 先渲染 <strong>透明紅色平面</strong> - z 小的先渲染</h5><p>先渲染 <strong>透明紅色平面</strong> 時，會先把整個 <strong>透明紅色平面</strong> 都畫上去，接著渲染 <strong>透明藍色平面</strong> 時，<strong>透明紅色平面</strong> 與 <strong>透明藍色平面</strong> 重疊的部分由於 <strong>透明藍色平面</strong> 的深度值較大會被捨棄，而 <strong>透明藍色平面</strong> 上沒有重疊的部分則是通過深度測試畫上去，最後畫面上呈現為：</p>
<img src="./transparent-z-order.png" style="width: 100%" />

<p>這時候會發現奇怪的地方是 <strong>透明紅色平面</strong> 因為是 <strong>透明物體</strong> 所以照理來說可以透過去看到後面的物體，但由於重疊部分後面的 <strong>透明藍色平面</strong> 沒有通過深度測試都被捨棄掉，最後在畫面上也就看不到了，因此採用 <code>z</code> 小先渲染的策略是有問題的，會導致透明物體後面的物體沒有渲染在畫面上</p>
<h5 id="2-先渲染-透明藍色平面-z-大的先渲染"><a href="#2-先渲染-透明藍色平面-z-大的先渲染" class="headerlink" title="2. 先渲染 透明藍色平面 - z 大的先渲染"></a>2. 先渲染 <strong>透明藍色平面</strong> - z 大的先渲染</h5><p>先渲染 <strong>透明藍色平面</strong> 時，會先把整個 <strong>透明藍色平面</strong> 都畫上去，接著渲染 <strong>透明紅色平面</strong> 時，由於 <strong>透明紅色平面</strong> 的深度值都較小所以整塊 <strong>透明紅色平面</strong> 都會通過深度測試而畫上螢幕，最後畫面上呈現為：</p>
<img src="./transparent-z-order-reverse.png" style="width: 100%" />

<p>這樣採用 <code>z</code> 大先渲染的順序才是對的，有辦法看得到在 <strong>透明物體</strong> 後面的東西</p>
<h4 id="3-為什麼透光物體的渲染次序放在第二個？"><a href="#3-為什麼透光物體的渲染次序放在第二個？" class="headerlink" title="3. 為什麼透光物體的渲染次序放在第二個？"></a>3. 為什麼透光物體的渲染次序放在第二個？</h4><p><strong>透光物體</strong>是一種類似玻璃的物體，調整 <a href="https://threejs.org/docs/#api/zh/materials/MeshPhysicalMaterial.transmission">透光率 MeshPhysicalMaterial.transmission</a> 可以改變透光的程度，官方提供的範例 - <a href="https://threejs.org/examples/#webgl_materials_physical_transmission">玻璃球</a> 可以看到這種物體在場景中的樣子</p>
<p>在 <code>renderScene</code> 函式中，<strong>透光物體</strong> 在 <strong>不透明物體</strong> <strong>“之後”</strong> 繪製的原因是，類似玻璃這樣的物質會反射場景中的<strong>不透明物體</strong>，因此需要等 <strong>不透明物體</strong> 在場景中都先渲染好了後，才能知道 <strong>不透明物體</strong> 投影在玻璃上應該呈現什麼樣子。而 <strong>透光物體</strong> 在 <strong>透明物體</strong> <strong>“之前”</strong> 渲染的原因是，在視線穿過 <strong>透明物體</strong> 時一樣有可能看到後面的 <strong>透光物體</strong>，為避免在後面的 <strong>透光物體</strong> 進行深度測試失敗導致 <strong>像素(fragment)</strong> 完全被丟棄，所以 <strong>透光物體</strong> 需要在 <strong>透明物體</strong> 之前進行繪製，這一段的說明我是詢問 chatGPT 得到的解答，乍看之下很有道理，但我覺得有某些部分是違反直覺的，例如：</p>
<ul>
<li><strong>透明物體</strong> 在 <strong>透光物體</strong> 後面時無法被看到</li>
</ul>
<p>由於 <strong>透明物體</strong> 是在 <strong>透光物體</strong> 之後渲染的，所以這代表只要 <strong>透明物體</strong> 在 <strong>透光物體</strong> 後面時永遠無法通過深度測試，所以就會直接消失，如下圖所示：</p>
<p><video src="https://bcjohn-public-static.s3.ap-southeast-2.amazonaws.com/threejs-transmissive-order.mp4" autoplay muted loop style="width: 100%"></video></p>
<p>我覺得這是蠻奇怪的一個行為，<strong>透光物體</strong> 可以設想為玻璃物體，正常來說透過玻璃應該都可以看到後面是什麼東西，不論他是 <strong>不透明物體</strong> 或是 <strong>透明物體</strong>，但在這種渲染次序的安排下，當後面的物體從 <strong>不透明物體</strong> 改變為 <strong>透明物體</strong> 時就會瞬間看不到，似乎不符合真實世界的樣子</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>本篇文章截圖所使用的 <a href="https://github.com/bcjohnblue/threejs-render-order">範例 repo</a></p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><ol>
<li>本文研究 Three.js 程式碼為 <a href="https://github.com/mrdoob/three.js/releases/tag/r176">r176</a> 版本</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://segmentfault.com/a/1190000041221932">THREE.js 渲染顺序</a><br><a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/">混合</a></p>
]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
  <entry>
    <title>Three.js 中物體的遠近關係 (4) - 對數深度值</title>
    <url>/blog/2025/03/17/three-js-%E4%B8%AD%E7%89%A9%E9%AB%94%E7%9A%84%E9%81%A0%E8%BF%91%E9%97%9C%E4%BF%82-4-%E5%B0%8D%E6%95%B8%E6%B7%B1%E5%BA%A6%E5%80%BC/</url>
    <content><![CDATA[<h6 id="此為-Three-js-中物體的遠近關係-系列文章-第-4-篇："><a href="#此為-Three-js-中物體的遠近關係-系列文章-第-4-篇：" class="headerlink" title="此為 Three.js 中物體的遠近關係 系列文章 - 第 4 篇："></a>此為 <strong>Three.js 中物體的遠近關係</strong> 系列文章 - 第 4 篇：</h6><ol>
<li><a href="/blog/2025/02/13/three-js-中物體的遠近關係-1-什麼是深度測試？/" target="_blank">Three.js 中物體的遠近關係 (1) - 什麼是深度測試？</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-2-左手-右手座標系與齊次座標/" target="_blank">Three.js 中物體的遠近關係 (2) - 左手&#x2F;右手座標系與齊次座標</a></li>
<li><a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/" target="_blank">Three.js 中物體的遠近關係 (3) - 深度值的計算方式</a></li>
<li><a href="/blog/2025/03/17/three-js-中物體的遠近關係-4-對數深度值/" target="_blank">Three.js 中物體的遠近關係 (4) - 對數深度值</a></li>
<li><a href="/blog/2025/03/31/three-js-中物體的遠近關係-5-渲染物體的順序/" target="_blank">Three.js 中物體的遠近關係 (5) - 渲染物體的順序</a></li>
<li><a href="/blog/2025/05/04/three-js-中物體的遠近關係-6-如何正確的渲染透明粒子？/" target="_blank">Three.js 中物體的遠近關係 (6) - 如何正確的渲染透明粒子？</a></li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇中我們知道<strong>透視投影</strong>的深度值 $ z_{depth} $ 和 $ 1&#x2F;z $ 成正比，如此與人眼感知的狀況相符，對於近處物體的分辨率較高，而遠處物體不容易分辨清楚互相的前後關係，大部分情況下這個深度值的轉換函式可以很好的描述物體的遠近，但如果套用到大尺度的場景，例如：太陽系、宇宙等，這種深度值的轉換函式就會出問題，這篇文章討論會出現哪些問題，以及最後如何使用對數深度值轉換函式解決</p>
<span id="more"></span>

<h2 id="深度值轉換函式的問題點"><a href="#深度值轉換函式的問題點" class="headerlink" title="深度值轉換函式的問題點"></a>深度值轉換函式的問題點</h2><p>上一篇文章中推導出深度值轉換的函式如下：</p>


$$
\large z_{depth} = \frac{1/z - 1/near}{1/far - 1/near}
$$



<div style="display: flex; justify-content: center;">
  <img src="./reciprocal.png" />
</div>

<p>以 <strong>Z-value</strong> 的範圍在 <strong>[1, 50]</strong> 來看，大約有九成的深度值都位在 <strong>Z-value</strong> 小於 10 的範圍內，這意味著離相機越遠的物體，深度值可以覆蓋的範圍越少，也就是說越遠的物體越難分辨他們的前後關係，對人眼來說這是正常的機制，但如果打算在 <strong>Three.js</strong> 中渲染大尺度的場景，可以想像位於非常遠處的兩個物體深度值會非常接近於 1，例如：0.9999991 v.s. 0.9999992，再加上電腦能儲存浮點數後的小數位數是有限制的，當四捨五入後兩個物體的深度值很有可能都等於 1，無法判別這兩個物體究竟誰在前誰在後，此時會看到畫面兩個物體互相重疊出現閃爍，這就是所謂的 <a href="https://en.wikipedia.org/wiki/Z-fighting">z-fighting 問題</a></p>
<h2 id="大尺度場景下導致的-z-fighting"><a href="#大尺度場景下導致的-z-fighting" class="headerlink" title="大尺度場景下導致的 z-fighting"></a>大尺度場景下導致的 z-fighting</h2><p><strong>Three.js</strong> 的其中一個 <a href="https://threejs.org/examples/#webgl_camera_logarithmicdepthbuffer">官方範例</a> 很好的展示了這個問題，畫面的左邊套用的是正常深度值轉換函式，也就是 $ z_{depth} $ 與 $ 1&#x2F;z $ 成正比，而右邊的是 <strong>Three.js</strong> 內建的對數深度值轉換函式，一進去這個場景會從  $ 10^{-6} \; \small m $  距離開始逐步將相機拉遠到  $ 10^{19} \; \small m $  遠的地方，從以下截圖可以看到當相機拉遠到太陽的尺度  $ 1.4 \times 10^{5} \; \small km $  時，左邊的畫面不斷閃爍出現很明顯的 <strong>z-fighting</strong></p>
<div style="display: flex; justify-content: center;">
  <img src="./scene-sun.png" />
</div>

<h2 id="對數深度值"><a href="#對數深度值" class="headerlink" title="對數深度值"></a>對數深度值</h2><p>在 <strong>Three.js</strong> 中啟用對數深度值的方式非常簡單，只要在 <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderer">WebGLRenderer</a> 中將 <code>logarithmicDepthBuffer</code> 設為 <code>true</code> 就好了，以上範例左、右畫面在實作上就只是 <code>logarithmicDepthBuffer</code> 有沒有開啟而已</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123; <span class="attr">logarithmicDepthBuffer</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>光調整一個參數就可以讓畫面的呈現有這麽大的差別真是神奇，以下讓我們來看看 <code>logarithmicDepthBuffer</code> 底層的邏輯是如何實作的</p>
<p>P.S. 在這之前建議先閱讀 <a href="/blog/2025/02/08/理解-three-js-的-shader-架構/" target="_blank">理解-three-js-的-shader-架構</a>，了解 <strong>Three.js</strong> 中的 shader 是如何作用的</p>
<h4 id="定義-USE-LOGDEPTHBUF-常數"><a href="#定義-USE-LOGDEPTHBUF-常數" class="headerlink" title="定義 USE_LOGDEPTHBUF 常數"></a>定義 USE_LOGDEPTHBUF 常數</h4><p>首先在 <a href="https://github.com/mrdoob/three.js/blob/a6bbc0e4e2126f075327d667973443060fdd9e63/src/renderers/webgl/WebGLProgram.js#L654">WebGLProgram.js</a> 檔案裡，當 <code>logarithmicDepthBuffer = true</code> 時，會在 shaders 中定義 <code>USE_LOGDEPTHBUF</code> 常數</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parameters.<span class="property">logarithmicDepthBuffer</span> ? <span class="string">&#x27;#define USE_LOGDEPTHBUF&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>當 <code>USE_LOGDEPTHBUF</code> 被定義時，會在 vertex shader 及 fragment shader 中添加一些變數，這些變數最後用來計算對數深度值</p>
<h4 id="Vertex-shader"><a href="#Vertex-shader" class="headerlink" title="Vertex shader"></a>Vertex shader</h4><ul>
<li><a href="https://github.com/mrdoob/three.js/blob/db7233612cb0d6372605f414c0fa955d01d7916b/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js">logdepthbuf_pars_vertex.glsl.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#ifdef USE_LOGDEPTHBUF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  varying float vFragDepth;</span></span><br><span class="line"><span class="string">  varying float vIsPerspective;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/mrdoob/three.js/blob/db7233612cb0d6372605f414c0fa955d01d7916b/src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js">logdepthbuf_vertex.glsl.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#ifdef USE_LOGDEPTHBUF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  vFragDepth = 1.0 + gl_Position.w;</span></span><br><span class="line"><span class="string">  vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Fragment-shader"><a href="#Fragment-shader" class="headerlink" title="Fragment shader"></a>Fragment shader</h4><ul>
<li><a href="https://github.com/mrdoob/three.js/blob/db7233612cb0d6372605f414c0fa955d01d7916b/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js">logdepthbuf_pars_fragment.glsl.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#if defined( USE_LOGDEPTHBUF )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  uniform float logDepthBufFC;</span></span><br><span class="line"><span class="string">  varying float vFragDepth;</span></span><br><span class="line"><span class="string">  varying float vIsPerspective;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/mrdoob/three.js/blob/db7233612cb0d6372605f414c0fa955d01d7916b/src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js">logdepthbuf_fragment.glsl.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#if defined( USE_LOGDEPTHBUF )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // Doing a strict comparison with == 1.0 can cause noise artifacts</span></span><br><span class="line"><span class="string">  // on some platforms. See issue #17623.</span></span><br><span class="line"><span class="string">  gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="對數深度值公式"><a href="#對數深度值公式" class="headerlink" title="對數深度值公式"></a>對數深度值公式</h2><p>其中最重要的變數是 <code>gl_FragDepth</code>，<a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/08%20Advanced%20GLSL/#:~:text=gl_FrontFacing%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89%E3%80%82-,gl_FragDepth,-%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fgl_FragCoord">gl_FragDepth</a> 代表這個 fragment 的深度值，在這個式子中先利用 <code>vIsPerspective</code> 判斷是否為透視投影，當 <code>vIsPerspective == 0</code> 時不是透視投影，深度值套用預設的 <code>gl_FragCoord.z</code>，那如果是透視投影的話套用 <code>log2( vFragDepth ) * logDepthBufFC * 0.5</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gl_FragDepth =</span><br><span class="line">  vIsPerspective == <span class="number">0.0</span></span><br><span class="line">    ? gl_FragCoord.<span class="property">z</span></span><br><span class="line">    : <span class="title function_">log2</span>(vFragDepth) * logDepthBufFC * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>vFragDepth</code> 與 <code>logDepthBufFC</code> 的數值是從其他檔案引入進來的：</p>
<ul>
<li><a href="https://github.com/mrdoob/three.js/blob/db7233612cb0d6372605f414c0fa955d01d7916b/src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js">logdepthbuf_vertex.glsl.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vFragDepth = <span class="number">1.0</span> + gl_Position.<span class="property">w</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/mrdoob/three.js/blob/4f03f16366ca4ca2a49d4f19b7ec2db2ac8b0736/src/renderers/WebGLRenderer.js#L2409">WebGLRenderer.js</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p_uniforms.<span class="title function_">setValue</span>(</span><br><span class="line">  _gl,</span><br><span class="line">  <span class="string">&#x27;logDepthBufFC&#x27;</span>,</span><br><span class="line">  <span class="number">2.0</span> / (<span class="title class_">Math</span>.<span class="title function_">log</span>(camera.<span class="property">far</span> + <span class="number">1.0</span>) / <span class="title class_">Math</span>.<span class="property">LN2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>綜合以上資訊，透視投影的對數深度值公式以數學形式表示如下：</p>


$$
z_{depth} = \log_2(1 + w) \times \frac{2}{\frac{\log_e(f + 1)}{\log_e2}} \times 0.5
$$



<p>套用以下已知條件，可以進一步將公式改寫：</p>
<h5 id="1-w-替換成-z"><a href="#1-w-替換成-z" class="headerlink" title="1. $ w $ 替換成 $ -z $"></a>1. $ w $ 替換成 $ -z $</h5><p>在上一篇文章 - <a href="/blog/2025/02/28/three-js-中物體的遠近關係-3-深度值的計算方式/#透視除法-Perspective-division" target="_blank">透視除法</a> 有求出 $ w &#x3D; -z $，$ w $ 位於 <strong>裁剪座標(clip coordinates)</strong> 下，而  $ z $ 位於 <strong>觀察座標(view coordinates)</strong></p>
<p>上面計算 <code>vFragDepth</code> 中的 <code>gl_Position.w</code> 指的是 <strong>螢幕座標 (screen coordinate)</strong> 下的 $ w $，由於<strong>裁剪座標</strong>的 $ w $ 在經過 <a href="https://www.songho.ca/opengl/gl_viewport.html">視口變換(viewport transform)</a> 成<strong>螢幕座標</strong>後 <a href="https://youtu.be/k55KvDFu3_4?t=680">$ w $ 維持不變</a>，因此計算 <code>vFragDepth</code> 中的 $ 1 + w $ 可以變成 $ 1 - z $，其中的 $ z $ 是<strong>觀察座標</strong>下的 $ z $</p>
<h5 id="2-改寫對數部分"><a href="#2-改寫對數部分" class="headerlink" title="2. 改寫對數部分"></a>2. 改寫對數部分</h5><p>套用 <a href="https://zh.wikipedia.org/zh-tw/%E5%AF%B9%E6%95%B0%E6%81%92%E7%AD%89%E5%BC%8F#%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F">換底公式、倒數公式</a>：</p>


$$
\begin{align*}
\displaystyle
\frac{2}{\frac{\log_e(f + 1)}{\log_e2}} \times 0.5 &= \frac{\log_e2}{\log_e(f + 1)} = \frac{1}{\log_2(f + 1)} \\
\end{align*}
$$



<p>所以改寫後的深度值如下：</p>


$$
z_{depth} = \frac{\log_2(-z + 1)}{\log_2(f + 1)}
$$



<h2 id="為什麼對數深度值的公式長這樣？"><a href="#為什麼對數深度值的公式長這樣？" class="headerlink" title="為什麼對數深度值的公式長這樣？"></a>為什麼對數深度值的公式長這樣？</h2><p>剛看到這個公式其實我想了很久，不知道為什麼對數深度值的公式是這個形式，後來研究許久後得出一些結論：</p>
<h5 id="1-為什麼分子是-z-1"><a href="#1-為什麼分子是-z-1" class="headerlink" title="1. 為什麼分子是 $ -z + 1 $ ?"></a>1. 為什麼分子是 $ -z + 1 $ ?</h5><p>一開始可以想到最簡單取對數的方式就是 $ \log_2{z} $，我們知道 $ z $ 的範圍會從 <strong>近平面(-n)</strong> 到 <strong>遠平面(-f)</strong>，其中<strong>近平面</strong>的距離可以小到完全接近相機也就是 $ z &#x3D; 0 $，此時深度值的函式會變成 $ z_{depth} &#x3D; \log_2{0} &#x3D; -\infty $，由於深度值的範圍定義在 <strong>[0, 1]</strong> 之間，所以很明顯這樣是不合理的，而當分子改成 $ -z + 1 $ 時， $ z_{depth} &#x3D; \log_2(-0 + 1) &#x3D; \log_21 &#x3D; 0 $，如此我們可以將 $ z $ 的最小值 $ 0 $ 正確映射到深度值區間的最小值 $ 0 $</p>
<h5 id="2-為什麼分母是-f-1"><a href="#2-為什麼分母是-f-1" class="headerlink" title="2. 為什麼分母是 $ f + 1 $ ?"></a>2. 為什麼分母是 $ f + 1 $ ?</h5><p>當 $ z $ 值拉到最遠等於 <strong>遠平面(-f)</strong> 時，分子會變成 $ z_{depth} &#x3D; \log_2(f + 1) $，為了要符合深度值最大為 $ 1 $ 的限制，因此就必須除以分母 $ \log_2(f + 1) $</p>
<h2 id="正常深度值與對數深度值的比較"><a href="#正常深度值與對數深度值的比較" class="headerlink" title="正常深度值與對數深度值的比較"></a>正常深度值與對數深度值的比較</h2><p>接著我們以一開始提到 <strong>Three.js</strong> 大尺度場景的範例來看深度值套用兩種不同公式間的差別，設定物體與相機的距離 $ z $ 範圍為 $ 10^{-6} $ 到 $ 10^{19} $，畫出正常深度值(左圖) 與 對數深度值(右圖)</p>
<div class="two-column">
  <div class="center">
    <b>正常深度值</b>
    <img src="./large-scale-reciprocal.png" />
  </div>
  <div class="center">
   <b>對數深度值</b>
    <img src="./large-scale-log.png" />
  </div>
</div>

<p>可以看到之前正常深度值的優點是符合人眼感知的狀況，在近的地方深度值覆蓋範圍大，適合分辨近處物體，但當場景需要容納大尺度的 $ z $ 值時，這就變成缺點了，可以看到從 $ 10^3 $ 左右一直到 $ 10^{18} $ 的距離，轉換成深度值後幾乎都等於 $ 1 $，這導致 shader 在判定物體的遠近時，兩個物體深度值的差異小到無法正確判別，就導致畫面上閃爍的 <strong>z-fighting</strong> 問題了。反過來看對數深度值則是在 $ 10^0 $ 到 $ 10^{18} $ 之間分佈平均，可以正常判別物體深度值之間的差異</p>
<h2 id="深度值的精度"><a href="#深度值的精度" class="headerlink" title="深度值的精度"></a>深度值的精度</h2><p>最終我們來討論深度值的精度是如何設置的，上面提到藉由比較兩個物體的深度值判斷誰應該在前誰應該在後，而在電腦中是以浮點數的方式儲存深度值的，當兩個浮點數的差值小到電腦無法分辨的時候就會引起 <strong>z-fighting</strong> 的問題。上面我們在 fragment shader 中使用 <code>gl_FragDepth</code> 賦予每個 fragment 的深度值，在 <a href="/blog/2024/12/06/使用-three-js-操作-shader-畫出國旗/#Shader-數值的精度設置" target="_blank">Shader 數值的精度設置</a> 的部分有提過，fragment shader 中可設置的精度有三種 - <strong>highp</strong>, <strong>mediump</strong>, <strong>lowp</strong></p>
<table>
<thead>
<tr>
<th>精細度</th>
<th>說明</th>
<th>適用場景</th>
</tr>
</thead>
<tbody><tr>
<td>highp</td>
<td>高精度 (32 位浮點數)</td>
<td>需要高精度的計算，例如：光照、物理模擬等</td>
</tr>
<tr>
<td>mediump</td>
<td>中精度 (16 位浮點數)</td>
<td>對精度要求中等的場景，例如：紋理 UV 坐標、顏色</td>
</tr>
<tr>
<td>lowp</td>
<td>低精度 (8 位浮點數)</td>
<td>不太需要精度的場景，例如：簡單的顏色計算</td>
</tr>
</tbody></table>
<p>在 Three.js 中創建 <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderer">WebGLRenderer</a> 時預設將 <strong>精度(precision)</strong> 設為 <strong>highp</strong>，或是在 <a href="https://threejs.org/docs/#api/en/materials/Material.precision">Material.precision</a> 中也可以個別修改 fragment 的<strong>精度</strong></p>
<p>接著我們以大尺度場景的範例來看，當 $ near &#x3D; 10^{-6}, far &#x3D; 10^{19} $ 時，兩個很遠的物體 $ z_1 &#x3D; 10^{15}, z_2 &#x3D; 10^{18} $ 時他們的深度值差異是多少：</p>
<ul>
<li>正常深度值的差異</li>
</ul>


$$
z_{depth1} = \frac{1/z_1 - 1/near}{1/far - 1/near} = \frac{10^{-15} - 10^6}{10^{-19} - 10^6} \approx \frac{-10^6}{-10^6} = 1
$$

$$
z_{depth2} = \frac{1/z_2 - 1/near}{1/far - 1/near} = \frac{10^{-18} - 10^6}{10^{-19} - 10^6} \approx \frac{-10^6}{-10^6} = 1
$$



<ul>
<li>對數深度值的差異</li>
</ul>


$$
z_{depth1} = \frac{\log_2(z_1 + 1)}{\log_2(far + 1)} = \frac{\log_2(10^{15} + 1)}{\log_2(10^{19} + 1)} \approx 0.7895
$$

$$
z_{depth2} = \frac{\log_2(z_2 + 1)}{\log_2(far + 1)} = \frac{\log_2(10^{18} + 1)}{\log_2(10^{19} + 1)} \approx 0.9474
$$



<p>由於電腦只能用有限的位數儲存浮點數，所以當數值相差過大的數值進行加減時，有些位數就會直接被忽略 (ex. $ 10^{-15} - 10^6 \approx -10^6 $)，所以正常深度值的公式至少在 $ z &gt; 10^{15} $ 以上的區間就已經無法分辨物體的遠近關係了，而對數深度值公式即使是 $ z $ 很大的狀況下一樣可以求出有效的深度值</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><h4 id="1-gl-FragDepth-的相容性"><a href="#1-gl-FragDepth-的相容性" class="headerlink" title="1. gl_FragDepth 的相容性"></a>1. gl_FragDepth 的相容性</h4><p><a href="https://registry.khronos.org/webgl/specs/latest/2.0/#5.33">gl_FragDepth</a> 是 WebGL 2.0 中改變 fragment 深度值的方式，在 WebGL 1.0 中則是使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth">gl_FragDepthEXT</a>，在 <strong>Three.js</strong> 的原始碼中對這部分進行了相容性的處理如果是 WebGL 1.0 的 <code>gl_FragDepthEXT</code> 的話會重新命名成 <code>gl_FragDepth</code>，因此最後賦予深度值的變數只需要使用 <code>gl_FragDepth</code> 就好</p>
<p><a href="https://github.com/mrdoob/three.js/blob/1095272ee053480256ea3b0d3a5827fc0340936f/src/renderers/webgl/WebGLProgram.js#L875">WebGLProgram.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prefixFragment = [</span><br><span class="line">  <span class="string">&#x27;#define varying in&#x27;</span>,</span><br><span class="line">  ( parameters.<span class="property">glslVersion</span> === <span class="title class_">GLSL3</span> ) ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;layout(location = 0) out highp vec4 pc_fragColor;&#x27;</span>,</span><br><span class="line">  ( parameters.<span class="property">glslVersion</span> === <span class="title class_">GLSL3</span> ) ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;#define gl_FragColor pc_fragColor&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;#define gl_FragDepthEXT gl_FragDepth&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="2-isPerspectiveMatrix-的實作"><a href="#2-isPerspectiveMatrix-的實作" class="headerlink" title="2. isPerspectiveMatrix 的實作"></a>2. isPerspectiveMatrix 的實作</h4><p>shader 中的 <code>isPerspectiveMatrix</code> 函式定義在 <code>common.glsl.js</code> 檔案中，是用投影矩陣的第三行第四列是否等於 -1 判斷透視投影矩陣</p>
<div class="two-column">
  <div class="center">
    <b>透視投影矩陣</b>
    

    $$
    \begin{bmatrix}
    \displaystyle \frac{2n}{r-l} & 0 & \displaystyle \frac{r+l}{r-l} & 0 \\
    0 & \displaystyle \frac{2n}{t-b} & \displaystyle \frac{t+b}{t-b} & 0 \\
    0 & 0 & \displaystyle -\frac{f+n}{f-n} & \displaystyle -\frac{2 f n}{f - n} \\
    0 & 0 & -1 & 0 \\
    \end{bmatrix}
    $$

    

  </div>
  <div class="center">
    <b>正交投影矩陣</b>
    

    $$
    \begin{bmatrix}
    \displaystyle \frac{1}{r} & 0 & 0 & 0 \\
    0 & \displaystyle \frac{1}{t} & 0 & 0 \\
    0 & 0 & \displaystyle -\frac{2}{f-n} & \displaystyle -\frac{f+n}{f-n} \\
    0 & 0 & 0 & 1 \\
    \end{bmatrix}
    $$

    

  </div>
</div>

<p>透視投影矩陣與正交投影矩陣的推導過程請見 <a href="https://hackmd.io/@23657689/projection_matrix#">Projection Matrix</a></p>
<p><a href="https://github.com/mrdoob/three.js/blob/1095272ee053480256ea3b0d3a5827fc0340936f/src/renderers/shaders/ShaderChunk/common.glsl.js#L88">common.glsl.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool <span class="title function_">isPerspectiveMatrix</span>(<span class="params"> mat4 m </span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m[ <span class="number">2</span> ][ <span class="number">3</span> ] == - <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-gl-FragCoord-z-的定義"><a href="#3-gl-FragCoord-z-的定義" class="headerlink" title="3. gl_FragCoord.z 的定義"></a>3. gl_FragCoord.z 的定義</h4><p>在 fragment shader 中可以取得的 <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml">gl_FragCoord</a> 是 OpenGL 中定義的變數，其中 <code>gl_FragCoord.z</code> 指的就是 <strong>[0, 1]</strong> 區間的深度值，因此當不是透視投影時(<code>vIsPerspective == 0.0</code>)，將預設的深度值 <code>gl_FragCoord.z</code> 賦值給 <code>gl_FragDepth</code></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gl_FragDepth</span> = vIsPerspective == <span class="number">0.0</span> ? <span class="built_in">gl_FragCoord</span>.z : <span class="built_in">log2</span>( vFragDepth ) * logDepthBufFC * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-issue-17623-的浮點數精度-bug"><a href="#4-issue-17623-的浮點數精度-bug" class="headerlink" title="4. issue #17623 的浮點數精度 bug"></a>4. issue #17623 的浮點數精度 bug</h4><p>在計算 <code>gl_FragDepth</code> 的地方有一段註解說明 <a href="https://github.com/mrdoob/three.js/issues/17623">issue #17623</a> 的 bug：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#if defined( USE_LOGDEPTHBUF )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // Doing a strict comparison with == 1.0 can cause noise artifacts</span></span><br><span class="line"><span class="string">  // on some platforms. See issue #17623.</span></span><br><span class="line"><span class="string">  gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>進一步查詢可以發現之前的程式是這樣寫的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">/* glsl */</span> <span class="string">`</span></span><br><span class="line"><span class="string">#if defined( USE_LOGDEPTHBUF )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  gl_FragDepth = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到計算深度值的邏輯完全沒變，差別只在以前是 <code>vIsPerspective == 1.0</code> 而現在是判斷 <code>vIsPerspective == 0.0</code>，經過一些研究後看起來是判斷 <code>vIsPerspective == 1.0</code> 時會有浮點數精度誤差的問題，也就是說有些 GPU 的實作 <code>1.0</code> 可能會變成 <code>0.99999994</code> 或 <code>1.0000001</code> 導致判斷失效，因此最後解決方案改為判斷 <code>vIsPerspective == 0.0</code></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html">Logarithmic depth buffer optimizations &amp; fixes</a><br><a href="https://blog.csdn.net/qq_21476953/article/details/141713244">Cesium 和 three.js 对数深度缓冲原理简析</a><br><a href="https://community.khronos.org/t/gl-fragcoord-z/54092">gl_FragCoord.z 的定義討論</a><br><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml">gl_FragCoord 官方文檔</a><br><a href="https://blog.csdn.net/fatcat123/article/details/103861403">gl_FragCoord 的含义</a><br><a href="https://stackoverflow.com/questions/57938025/how-does-a-camera-convert-from-clip-space-into-screen-space">How Does a camera convert from clip space into screen space?</a><br><a href="https://www.youtube.com/watch?v=k55KvDFu3_4">OpenGL clip space, NDC, and screen space</a></p>
<ul>
<li>浮點數精度<br><a href="https://vocus.cc/article/65ee9d51fd89780001eb4d59">淺談 DeepLearning 的浮點數精度 FP32&#x2F;FP16&#x2F;TF32&#x2F;BF16……..(以 LLM 為例)</a><br><a href="https://tigercosmos.xyz/post/2020/12/system/floating-number-cpu-gpu/">CPU 與 GPU 計算浮點數的差異</a><br><a href="https://polarisxu.studygolang.com/posts/basic/diagram-float-point/">15 张图带你深入理解浮点数</a><br><a href="https://zhaoshihan.github.io/posts/16352/">详解浮点数</a></li>
</ul>


<style>
.two-column {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;

  .center {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  img {
    width: 100%;
    object-fit: cover;
  }
}

table {
  th, td {
   padding: 8px 12px;
  } 
}

@media (max-width: 600px) {
  img {
      width: 100%;
  }
}

@media (min-width: 601px) {
  img {
      width: 75%;
  }
}
</style>


]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
  </entry>
</search>
